<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dailyProblem230210</title>
    <link href="/2023/02/11/dailyProblem230210/"/>
    <url>/2023/02/11/dailyProblem230210/</url>
    
    <content type="html"><![CDATA[<h4 id="1223-掷骰子模拟"><a href="#1223-掷骰子模拟" class="headerlink" title="1223. 掷骰子模拟"></a><a href="https://leetcode.cn/problems/dice-roll-simulation/">1223. 掷骰子模拟</a></h4><p>难度困难</p><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字 <code>i</code> 的次数不能超过 <code>rollMax[i]</code>（<code>i</code> 从 1 开始编号）。</p><p>现在，给你一个整数数组 <code>rollMax</code> 和一个整数 <code>n</code>，请你来计算掷 <code>n</code> 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模 <code>10^9 + 7</code></strong> 之后的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">2</span>, rollMax = <span class="hljs-string">[1,1,1,1,1,1]</span><br>输出：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">3</span>, rollMax = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">181</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>rollMax.length == 6</code></li><li><code>1 &lt;= rollMax[i] &lt;= 15</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>动态规划问题。</p><p>使用dp[i][j]来记录i位置时是j的序列数量，即长度为i的序列总数为dp[i][1~6]。</p><p>要怎么用上约束条件呢？</p><p>假设目前i位置上为X，分两种情况。</p><p>1，假如添加X后还没超过限制，就不做任何处理。</p><p>2，添加X后超过了限制，可知这必定是第一次超过限制，</p><p>如果都把可能性直接相加，那么可知是要减掉一些的。</p><p>假设数字5在第10位已经连续出现了4次，而5限制只能连续出现3次。那么就代表第6位是1，2，3，4，6。把这些数量减去就好了</p><p>于是状态方程为：<br>$$<br>\sum_{k&#x3D;1}^6dp[i-1][k] - \sum_{k&#x3D;1,k!&#x3D;j}^6dp[i-rollMax[j-1]-1][k]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; rollMax)</span> </span>&#123;<br>        vector&lt;vector&lt;LL&gt; &gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;LL&gt;(<span class="hljs-number">7</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>            dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>                <span class="hljs-comment">// 加入第 i-1 次得所有可能序列总数</span><br>                LL ans = <span class="hljs-built_in">accumulate</span>(dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(), dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<br>                <span class="hljs-type">int</span> idx = i - <span class="hljs-number">1</span> - rollMax[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span> (idx &gt;= <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 减去 i - 1 - rollMax[j-1]次掷出1，2，3，4，5 的所有序列总数</span><br>                    ans = <span class="hljs-built_in">accumulate</span>(dp[idx].<span class="hljs-built_in">begin</span>(), dp[idx].<span class="hljs-built_in">end</span>(), ans, [&amp;](LL init, LL e) &#123;<br>                        <span class="hljs-keyword">return</span> init + MOD - e;<br>                    &#125;);<br>                    ans += dp[idx][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 特殊情况处理</span><br>                    ans -= <span class="hljs-number">1</span>;<br>                &#125;<br>                dp[i][j] = ans % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp[n].<span class="hljs-built_in">begin</span>(), dp[n].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) % MOD;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230211</title>
    <link href="/2023/02/11/dailyProblem230211/"/>
    <url>/2023/02/11/dailyProblem230211/</url>
    
    <content type="html"><![CDATA[<h4 id="2335-装满杯子需要的最短总时长"><a href="#2335-装满杯子需要的最短总时长" class="headerlink" title="2335. 装满杯子需要的最短总时长"></a><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/">2335. 装满杯子需要的最短总时长</a></h4><p>难度简单47</p><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [1,4,2]<br>输出：4<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水。<br>可以证明最少需要<span class="hljs-number"> 4 </span>秒才能装满所有杯子。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [5,4,4]<br>输出：7<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 5 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 6 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 7 </span>秒：装满一杯热水。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> [5,0,0]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：每秒装满一杯冷水。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>amount.length == 3</code></li><li><code>0 &lt;= amount[i] &lt;= 100</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单的数学题，题中明确了只有三个杯子而一次可以倒两个杯子。</p><p>最少的次数肯定就是需求数量比较少的两个杯子之和与最多的那个杯子做差有关系。</p><p>因为一次能倒满两个杯子，就要争取每一次都有两个杯子可以倒。</p><p>用需求数量最多的杯子去调整剩下两个杯子的数量（使得用完最多的杯子的时候那两个杯子数量尽可能相等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fillCups</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; amount)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(amount.<span class="hljs-built_in">begin</span>(),amount.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>((amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>])&lt;=amount[<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> temp = amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>]-amount[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230208</title>
    <link href="/2023/02/08/dailyProblem230208/"/>
    <url>/2023/02/08/dailyProblem230208/</url>
    
    <content type="html"><![CDATA[<h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><p>难度中等</p><p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p><p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p><ul><li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/d/e&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>解释：<span class="hljs-string">&quot;/a/b&quot;</span> 是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹，而 <span class="hljs-string">&quot;/c/d/e&quot;</span> 是 <span class="hljs-string">&quot;/c/d&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>]<br>解释：文件夹 <span class="hljs-string">&quot;/a/b/c&quot;</span> 和 <span class="hljs-string">&quot;/a/b/d&quot;</span> 都会被删除，因为它们都是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: folder = [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出: [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= folder.length &lt;= 4 * 104</code></li><li><code>2 &lt;= folder[i].length &lt;= 100</code></li><li><code>folder[i]</code> 只包含小写字母和 <code>&#39;/&#39;</code></li><li><code>folder[i]</code> 总是以字符 <code>&#39;/&#39;</code> 起始</li><li>每个文件夹名都是 <strong>唯一</strong> 的</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>读完题目后，判断是否是子文件夹其实就是找子串。</p><p>因为目录的逻辑，解答的要求应该是，文件夹与子文件夹的路径只有开头部分重复。</p><p>并且按照文件夹的定义，字母间需要用 ‘&#x2F;’ 隔开。</p><p>所以解题的步骤就是，先将这些字符串排序（短的在前），然后给它添加一个 ‘&#x2F;’ 。</p><p>逐个验证是否是子串，如果是就标记为1，减少遍历次数以及标记答案。</p><p>因为即使是子串也有可能不是因为开头相同而匹配，所以还要额外验证一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = folder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(),folder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i] == <span class="hljs-number">0</span>)&#123;<br>                string temp = folder[i]+<span class="hljs-string">&#x27;/&#x27;</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(folder[j].<span class="hljs-built_in">find</span>(temp)!=folder[j].npos&amp;&amp;temp[<span class="hljs-number">1</span>]==folder[j][<span class="hljs-number">1</span>])&#123;<br>                        hash[j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i]==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(folder[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230208</title>
    <link href="/2023/02/08/dailyProblem230209/"/>
    <url>/2023/02/08/dailyProblem230209/</url>
    
    <content type="html"><![CDATA[<h4 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797. 设计一个验证系统"></a><a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></h4><p>难度中等</p><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code> 类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li></ul><p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：<br>[<span class="hljs-string">&quot;AuthenticationManager&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, null, null, null, <span class="hljs-number">0</span>]<br><br>解释：<br>AuthenticationManager authenticationManager = new AuthenticationManager(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 构造 AuthenticationManager ，设置 timeToLive = <span class="hljs-number">5</span> 秒。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">1</span> 时，没有验证码的 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> ，没有验证码被更新。<br>authenticationManager.generate(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">2</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的新验证码。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">6</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">6</span> 时，只有 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码未过期，所以返回 <span class="hljs-number">1</span> 。<br>authenticationManager.generate(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">7</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的新验证码。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，且 <span class="hljs-number">8</span> &gt;= <span class="hljs-number">7</span> ，所以时刻 <span class="hljs-number">8</span> 的renew 操作被忽略，没有验证码被更新。<br>authenticationManager.renew(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">10</span> 没有过期，所以 renew 操作会执行，该 token 将在时刻 <span class="hljs-number">15</span> 过期。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">15</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">15</span> 过期，tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，所有验证码均已过期，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li><li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>其实只是哈希表的分函数调用。所以均可访问的变量要在private定义。</p><p>用map给所有字符串和有效时间做映射，generate就初始化时间节点，renew就延长。</p><p>最后count的时候把所有字符串对应的时间和currentTime比较大小就可以返回答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> timeToLive;<br>    unordered_map&lt;string,<span class="hljs-type">int</span>&gt; valid;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AuthenticationManager</span>(<span class="hljs-type">int</span> timeToLive) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;timeToLive = timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        valid[tokenId] = currentTime + timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">renew</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (valid.<span class="hljs-built_in">count</span>(tokenId) &amp;&amp; valid[tokenId] &gt; currentTime) &#123;<span class="hljs-comment">//unorderedmap不能用find</span><br>            valid[tokenId] = currentTime + timeToLive;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countUnexpiredTokens</span><span class="hljs-params">(<span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//for (auto &amp;[_, time] : mp) &#123;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = valid.<span class="hljs-built_in">begin</span>();it!=valid.<span class="hljs-built_in">end</span>();it++)&#123;<br>            <span class="hljs-keyword">if</span> (it -&gt; second &gt; currentTime) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your AuthenticationManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * AuthenticationManager* obj = new AuthenticationManager(timeToLive);</span><br><span class="hljs-comment"> * obj-&gt;generate(tokenId,currentTime);</span><br><span class="hljs-comment"> * obj-&gt;renew(tokenId,currentTime);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;countUnexpiredTokens(currentTime);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading-02</title>
    <link href="/2022/12/03/PaperReading-02/"/>
    <url>/2022/12/03/PaperReading-02/</url>
    
    <content type="html"><![CDATA[<h1 id="Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences"><a href="#Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences" class="headerlink" title="Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences"></a>Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences</h1><h4 id="A-Paper-summary"><a href="#A-Paper-summary" class="headerlink" title="A. Paper summary"></a>A. Paper summary</h4><h4 id="Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions"><a href="#Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions" class="headerlink" title="Please provide a short summary of the paper that captures the key contributions."></a>Please provide a short summary of the paper that captures the key contributions.</h4><p>DNN inference tasks can be divided into two types according to whether it has real-time demand. However, current GPU scheduling systems don’t maintain throughput well while satisfying real-time preemption. To remedy this problem, this paper presented REEF, the first DNN inference serving system for commodity GPUs. It allows BE task to be executed with RT task without affecting it concurrently.</p><p>The two core technologies respectively are:</p><p>1, Reset-base Preemption: It is proved that the GPU based on DNN inference tasks is idempotent, so it can be quickly preempted by “kill”, and task can be recovery at breakpoints.</p><p>2, Dynamic Kernel Padding: Based on the observation of the predictability of delay of the GPU kernel of DNN inference tasks, the author proposes a controllable concurrent execution method, in the real-time kernel execution, according to its execution delay, dynamically fill the appropriate best-effort kernel with its concurrent execution.</p><h4 id="B-Key-strengths-and-weaknesses"><a href="#B-Key-strengths-and-weaknesses" class="headerlink" title="B. Key strengths and weaknesses"></a>B. Key strengths and weaknesses</h4><h4 id="Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively"><a href="#Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively" class="headerlink" title="Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively."></a>Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively.</h4><p>(+) REEF can preempt concurrent DNN tasks in Microsecond-scale.</p><p>(+) Compared with RT-Only in the DISB test, REEF can increase the throughput by 1.14~7.7 times under the premise of only increasing the latency of RT tasks by 2%.</p><p>(+) REEF are feasible for the closed-source GPUs, and evaluating result shows it reduces the preemption latency.</p><p>(-) When the execution time of best-effort kernels is often longer than that of real-time kernels, the throughput improvement of dynamic kernel padding may be trivial. But it also bring scheduling delay.</p><p>(-) Many commodity GPUs are closed-source, so REEF is unable to manipulate host queues and device queues directly.</p><p>(-) Latency predictability need to develop an offline kernel profiler to measure the computational requirements and the execution time. That is like a pretraining, which needs more time or computing power.</p><h4 id="C-Comments-to-authors"><a href="#C-Comments-to-authors" class="headerlink" title="C. Comments to authors"></a>C. Comments to authors</h4><h4 id="Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review"><a href="#Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review" class="headerlink" title="Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review."></a>Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review.</h4><p>For preemption, this paper shows REEF preemption delay is reduced by 15~18 times compared with existing methods. Not only promising RT tasks demand, but also maintain the throughput, which is instructive in some IoT scheme. Moreover, REEF-N runs on the closed-source GPUs such as NVIDIA and AMD GPUs. It’s available for Users and researchers. But the flaw is it cannot perform well as open source GPUs. In the end, I think if latency predicting judge RT tasks when they put into queue without offline measure in advance is better.</p><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1202</title>
    <link href="/2022/12/02/dailyProblem1202/"/>
    <url>/2022/12/02/dailyProblem1202/</url>
    
    <content type="html"><![CDATA[<h4 id="1769-移动所有球到每个盒子所需的最小操作数"><a href="#1769-移动所有球到每个盒子所需的最小操作数" class="headerlink" title="1769. 移动所有球到每个盒子所需的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/">1769. 移动所有球到每个盒子所需的最小操作数</a></h4><p>难度中等</p><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 <strong>一个</strong> 小球。</p><p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = &quot;110&quot;<br>输出：[1,1,3]<br>解释：每个盒子对应的最小操作数如下：<br>1) 第<span class="hljs-number"> 1 </span>个盒子：将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 1 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>2) 第<span class="hljs-number"> 2 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 2 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>3) 第<span class="hljs-number"> 3 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 2 </span>步操作。将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。共计<span class="hljs-number"> 3 </span>步操作。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">boxes </span>= <span class="hljs-string">&quot;001011&quot;</span><br>输出：[<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直观地理解，其实就是每一个小球都只能一步移动。</p><p>让所有球都集中到某个盒子，所需的次数其实就是小球与这个盒子的距离。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(string boxes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxes.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(boxes[j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans[i] += <span class="hljs-built_in">abs</span>(i-j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading_01</title>
    <link href="/2022/11/29/PaperReading-01/"/>
    <url>/2022/11/29/PaperReading-01/</url>
    
    <content type="html"><![CDATA[<h1 id="L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites"><a href="#L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites" class="headerlink" title="L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites"></a>L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites</h1><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><p>实时高分辨率的地球图片回传非常具有挑战性；因为轨道很低并且在高速移动。集中式架构的地面接收站会招致小时级别的数据下载延迟，并且因为造价原因难以扩展。作者希望降低数据回传时延。</p><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><p>L2D2——地面分布式站点设计。</p><p>是使用低成本的商品硬件提供低时延和鲁棒下载链接的混合地面站模型，只有一部分地面站有上行链路功能。还设计了用于调度和速率自适应的新算法，尽管仅接收地面站存在局限性，但仍可实现低延迟和高鲁棒性。</p><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><p>1，L2D2模型拥有全球分布式的地面站点</p><p>——使得卫星可以follow动态下行链路的调度，并降低了数据下行的时延。</p><p>2，混合式站点部署</p><p>——大部分站点只有接收功能，不传输任何数据，使得模型整体易于扩展。</p><p>3，低复杂度降低维护成本</p><p>——单个地面站没有专用设备，而是易于部署的商品硬件，通过多个地面站互补链路容量。</p><p>4，利用机器学习的方法来建模解决速率适应问题</p><p>——梯度提升回归树，基于深度学习的回归。</p><p><img src="C:\Users\Aki\OneDrive\桌面\model.png" alt="model"></p><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><p>使用真实世界链路质量测量和模拟的组合</p><p>作者从 X 波段运行的 16 对地面站-卫星和在 Ka 波段运行的 1 对地面站-卫星对中收集真实世界的数据，</p><p>使用从开源的SatNOGS地面站部署收集的数据用于仿真来评估L2D2，这些地站会监听政府和学术机构卫星的广播信号，数据放在一个公开数据集。选择了可运行的地面站并且进行了至少 1000 次观察。</p><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3><p>提出了新的模型：仅能下载的和上下行皆可的。其地理分布式以及新的调度方案、速率适应方案使得L2D2可以从大规模的LEO中经过数分钟成功下载数据，而传统的则需要几个小时。由于设计比较简单、低成本，所以易于推广。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1129</title>
    <link href="/2022/11/29/dailyProblem1129/"/>
    <url>/2022/11/29/dailyProblem1129/</url>
    
    <content type="html"><![CDATA[<h4 id="1758-生成交替二进制字符串的最少操作数"><a href="#1758-生成交替二进制字符串的最少操作数" class="headerlink" title="1758. 生成交替二进制字符串的最少操作数"></a><a href="https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/">1758. 生成交替二进制字符串的最少操作数</a></h4><p>给你一个仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code> ，或者将 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code> 。</p><p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code> 是交替字符串，而字符串 <code>&quot;0100&quot;</code> 不是。</p><p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;0100&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：如果将最后一个字符变为 &#x27;1&#x27; ，s 就变成 <span class="hljs-string">&quot;0101&quot;</span> ，即符合交替字符串定义。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：s 已经是交替字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：需要 <span class="hljs-number">2</span> 步操作得到 <span class="hljs-string">&quot;0101&quot;</span> 或 <span class="hljs-string">&quot;1010&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，答案字符串只有两种可能性，一种是0开头，另一种是1开头，然后让字符串s分别变成这两种字符串，取最小变化次数的一个就行。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;<br>        string s2 = s;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            cnt1++;<br>            s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i+<span class="hljs-number">1</span>])&#123;<br>                s[i+<span class="hljs-number">1</span>] = (s[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt1++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s2[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            cnt2++;<br>            s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s2.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s2[i]==s2[i+<span class="hljs-number">1</span>])&#123;<br>                s2[i+<span class="hljs-number">1</span>] = (s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cnt1,cnt2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LABOBASE TEST</title>
    <link href="/2022/11/18/LABOBASE-TEST/"/>
    <url>/2022/11/18/LABOBASE-TEST/</url>
    
    <content type="html"><![CDATA[<h1 id="再部署"><a href="#再部署" class="headerlink" title="再部署"></a>再部署</h1><p>在实验室也重新搭建了博客，以后用来update一些论文阅读，周报，以及题解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>LOG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/18/hello-world/"/>
    <url>/2022/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
