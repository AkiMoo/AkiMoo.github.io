<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>随记250324</title>
    <link href="/2025/03/24/%E9%9A%8F%E8%AE%B0250324/"/>
    <url>/2025/03/24/%E9%9A%8F%E8%AE%B0250324/</url>
    
    <content type="html"><![CDATA[<h1 id="担忧，迷茫，和焦虑"><a href="#担忧，迷茫，和焦虑" class="headerlink" title="担忧，迷茫，和焦虑"></a>担忧，迷茫，和焦虑</h1><p>时间也快到4月了，从现状分析，春招里早早投的公司反而都没给笔试面试机会。</p><p>3月8日笔试了mihoyo（心态不稳定+低级错误），3月20流程终止。</p><p>3月17日腾讯天美后台实习生岗一面，聊完问有无应届HC，当天流程终止。</p><p>3月21日笔试Ubisoft，体验外企的全英笔试，临场发挥乱答一通（不过代码题算是做出来了？原来外企笔试是不知道自己有无AC的，除了正确率还有性能评分，感觉还挺全面的）</p><p>3月23日晚鹰角笔试AK，但是听说AK了也可能泡池子一个月然后挂掉（悲</p><p>3月30日EA笔试预定。</p><p>还投了莉莉丝，库洛，叠纸，雷火，腾讯，都没给正式机会。时过境迁，大家都还是更想要厉害的实习生。去年这个时候只觉得，要有实习才好找工作，没怎么考虑过对不对口，要不要就地转正的问题。还是成长得太慢吧，去年心态没及时转变，导致现在想去游戏厂，抛开个人实力的因素还要再叠加一层应届生没面试机会的劣势。</p><p>但是过去的也已经不能重来。爸妈也很担心我的状态，也认可我真的想去追梦的心，不过到了后面如果时间来不及，大概也只能签南网防止失业，然后永别梦想？虽然不想接受，但不能让生活变得比这个还要糟糕。<br>手头的事情也还有很多，毕业论文开始动工了但也只写了一点点，月末就要查重了。找工作也不顺利，偏偏这样还是有很多米哈游的内推广告和在脉脉上主动加我的前辈，不管是不是只为了我能用他们的内推码，总归是呈现出一种需要招人的现状。越是这样越是气自己不争气。人生的机会，是真的转瞬即逝。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>250323HYPERGRYPH</title>
    <link href="/2025/03/24/250323HYPERGRYPH/"/>
    <url>/2025/03/24/250323HYPERGRYPH/</url>
    
    <content type="html"><![CDATA[<h1 id="HyperGryph笔试3月23日场次"><a href="#HyperGryph笔试3月23日场次" class="headerlink" title="HyperGryph笔试3月23日场次"></a>HyperGryph笔试3月23日场次</h1><p>因为之前看到了终末地的实机演示，也是符合心目中高质量游戏的标准，如果能进到这个组的话肯定是个好选择。<br>在周五刷牛客想翻翻历年题目或者面经什么的，但是相比mihoyo，腾讯，网易三大头部厂，信息量还是比较少。<br>印象中看到一位上交的硕士在秋招提前批投了这家，笔试全AC没给面，有点劝退。<br>不过对于目前的我来说，只能硬着头皮试一试，校招想要进游戏厂的话也只剩下这为数不多的几次机会了。</p><p>出乎意料的是，不知道是不是因为题目比较对我胃口？（偏数学归纳，推理）而且还是Leetcode那种不需要写输入输出的模式。<br>比较少有的笔试AK了，多少有点纪念意义，所以今天开存档记一下。</p><h2 id="1，使其变成不存在偶数长度回文子串的最少操作次数"><a href="#1，使其变成不存在偶数长度回文子串的最少操作次数" class="headerlink" title="1，使其变成不存在偶数长度回文子串的最少操作次数"></a>1，使其变成不存在偶数长度回文子串的最少操作次数</h2><p>给定一个只有小写字母的字符串，每次可以删除一个元素，要求最后返回的字符串，不包含长度为偶数的回文子串。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>既视感很强，偶数长度的回文子串中间两个肯定是相同的字母连续，所以只要找字符串中连续相同的字母，然后计数就行，最后直接返回计数值。</p><h2 id="2，使其变成非递减排列的最少操作次数"><a href="#2，使其变成非递减排列的最少操作次数" class="headerlink" title="2，使其变成非递减排列的最少操作次数"></a>2，使其变成非递减排列的最少操作次数</h2><p>给定一个乱序数组，每个数组元素对应有W,R两种标记。R标记的元素可以相互交换，要求变成非递减排列的最少操作次数。<br>数据范围是：N&lt;&#x3D;1e5，元素值范围是：1至N，每个元素只出现一次。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>一开始直接按照题目的思路，开了unordered_map去给元素和W&#x2F;R记号做映射。<br>但是再次读题发现他没让我返回不能操作的情况，那就是默认W记号位是必定正确的，就是要将R记号位的元素放到排序位置。<br>并且每个元素只出现一次，不就是桶排序？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(A[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">swap</span>(A[i],A[A[i]<span class="hljs-number">-1</span>])<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样操作完就是非递减排序了，但是只过了93.3%。<br>可以预见的是肯定会做多余的交换，比如需要交换元素个数超过三个，因为从前往后交换，可能会导致某个元素被交换多次。<br>当时是做完第三题回来做的，仔细考虑完如何做最理性交换，那不就是每次操作必定放好一个元素并不影响其他顺序吗？<br>既然如此，我开一个set记录我这一趟循环出现过的元素,不就是上帝视角答案吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>setHash.<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">while</span>(A[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">swap</span>(A[i],A[A[i]<span class="hljs-number">-1</span>])<br>    setHash.<span class="hljs-built_in">insert</span>(A[i]);   <br>&#125;<br>cnt+=setHash.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><p>（因为这个while循环中，一次交换中虽然涉及两个元素，但是只记录其中一个元素，是符合数学模型的。）</p><h2 id="3，使其变成连续目标子串的最少操作次数"><a href="#3，使其变成连续目标子串的最少操作次数" class="headerlink" title="3，使其变成连续目标子串的最少操作次数"></a>3，使其变成连续目标子串的最少操作次数</h2><p>给定一个长度为3N的字符串序列，A,K,S均出现N次，每次可以交换两个元素的位置，要求变成N个AKS子串的最少操作次数。<br>数据范围是：N&lt;&#x3D;1e5。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>可能是因为刚做完第二题桶排，这道题也很快反应过来，要将这三个字母分别放到最终位置上。<br>所以开6个计数器，分别记录在A位置的错误（K,S），在K位置的错误（A,S），在S位置的错误（A,K）。<br>然后这些错误位置分别作最佳交换，比如K错误的A，就和A错误的K交换。<br>这样交换完会剩下3组盈余组，难点在于怎么去计算这三个盈余组的次数。<br>通过自己模拟，发现其实是循环交换，因为给定每个元素都是N次，所以剩下的肯定也是3个一组做交换的，3个一组需要交换两次。<br><strong>最后的公式是ans +（res1+res2+res3）&#x2F;3*2</strong>；</p><p>简单说一下证明，如果res1&#x2F;2&#x2F;3任一个是0，就证明其中某个元素已经不存在错误位置了，那剩下的两组的错误位置需要两两交换。<br>但是在此前已经做完了所有两组组合的交换了，所以矛盾，故最后的这种情况必然是均不为0，然后3个一组做循环交换。<br>PS：一开始还看错题了，以为要做AAKKSS,结果是AKSAKS，浪费了半小时（笨</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记250310-2</title>
    <link href="/2025/03/10/%E9%9A%8F%E8%AE%B0250310-2/"/>
    <url>/2025/03/10/%E9%9A%8F%E8%AE%B0250310-2/</url>
    
    <content type="html"><![CDATA[<h1 id="随便写点"><a href="#随便写点" class="headerlink" title="随便写点"></a>随便写点</h1><p>我也不知道是什么时候不甘于只当Player，萌生出要当Game Developer的想法。可能是9岁第一次玩战神2？又可能是在初中想自己创作一个集换式卡牌游戏？亦或者是，在大学选专业的时候？<br>似乎都不太重要，只是如今走到了这个人身节点，难免有点感叹，早干嘛去了？<br>其实也不能说自己没有思考过要怎么活，<br>只是答案太多，每个人都有自己的追求，各路参考，又似乎觉得什么都可以。<br>贪玩的时候，觉得不要选很忙的工作，不然没时间玩牌；上进的时候，又觉得要选最前沿的技术大厂。<br>想的总比做得多。</p><p>最近b站上看到了许多up主在本科期间就尝试各种创作制造，不论是游戏，音乐，建模，还是美术，拥有一门创造性的爱好一直都让我很羡慕。<br>自己什么都弄点皮毛，似乎觉得自己还是时间管理大神，什么都能学，什么都能会。<br>但是现实并不如此，我总在忙完所谓的正事后，急于寻找”放松“的机会，这种活法大概就是我平庸的体现。<br>在困难面前，我不是那个能坚持到最后的人，我会急于寻找现成的方案，草草了事。<br>或许我在内心深处知道，这样子成不了大事。日积月累，能力没什么长进也是事实。<br>当下，无非就是觉得，自己的前途要被这种傻瓜式的失误断送，觉得滑稽荒唐不可接受。<br>但是退一步来说，如果是终面，被面试官评判为能力不足，又或是单纯地不匹配，我就能接受这个结果了吗？<br>想必还是不能的。</p><p>我任性，我觉得我想要的东西进行努力之后就会得到。<br>可能是努力的方向不对，可能是我没有才能，又或者是还不够努力。<br>但今天想起我仍然没办法接受现实。<br>我也不知道该怎么办。<br>毕业论文没写多少，可能还要被老师说为什么不把最后的工作也发表了，指望那篇期刊准时接收吗？<br>如此一想便更想逃避。</p><p>我该怎么做才能在地球OL获得想要的结果呢？</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice-250310-1</title>
    <link href="/2025/03/10/Practice-250310-1/"/>
    <url>/2025/03/10/Practice-250310-1/</url>
    
    <content type="html"><![CDATA[<h1 id="LCP-63-弹珠游戏"><a href="#LCP-63-弹珠游戏" class="headerlink" title="LCP 63. 弹珠游戏"></a><a href="https://leetcode.cn/problems/EXvqDp/description/">LCP 63. 弹珠游戏</a></h1><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>换作一年前的我应该反反复复不能AC然后看答案，现在已经不觉得这种类型的题目难了。<br>但是一些状态光凭想象中写还是容易出错，反复debug浪费时间，或许真应该用一下纸笔再动手比较好。<br>今天想记一下这道题是两个点，一个是习惯的右自增，这个方式用来传参是错的。第二个是整数模运算，后退时不应该直接-1而应该是+（n-1）再模n，防止从0后退变成-1的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y, <span class="hljs-type">int</span> d)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(d%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)<br>            x--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d%<span class="hljs-number">4</span>==<span class="hljs-number">1</span>)<br>            y--;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d%<span class="hljs-number">4</span>==<span class="hljs-number">2</span>)<br>            x++;<br>        <span class="hljs-keyword">else</span><br>            y++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; plate, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-built_in">dir</span>(x,y,d);<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=plate.<span class="hljs-built_in">size</span>()||y&lt;<span class="hljs-number">0</span>||y&gt;=plate[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()||k&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(plate[x][y] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(plate[x][y] == <span class="hljs-string">&#x27;W&#x27;</span>)&#123;<br>            d = (d+<span class="hljs-number">1</span>)%<span class="hljs-number">4</span>;<br>            <span class="hljs-comment">//不能return k--，这样返回的值是整个递归结束再减</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(plate,x,y,d,--k);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(plate[x][y] == <span class="hljs-string">&#x27;E&#x27;</span>)&#123;<br>            d = (d+<span class="hljs-number">3</span>)%<span class="hljs-number">4</span>;<span class="hljs-comment">//单纯-1的话可能变成-1，注意</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(plate,x,y,d,--k);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(plate,x,y,d,--k);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ballGame</span>(<span class="hljs-type">int</span> num, vector&lt;string&gt;&amp; plate) &#123;<br>        <span class="hljs-type">int</span> n = plate.<span class="hljs-built_in">size</span>(), m = plate[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>                <span class="hljs-keyword">if</span>(plate[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;(j!=<span class="hljs-number">0</span>&amp;&amp;j!=m<span class="hljs-number">-1</span>))&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(plate,i,j,<span class="hljs-number">2</span>,num))<br>                            ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>&amp;&amp;(i!=<span class="hljs-number">0</span>&amp;&amp;i!=n<span class="hljs-number">-1</span>))&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(plate,i,j,<span class="hljs-number">3</span>,num))<br>                            ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>&amp;&amp;(j!=<span class="hljs-number">0</span>&amp;&amp;j!=m<span class="hljs-number">-1</span>))&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(plate,i,j,<span class="hljs-number">0</span>,num))<br>                            ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j==m<span class="hljs-number">-1</span>&amp;&amp;(i!=<span class="hljs-number">0</span>&amp;&amp;i!=n<span class="hljs-number">-1</span>))&#123;<br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(plate,i,j,<span class="hljs-number">1</span>,num))<br>                            ans.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机250310</title>
    <link href="/2025/03/10/%E9%9A%8F%E6%9C%BA250310/"/>
    <url>/2025/03/10/%E9%9A%8F%E6%9C%BA250310/</url>
    
    <content type="html"><![CDATA[<h1 id="写在之后"><a href="#写在之后" class="headerlink" title="写在之后"></a>写在之后</h1><p>距离考完，已经一天多了。<br>说实话未曾想过是这样的收场。<br>真的是很不甘，有种努力付诸东流的感觉。<br>想过各种技不如人的结局，没想过是心态决定成败。<br>不知道cin读入空格会有问题，当时测试想过但也没细心验证；被所谓“签到题”包袱越压越紧，却没想过其实后面的，也可以尽力做做。<br>我一定很恨自己吧，说实话真赖不了，就是本科学习太浮于表面，计算机科学这门学科，是真的处处留意，摸通原理的，照本宣科拿来即用，这样的我即便真去到了生产岗位，也不见得能不给别人添麻烦。</p><p>很遗憾，可能我的游戏春招就到此结束了。<br>父亲跟我说人生处处都有机会，我还年轻，未来很长。<br>可我却觉得我已经老了，我害怕到达30岁，我害怕我的精力比不上更年轻一代，我害怕我还在走弯路，一直走不到梦想的尽头。<br>现实往往是残酷的，可这次的题目也不难，又怎么能怪老天爷不眷顾你呢。<br>人们常说机会总留给有准备的人，我自认也准备了，但还是抓不住机会，我是不是真的就这么不堪，这么无能呢。<br>如今的我被各种负面情绪困扰，各种自责的念头回旋，似乎有点不能正视“毕业“这件事。</p><p>拖了很久的毕业论文也该开始动工了，生活总要向前吧。<br>就算我不想认输，时间也不会等我，当然，时间本身已经给了多次机会给我了。<br>但至少，如果连毕业都毕业不了的话，更不能让别人信服你有能力吧。</p><p>如果能控制住自己不去想”以后可能无缘游戏行业“这个结果，或许我能更加轻松上阵。</p><p>太想了，我真的太想参与大型开发了。<br>如果可以，命运请给我回响吧，我不能再等了。</p><p>睡吧，身体如果不行了，人会更容易产生放弃的念头。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随记250307</title>
    <link href="/2025/03/07/%E9%9A%8F%E8%AE%B0250307/"/>
    <url>/2025/03/07/%E9%9A%8F%E8%AE%B0250307/</url>
    
    <content type="html"><![CDATA[<h1 id="写在笔试前夜"><a href="#写在笔试前夜" class="headerlink" title="写在笔试前夜"></a>写在笔试前夜</h1><p>明天就是mihoyo春招笔试了。<br>对于在去年11月才决定进入游戏行业的我，按照现在的情况，很可能是春招第一次且最后一次的机会了。<br>说来也惭愧，一直以来都没有很深入地思考，毕业之后的生活，等真正到来了，被时间推着不得不向前的时候，却又不能接受曾经随波逐流的自己。<br>常常觉得进入社会，要考虑收入，考虑稳定，考虑家庭，但这些东西说重要也不重要。<br>在进入大学之后，我发现我在对自己诚实这件事越来越懦弱：<br>比如总是幻想自己能用很短的时间解决一些事情；<br>比如觉得别人可以这样，那我也可以这样；<br>比如社会总体上认为什么好，那就是什么好。<br>终究在实习回来进入秋招周期的某天晚上，我才意识到，我其实也是有很多想做的事情。<br>我想做属于自己的游戏，我想成为旅拍摄影师，我想在某个领域获得杰出的成就，诸如此类。<br>但总以学生的心态，觉得“学习”这件事是要放在首位的，没怎么思考过，我到底，是要学什么，积累什么。<br>结果就是，在今天并没有积累够撬开大门的知识和技能。<br>但至少在那天晚上，我找回了勇气，我愿意用最后的校园时光拼一把。<br>为此，终于开始学习unity，把脑内的想法落实，实现gameplay的经历，让我收获了名为创造的快乐，原来那是这样的爽快。<br>我深知，目前的我，可能还不够资格进入我梦想中的gameplay岗位。但现在的我也算是尽力准备了，时间倒流回24年11月重来一遍，时间长河中的我大概也只会成为今天的我，所以一切都理应发生，一切都理应是，不完美但最好的状态。</p><p>所以，写在最后。希望命运这一次能眷顾我一次，我真的很想进mihoyo，参与大型游戏的开发，收获一段珍贵的经历，为日后做出自己想要的内容，打好稳固的基础。愿一切顺利。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HeapSortTemplete</title>
    <link href="/2025/02/28/HeapSortTemplete/"/>
    <url>/2025/02/28/HeapSortTemplete/</url>
    
    <content type="html"><![CDATA[<h2 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h2><p>自己写的Version1，建堆是按照定义来的，但是每次都在建堆，复杂度还是n平方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;i&gt;=low;i--)&#123;<br>            <span class="hljs-type">int</span> lson = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,rson = i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(lson&lt;n&amp;&amp;nums[i]&lt;nums[lson])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[lson]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rson&lt;n&amp;&amp;nums[i]&lt;nums[rson])&#123;<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[rson]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">HeapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">buildHeap</span>(nums,<span class="hljs-number">0</span>,n-i);<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>],nums[n-i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">HeapSort</span>(nums);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h2><p>每次只做堆调整，建堆只做一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">maxHeapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(low*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;n)&#123;<br>            <span class="hljs-type">int</span> lson = low*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,rson = low*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> maxIndex = low;<br>            <span class="hljs-keyword">if</span>(lson&lt;n&amp;&amp;nums[lson]&gt;nums[maxIndex])&#123;<br>                maxIndex = lson;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(rson&lt;n&amp;&amp;nums[rson]&gt;nums[maxIndex])&#123;<br>                maxIndex = rson;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(maxIndex!=low)&#123;<br>                <span class="hljs-built_in">swap</span>(nums[low],nums[maxIndex]);<br>                low = maxIndex;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildMaxHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-built_in">maxHeapify</span>(nums,i,n);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">HeapSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">buildMaxHeap</span>(nums);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>],nums[n-i<span class="hljs-number">-1</span>]);<br>            <span class="hljs-built_in">maxHeapify</span>(nums,<span class="hljs-number">0</span>,n-i<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">HeapSort</span>(nums);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MergeSortTemplete</title>
    <link href="/2025/02/28/MergeSortTemplete/"/>
    <url>/2025/02/28/MergeSortTemplete/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(r&lt;=l)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums,l,mid);<br>        <span class="hljs-built_in">mergeSort</span>(nums,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-type">int</span> i = l, j = mid+<span class="hljs-number">1</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[j])&#123;<br>                temp[cnt] = nums[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                temp[cnt] = nums[j];<br>                j++;<br>            &#125;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>            temp[cnt++] = nums[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;=r)&#123;<br>            temp[cnt++] = nums[j++];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r-l+<span class="hljs-number">1</span>;i++)&#123;<br>            nums[i+l] = temp[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        temp.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">mergeSort</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Solution s;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res=s.<span class="hljs-built_in">sortArray</span>(nums);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QuickSortTemplete</title>
    <link href="/2025/02/28/QuickSortTemplete/"/>
    <url>/2025/02/28/QuickSortTemplete/</url>
    
    <content type="html"><![CDATA[<h1 id="1-QuickSortTemplete"><a href="#1-QuickSortTemplete" class="headerlink" title="1. QuickSortTemplete"></a>1. QuickSortTemplete</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">Partition</span>(nums, l, r);<br>            <span class="hljs-built_in">quicksort</span>(nums,l,p<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">quicksort</span>(nums,p+<span class="hljs-number">1</span>,r);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-type">int</span> pivot=nums[l];<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=pivot)&#123;<br>                r--;<br>            &#125;<br>            nums[l] = nums[r];<br>            <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;pivot)&#123;<br>                l++;<br>            &#125;<br>            nums[r] = nums[l];<br>        &#125;<br>        nums[l] = pivot;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quicksort</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Solution s;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res=s.<span class="hljs-built_in">sortArray</span>(nums);<br>    cout&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, Base Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice_250227_5</title>
    <link href="/2025/02/27/Practice-250227-5/"/>
    <url>/2025/02/27/Practice-250227-5/</url>
    
    <content type="html"><![CDATA[<h1 id="1466-重新规划路线"><a href="#1466-重新规划路线" class="headerlink" title="1466. 重新规划路线"></a><a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/?envType=study-plan-v2&envId=leetcode-75">1466. 重新规划路线</a></h1><p><code>n</code> 座城市，从 <code>0</code> 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p><p>路线用 <code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 <code>a</code> 到 <code>b</code> 的一条有向路线。</p><p>今年，城市 <code>0</code> 将会举办一场大型比赛，很多游客都想前往城市 <code>0</code> 。</p><p>请你帮助重新规划路线方向，使每个城市都可以访问城市 <code>0</code> 。返回需要变更方向的最小路线数。</p><p>题目数据 <strong>保证</strong> 每个城市在重新规划路线方向后都能到达城市 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 6, connections = <span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[4,0]</span>,<span class="hljs-comment">[4,5]</span>]</span><br>输出：3<br>解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 5, connections = <span class="hljs-comment">[<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,2]</span>,<span class="hljs-comment">[3,4]</span>]</span><br>输出：2<br>解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">3</span>, connections = <span class="hljs-string">[[1,0],[2,0]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> &lt;= n &lt;= <span class="hljs-number">5</span> * <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br><span class="hljs-attribute">connections</span>.length == n-<span class="hljs-number">1</span><br><span class="hljs-attribute">connections</span>[i].length == <span class="hljs-number">2</span><br><span class="hljs-attribute">0</span> &lt;= connections[i][<span class="hljs-number">0</span>], connections[i][<span class="hljs-number">1</span>] &lt;= n-<span class="hljs-number">1</span><br><span class="hljs-attribute">connections</span>[i][<span class="hljs-number">0</span>] != connections[i][<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>今晚最后一题。<br>一开始直接用图的BFS方式广搜，超时。<br>在想如何优化时间，首先就肯定不能直接遍历，再读题，发现每个点只存在一条路。<br>然后只有出度需要计数。就想到了领接表的存储方式，每个点以正负数存储出入度（刚好这里0是起点，所以直接正负表示不会影响顶点出入的方向）。<br>然后用广搜，同样的压入队列操作（出度入度都要压），区别是出度要进行计数（路线反转）。<br>最后计数结果就是答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minReorder</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = connections.<span class="hljs-built_in">size</span>();<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">hash</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>            hash[connections[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(connections[i][<span class="hljs-number">1</span>]);<br>            hash[connections[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(-connections[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;hash[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-keyword">if</span>(hash[x][i]&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(visited[hash[x][i]]==<span class="hljs-number">0</span>)&#123;<br>                        q.<span class="hljs-built_in">push</span>(hash[x][i]);<br>                        cnt++;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(visited[-hash[x][i]]==<span class="hljs-number">0</span>)&#123;<br>                        q.<span class="hljs-built_in">push</span>(-hash[x][i]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            visited[x] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice_250227_4</title>
    <link href="/2025/02/27/Practice-250227-4/"/>
    <url>/2025/02/27/Practice-250227-4/</url>
    
    <content type="html"><![CDATA[<h1 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/description/?envType=study-plan-v2&envId=leetcode-75">547. 省份数量</a></h1><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：isConnected = <span class="hljs-string">[[1,1,0],[1,1,0],[0,0,1]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：isConnected = <span class="hljs-string">[[1,0,0],[0,1,0],[0,0,1]]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">200</span><br><span class="hljs-attribute">n</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> isConnected.length<br><span class="hljs-attribute">n</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> isConnected[i].length<br>isConnected[i][j] 为 <span class="hljs-number">1</span> 或 <span class="hljs-number">0</span><br>isConnected[i][i] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>isConnected[i][j] <span class="hljs-operator">=</span><span class="hljs-operator">=</span> isConnected[j][i]<br></code></pre></td></tr></table></figure><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>经典图论题，既可以将所有邻居压入队列，做BFS。又可以针对某个点出发，做DFS。<br>已经相对熟练了。计数法如果用DFS的话，用点的个数减去联通分量比较好，BFS的话就可以逐个计算连通分量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-type">int</span> i, vector&lt;<span class="hljs-type">int</span>&gt;&amp; visited)</span></span>&#123;<br>        visited[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;isConnected[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(isConnected[i][j]==<span class="hljs-number">1</span>&amp;&amp;visited[j]==<span class="hljs-number">0</span>)&#123;<br>                ans--;<br>                <span class="hljs-built_in">DFS</span>(isConnected,j,visited);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();<br>        ans = n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-built_in">DFS</span>(isConnected,i,visited);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++,LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice_250227_3</title>
    <link href="/2025/02/27/Practice-250227-3/"/>
    <url>/2025/02/27/Practice-250227-3/</url>
    
    <content type="html"><![CDATA[<h1 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=leetcode-75">994. 腐烂的橘子</a></h1><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><p>值 <code>0</code> 代表空单元格；<br>值 <code>1</code> 代表新鲜橘子；<br>值 <code>2</code> 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 <code>4</code> 个方向上相邻 的新鲜橘子都会腐烂。</p><p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[2,1,1],[1,1,0],[0,1,1]]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[2,1,1],[0,1,1],[1,0,1]]</span><br>输出：<span class="hljs-number">-1</span><br>解释：左下角的橘子（第 <span class="hljs-number">2</span> 行， 第 <span class="hljs-number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="hljs-number">4</span> 个方向上。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,2]]</span><br>输出：<span class="hljs-number">0</span><br>解释：因为 <span class="hljs-number">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>第三道BFS练习题，关键点是在于检查能不能全部变腐烂。这里用的方法是检查两次剩余好的橘子数是否相等，如果相等说明必不可能全腐烂。其余部分已经算是熟练的内容了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> orangeCnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dir)</span></span>&#123;<br>        queue&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">2</span>)&#123;<br>                    q.<span class="hljs-built_in">emplace</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;i,j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>                <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>()[<span class="hljs-number">0</span>] + dir[i][<span class="hljs-number">0</span>], y = q.<span class="hljs-built_in">front</span>()[<span class="hljs-number">1</span>]+dir[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;n&amp;&amp;x&lt;m&amp;&amp;grid[x][y]==<span class="hljs-number">1</span>)&#123;<br>                    grid[x][y] = <span class="hljs-number">2</span>;<br>                    orangeCnt--;<br>                &#125;<br>            &#125;<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dir = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    orangeCnt++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> lastCnt=<span class="hljs-number">-1</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(orangeCnt&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(lastCnt==orangeCnt)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>            lastCnt = orangeCnt;<br>            <span class="hljs-built_in">BFS</span>(grid,m,n,dir);<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice_250227_2</title>
    <link href="/2025/02/27/Practice-250227-2/"/>
    <url>/2025/02/27/Practice-250227-2/</url>
    
    <content type="html"><![CDATA[<h1 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode.cn/problems/keys-and-rooms/description/?envType=study-plan-v2&envId=leetcode-75">841. 钥匙和房间</a></h1><p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p><p>当你进入一个房间，你可能会在里面找到一套 不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p><p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1],[2],[3],[]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>我们从 <span class="hljs-number">0</span> 号房间开始，拿到钥匙 <span class="hljs-number">1</span>。<br>之后我们去 <span class="hljs-number">1</span> 号房间，拿到钥匙 <span class="hljs-number">2</span>。<br>然后我们去 <span class="hljs-number">2</span> 号房间，拿到钥匙 <span class="hljs-number">3</span>。<br>最后我们去了 <span class="hljs-number">3</span> 号房间。<br>由于我们能够进入每个房间，我们返回 <span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：rooms = <span class="hljs-string">[[1,3],[3,0,1],[2],[0]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：我们不能进入 <span class="hljs-number">2</span> 号房间。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">n</span> <span class="hljs-operator">=</span><span class="hljs-operator">=</span> rooms.length<br><span class="hljs-number">2</span> &lt;<span class="hljs-operator">=</span> n &lt;<span class="hljs-operator">=</span> <span class="hljs-number">1000</span><br><span class="hljs-number">0</span> &lt;<span class="hljs-operator">=</span> rooms[i].length &lt;<span class="hljs-operator">=</span> <span class="hljs-number">1000</span><br><span class="hljs-number">1</span> &lt;<span class="hljs-operator">=</span> sum(rooms[i].length) &lt;<span class="hljs-operator">=</span> <span class="hljs-number">3000</span><br><span class="hljs-number">0</span> &lt;<span class="hljs-operator">=</span> rooms[i][j] &lt; n<br>所有 rooms[i] 的值 互不相同<br></code></pre></td></tr></table></figure><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>继刚刚广搜的一道题。<br>每间钥匙对应一间房，每一轮拿完钥匙就把房间加入队列，然后逐个检查钥匙对应的房间。钥匙全部用完之后visited数组还存在值为0则返回false。</p><p>PS：如果是对visited数组进行计数的话，可以直接置一个计数值在循环内，最后比较那个值是否等于n，就不需要在数组里找0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = rooms.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(n)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; key_q;<br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rooms[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();i++)&#123;<br>            key_q.<span class="hljs-built_in">push</span>(rooms[<span class="hljs-number">0</span>][i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!key_q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(!hash[key_q.<span class="hljs-built_in">front</span>()])&#123;<br>                <span class="hljs-type">int</span> i = key_q.<span class="hljs-built_in">front</span>();<br>                hash[i] = <span class="hljs-number">1</span>;<br>                ans++;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;rooms[i].<span class="hljs-built_in">size</span>();k++)&#123;<br>                    <span class="hljs-keyword">if</span>(hash[rooms[i][k]] != <span class="hljs-number">1</span>)&#123;<br>                        key_q.<span class="hljs-built_in">push</span>(rooms[i][k]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            key_q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans==n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Practice_250227_1</title>
    <link href="/2025/02/27/Practice-250227-1/"/>
    <url>/2025/02/27/Practice-250227-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1926-迷宫中离入口最近的出口"><a href="#1926-迷宫中离入口最近的出口" class="headerlink" title="1926. 迷宫中离入口最近的出口"></a><a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/?envType=study-plan-v2&envId=leetcode-75">1926. 迷宫中离入口最近的出口</a></h1><p>给你一个 <code>m x n</code> 的迷宫矩阵 <code>maze</code> （下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 <code>entrance</code> ，用 <code>entrance = [entrancerow, entrancecol]</code> 表示你一开始所在格子的行和列。</p><p>每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code> <strong>最近</strong> 的出口。出口 的含义是 <code>maze</code> 边界 上的 空格子。<code>entrance</code> 格子 <strong>不算</strong> 出口。</p><p>请你返回从 <code>entrance</code> 到最近出口的最短路径的 <strong>步数</strong> ，如果不存在这样的路径，请你返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：maze = [[<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>],[<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]], entrance = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">1</span><br>解释：总共有 <span class="hljs-number">3</span> 个出口，分别位于 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)，(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) 和 (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) 。<br>一开始，你在入口格子 (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) 处。<br>- 你可以往左移动 <span class="hljs-number">2</span> 步到达 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 。<br>- 你可以往上移动 <span class="hljs-number">1</span> 步到达 (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) 。<br>从入口处没法到达 (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) 。<br>所以，最近的出口是 (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>) ，距离为 <span class="hljs-number">1</span> 步。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：maze = [[<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>,<span class="hljs-string">&quot;+&quot;</span>]], entrance = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">2</span><br>解释：迷宫中只有 <span class="hljs-number">1</span> 个出口，在 (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) 处。<br>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 不算出口，因为它是入口格子。<br>初始时，你在入口与格子 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 处。<br>- 你可以往右移动 <span class="hljs-number">2</span> 步到达 (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) 处。<br>所以，最近的出口为 (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) ，距离为 <span class="hljs-number">2</span> 步。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：maze = <span class="hljs-string">[[&quot;.&quot;,&quot;+&quot;]]</span>, entrance = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">-1</span><br>解释：这个迷宫中没有出口。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">maze<span class="hljs-selector-class">.length</span> == m<br>maze<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-class">.length</span> == n<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">100</span><br>maze<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span> 要么是 <span class="hljs-string">&#x27;.&#x27;</span> ，要么是 <span class="hljs-string">&#x27;+&#x27;</span> 。<br>entrance<span class="hljs-selector-class">.length</span> == <span class="hljs-number">2</span><br><span class="hljs-number">0</span> &lt;= entrancerow &lt; m<br><span class="hljs-number">0</span> &lt;= entrancecol &lt; n<br>entrance 一定是空格子。<br></code></pre></td></tr></table></figure><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>拿到题想都没想就DFS了，但是边界定位不够仔细，调了比较久。但是DFS在这道题超时了，因为DFS会一条路走到走不通才会往回走。<br>这道题要找最近的出口，应该选用BFS。<br>BFS练习得确实不够多，一开始pop的位置没放好，调了比较久。<br>还有一点就是多弄个额外位置去记录现在是第几层，这个层数要跟坐标绑定，并不能放在循环外加，否则会多加。</p><p>PS：这种不能回头的广搜直接将走过的格子变成墙就能省下visited数组的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(string &amp;num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-built_in">reverse</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>());<br>        stack&lt;<span class="hljs-type">char</span>&gt; s1,s2;<br>        <span class="hljs-type">int</span> mark1 = <span class="hljs-number">1000</span>,mark2=<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    s1.<span class="hljs-built_in">push</span>(num[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;5&#x27;</span>||num[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    s1.<span class="hljs-built_in">push</span>(num[i]);<br>                    mark1 = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;5&#x27;</span>)&#123;<br>                    s2.<span class="hljs-built_in">push</span>(num[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;5&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;2&#x27;</span>||num[i]==<span class="hljs-string">&#x27;7&#x27;</span>)&#123;<br>                    s2.<span class="hljs-built_in">push</span>(num[i]);<br>                    mark2 = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;s2.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(mark1,mark2) - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> mark1 - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> mark2 - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DailyMemo240729</title>
    <link href="/2024/07/29/DailyMemo240729/"/>
    <url>/2024/07/29/DailyMemo240729/</url>
    
    <content type="html"><![CDATA[<h1 id="记事——24年7月29日"><a href="#记事——24年7月29日" class="headerlink" title="记事——24年7月29日"></a>记事——24年7月29日</h1><p>最近开始习惯实习的节奏了，感觉每天的时间都过得很快。</p><p>上周Leader说让我去投正式校招，算是口头转正？（毕竟华为校招一定要走流程）</p><p>然后就是，虽然有了些改变，但是习惯上感觉还是挺依赖的，没办法说不玩游戏就马上做到。在这方面的行动力属实有点摆不上台面，总觉得不玩就亏了，每天玩一点时间也不影响。实际上加起来每天都有很多没用好的碎片时间，也会把整块的时间变成碎片时间，导致专注思考问题的时间反而不多了。这种心理应该是要克服的，要能专注于现实世界的事情。</p><p>时间越来越逼近八月了，这个月里距离自己上个月出发去实习给自己定下的预期，差距蛮大。行测没刷什么题目，项目呢又都只做了一半，总是完成了一个小模块就开始分心，这样非常不好。</p><p>上周跟阿礼花钱买了AI框架的课程，这也是我长这么大第一次为私人知识付费？不过比起干啃代码，别人能把东西做出来卖也是有他的道理，希望这钱没白花吧。尽量把学习的记录mark在博客。</p><p>今天也得知了算法的岗位也得手撕leetcode，那我觉得八月的主旋律是完成leetcodehot100以及部署好那个推理框架。把那些以前可能做过两三遍的题目重新好好认真再做一遍，时间真的不多了，要卯足劲啊，加油！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem240726</title>
    <link href="/2024/07/26/dailyProblem240726/"/>
    <url>/2024/07/26/dailyProblem240726/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-value-of-the-partition/">2740. 找出分区值</a></p><p>给你一个 <strong>正</strong> 整数数组 <code>nums</code> 。</p><p>将 <code>nums</code> 分成两个数组：<code>nums1</code> 和 <code>nums2</code> ，并满足下述条件：</p><ul><li>数组 <code>nums</code> 中的每个元素都属于数组 <code>nums1</code> 或数组 <code>nums2</code> 。</li><li>两个数组都 <strong>非空</strong> 。</li><li>分区值 <strong>最小</strong> 。</li></ul><p>分区值的计算方法是 <code>|max(nums1) - min(nums2)|</code> 。</p><p>其中，<code>max(nums1)</code> 表示数组 <code>nums1</code> 中的最大元素，<code>min(nums2)</code> 表示数组 <code>nums2</code> 中的最小元素。</p><p>返回表示分区值的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,2,4]<br>输出：1<br>解释：可以将数组 nums 分成 nums1 = [1,2] 和 nums2 = [3,4] 。<br>- 数组 nums1 的最大值等于<span class="hljs-number"> 2 </span>。<br>- 数组 nums2 的最小值等于<span class="hljs-number"> 3 </span>。<br>分区值等于 |2 - 3| =<span class="hljs-number"> 1 </span>。<br>可以证明<span class="hljs-number"> 1 </span>是所有分区方案的最小值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [100,1,10]<br>输出：9<br>解释：可以将数组 nums 分成 nums1 = [10] 和 nums2 = [100,1] 。 <br>- 数组 nums1 的最大值等于<span class="hljs-number"> 10 </span>。 <br>- 数组 nums2 的最小值等于<span class="hljs-number"> 1 </span>。 <br>分区值等于 |10 - 1| =<span class="hljs-number"> 9 </span>。 <br>可以证明<span class="hljs-number"> 9 </span>是所有分区方案的最小值。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>这道题有点幽默，要求将数组分为两组，返回其中一组的最大值与另一组最小值的差值。</p><p>如果只返回值的话根本不需要考虑怎么分，我只需要找出有序数组的相邻元素最少差值，然后在这个位置将元素分成两拨就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findValueOfPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res= INT_MAX;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            res=<span class="hljs-built_in">min</span>(res,<span class="hljs-built_in">abs</span>(nums[i]-nums[i<span class="hljs-number">-1</span>]));<br>    &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem240725</title>
    <link href="/2024/07/26/dailyProblem240725/"/>
    <url>/2024/07/26/dailyProblem240725/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/minimum-operations-to-make-a-special-number/">2844. 生成特殊数字的最少操作</a></p><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>num</code> ，表示一个非负整数。</p><p>在一次操作中，您可以选择 <code>num</code> 的任意一位数字并将其删除。请注意，如果你删除 <code>num</code> 中的所有数字，则 <code>num</code> 变为 <code>0</code>。</p><p>返回最少需要多少次操作可以使 <code>num</code> 变成特殊数字。</p><p>如果整数 <code>x</code> 能被 <code>25</code> 整除，则该整数 <code>x</code> 被认为是特殊数字。</p><p><strong>示例 1：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;2245047&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：删除数字 <span class="hljs-built_in">num</span>[<span class="hljs-number">5</span>] 和 <span class="hljs-built_in">num</span>[<span class="hljs-number">6</span>] ，得到数字 <span class="hljs-string">&quot;22450&quot;</span> ，可以被 <span class="hljs-number">25</span> 整除。<br>可以证明要使数字变成特殊数字，最少需要删除 <span class="hljs-number">2</span> 位数字。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;2908305&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：删除 <span class="hljs-built_in">num</span>[<span class="hljs-number">3</span>]、<span class="hljs-built_in">num</span>[<span class="hljs-number">4</span>] 和 <span class="hljs-built_in">num</span>[<span class="hljs-number">6</span>] ，得到数字 <span class="hljs-string">&quot;2900&quot;</span> ，可以被 <span class="hljs-number">25</span> 整除。<br>可以证明要使数字变成特殊数字，最少需要删除 <span class="hljs-number">3</span> 位数字。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;10&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：删除 <span class="hljs-built_in">num</span>[<span class="hljs-number">0</span>] ，得到数字 <span class="hljs-string">&quot;0&quot;</span> ，可以被 <span class="hljs-number">25</span> 整除。<br>可以证明要使数字变成特殊数字，最少需要删除 <span class="hljs-number">1</span> 位数字。<br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= num.length &lt;= 100</code></li><li><code>num</code> 仅由数字 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code> 组成</li><li><code>num</code> 不含任何前导零</li></ul><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>虽然这种处理很low，但是情况并不多，25的倍数结尾只有00，25，50，75这四种情况。</p><p>当然还要对0这种情况做特殊，解答如下（虽然啰嗦但是性能ok）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(string &amp;num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = num.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-built_in">reverse</span>(num.<span class="hljs-built_in">begin</span>(),num.<span class="hljs-built_in">end</span>());<br>        stack&lt;<span class="hljs-type">char</span>&gt; s1,s2;<br>        <span class="hljs-type">int</span> mark1 = <span class="hljs-number">1000</span>,mark2=<span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    s1.<span class="hljs-built_in">push</span>(num[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;5&#x27;</span>||num[i]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                    s1.<span class="hljs-built_in">push</span>(num[i]);<br>                    mark1 = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;5&#x27;</span>)&#123;<br>                    s2.<span class="hljs-built_in">push</span>(num[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;5&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(num[i]==<span class="hljs-string">&#x27;2&#x27;</span>||num[i]==<span class="hljs-string">&#x27;7&#x27;</span>)&#123;<br>                    s2.<span class="hljs-built_in">push</span>(num[i]);<br>                    mark2 = i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;s2.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(mark1,mark2) - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> mark1 - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> mark2 - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem240724</title>
    <link href="/2024/07/26/dailyProblem240724/"/>
    <url>/2024/07/26/dailyProblem240724/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/relocate-marbles/">2766. 重新放置石块</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，表示一些石块的初始位置。再给你两个长度 <strong>相等</strong> 下标从 <strong>0</strong> 开始的整数数组 <code>moveFrom</code> 和 <code>moveTo</code> 。</p><p>在 <code>moveFrom.length</code> 次操作内，你可以改变石块的位置。在第 <code>i</code> 次操作中，你将位置在 <code>moveFrom[i]</code> 的所有石块移到位置 <code>moveTo[i]</code> 。</p><p>完成这些操作后，请你按升序返回所有 <strong>有</strong> 石块的位置。</p><p><strong>注意：</strong></p><ul><li>如果一个位置至少有一个石块，我们称这个位置 <strong>有</strong> 石块。</li><li>一个位置可能会有多个石块。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]<br>输出：[5,6,8,9]<br>解释：一开始，石块在位置 1,6,7,8 。<br>第 i =<span class="hljs-number"> 0 </span>步操作中，我们将位置<span class="hljs-number"> 1 </span>处的石块移到位置<span class="hljs-number"> 2 </span>处，位置 2,6,7,8 有石块。<br>第 i =<span class="hljs-number"> 1 </span>步操作中，我们将位置<span class="hljs-number"> 7 </span>处的石块移到位置<span class="hljs-number"> 9 </span>处，位置 2,6,8,9 有石块。<br>第 i =<span class="hljs-number"> 2 </span>步操作中，我们将位置<span class="hljs-number"> 2 </span>处的石块移到位置<span class="hljs-number"> 5 </span>处，位置 5,6,8,9 有石块。<br>最后，至少有一个石块的位置为 [5,6,8,9] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,1,3,3]</span>, moveFrom = <span class="hljs-selector-attr">[1,3]</span>, moveTo = <span class="hljs-selector-attr">[2,2]</span><br>输出：<span class="hljs-selector-attr">[2]</span><br>解释：一开始，石块在位置 <span class="hljs-selector-attr">[1,1,3,3]</span> 。<br>第 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> 步操作中，我们将位置 <span class="hljs-number">1</span> 处的石块移到位置 <span class="hljs-number">2</span> 处，有石块的位置为 <span class="hljs-selector-attr">[2,2,3,3]</span> 。<br>第 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">1</span> 步操作中，我们将位置 <span class="hljs-number">3</span> 处的石块移到位置 <span class="hljs-number">2</span> 处，有石块的位置为 <span class="hljs-selector-attr">[2,2,2,2]</span> 。<br>由于 <span class="hljs-number">2</span> 是唯一有石块的位置，我们返回 <span class="hljs-selector-attr">[2]</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= moveFrom.length &lt;= 105</code></li><li><code>moveFrom.length == moveTo.length</code></li><li><code>1 &lt;= nums[i], moveFrom[i], moveTo[i] &lt;= 109</code></li><li>测试数据保证在进行第 <code>i</code> 步操作时，<code>moveFrom[i]</code> 处至少有一个石块。</li></ul><h1 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION"></a>SOLUTION</h1><p>实际顺序模拟，注意的地方就是最后要排序一次，还有移动要先置零再添加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">relocateMarbles</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; moveFrom, vector&lt;<span class="hljs-type">int</span>&gt;&amp; moveTo)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> n = moveFrom.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;total;i++)&#123;<br>            hash[nums[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> temp = hash[moveFrom[i]];<br>            hash[moveFrom[i]] = <span class="hljs-number">0</span>;<br>            hash[moveTo[i]]+=temp;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = hash.<span class="hljs-built_in">begin</span>();i!=hash.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second&gt;<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(i-&gt;first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DailyMemo240723</title>
    <link href="/2024/07/23/DailyMemo240723/"/>
    <url>/2024/07/23/DailyMemo240723/</url>
    
    <content type="html"><![CDATA[<h1 id="记事——24年7月23日"><a href="#记事——24年7月23日" class="headerlink" title="记事——24年7月23日"></a>记事——24年7月23日</h1><p>在上周回家弄好博客之后我就说要写一下日记，但各种犯懒又没能动手写，好在今天产出第一篇了，希望能坚持。</p><p>这个想法在考研的时候也有，不过没坚持下来，有时候会觉得如果我今天就是做了不少事情，那我不需要记录，他也化为了我的内在一部分。但是最近刷到了polebug的视频，又想起之前嘉炜也是长期坚持记录的习惯，让我重新审视Memo的价值。</p><p>它大概不在于说我今天做了多少多少有价值的行为，所以要把它记下来。而是记下来，在迷茫或者无聊之时，看看自己挣扎过，又或是快乐过的的痕迹。It is just simple。</p><hr><p>在华为工作的第三周，我还没开始写新的需求代码，可能是因为没什么值得给新人练手的任务，又或者是leader和mentor自己都忙不过来没办法兼顾指导。Anyway，保持自己的节奏学就好了。有一个我觉得困扰的地方是有一些文档和blog实在是看得想睡觉，可能是因为我看得太随意太杂，缺乏一定的目的性，可以考虑明天跟同事讨论一下修改一下我目前实习上的学习路线。毕竟如果8月结束我的简历上没办法描述我在华为两个月到底干了些啥，似乎也挺丢脸的。</p><p>在摸鱼的时候，我之前设想的大学模拟类GalGame的玩意儿又有了一些“又新又老”的想法，不过囿于目前的技术和美术的欠缺，这些不应该是我当前应该考虑的事情。于是我想先把我想到的比较简单的玩法，先写出来，那也算是摸索和积累了。在上周没搞明白的走格子地图要怎么设计，今天看到了一个cmd走迷宫的游戏，才发现底层逻辑其实是一致的，我要考虑移动，只需要每次行动完刷新cmd屏幕，就能显示当前的位置和状态了。于是自己写了一个比较简单的走迷宫的cpp（已经传到仓库）。明天如果有时间的话，看一下能不能实现一个走格子积分的小游戏。还有编译好的文件汉字现实是乱码，这个也需要解决。</p><p>今天还有一件值得说说的事情，在公司摸鱼写走迷宫的时候打算直接upload到仓库，结果公司那边打电话来提醒我不要贡献开源代码，差点就违反规定了，可能以后就算是在线编辑也要多加注意。</p><p>晚上和朋友又探讨了一下“花束般的恋爱”，讨论并交换了观点。不得不说我的表达欲望真是非常强，回过头来看又是自己输出一堆，如果那么想说干脆把每天的Memo当作垃圾桶好了，可能过几年回来看又有不一样的感触了。</p><p>今天就写到这里吧，还是有很多废话想说，明天提前预留半个小时记Memo吧，晚安。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Memo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem240127</title>
    <link href="/2024/07/17/dailyProblem240127/"/>
    <url>/2024/07/17/dailyProblem240127/</url>
    
    <content type="html"><![CDATA[<h4 id="2865-美丽塔-I"><a href="#2865-美丽塔-I" class="headerlink" title="2865. 美丽塔 I"></a><strong><a href="https://leetcode.cn/problems/beautiful-towers-i/">2865. 美丽塔 I</a></strong></h4><p>中等</p><p>提示</p><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>maxHeights</code> 。</p><p>你的任务是在坐标轴上建 <code>n</code> 座塔。第 <code>i</code> 座塔的下标为 <code>i</code> ，高度为 <code>heights[i]</code> 。</p><p>如果以下条件满足，我们称这些塔是 <strong>美丽</strong> 的：</p><ol><li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li><li><code>heights</code> 是一个 <strong>山脉</strong> 数组。</li></ol><p>如果存在下标 <code>i</code> 满足以下条件，那么我们称数组 <code>heights</code> 是一个 <strong>山脉</strong> 数组：</p><ul><li>对于所有 <code>0 &lt; j &lt;= i</code> ，都有 <code>heights[j - 1] &lt;= heights[j]</code></li><li>对于所有 <code>i &lt;= k &lt; n - 1</code> ，都有 <code>heights[k + 1] &lt;= heights[k]</code></li></ul><p>请你返回满足 <strong>美丽塔</strong> 要求的方案中，<strong>高度和的最大值</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：maxHeights = <span class="hljs-selector-attr">[5,3,4,1,1]</span><br>输出：<span class="hljs-number">13</span><br>解释：和最大的美丽塔方案为 heights = <span class="hljs-selector-attr">[5,3,3,1,1]</span> ，这是一个美丽塔方案，因为：<br>- <span class="hljs-number">1</span> &lt;= heights<span class="hljs-selector-attr">[i]</span> &lt;= maxHeights<span class="hljs-selector-attr">[i]</span>  <br>- heights 是个山脉数组，峰值在 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span> 处。<br><span class="hljs-number">13</span> 是所有美丽塔方案中的最大高度和。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：maxHeights = <span class="hljs-selector-attr">[6,5,3,9,2,7]</span><br>输出：<span class="hljs-number">22</span><br>解释： 和最大的美丽塔方案为 heights = <span class="hljs-selector-attr">[3,3,3,9,2,2]</span> ，这是一个美丽塔方案，因为：<br>- <span class="hljs-number">1</span> &lt;= heights<span class="hljs-selector-attr">[i]</span> &lt;= maxHeights<span class="hljs-selector-attr">[i]</span><br>- heights 是个山脉数组，峰值在 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">3</span> 处。<br><span class="hljs-number">22</span> 是所有美丽塔方案中的最大高度和。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：maxHeights = <span class="hljs-selector-attr">[3,2,5,5,2,3]</span><br>输出：<span class="hljs-number">18</span><br>解释：和最大的美丽塔方案为 heights = <span class="hljs-selector-attr">[2,2,5,5,2,2]</span> ，这是一个美丽塔方案，因为：<br>- <span class="hljs-number">1</span> &lt;= heights<span class="hljs-selector-attr">[i]</span> &lt;= maxHeights<span class="hljs-selector-attr">[i]</span><br>- heights 是个山脉数组，最大值在 <span class="hljs-selector-tag">i</span> = <span class="hljs-number">2</span> 处。<br>注意，在这个方案中，<span class="hljs-selector-tag">i</span> = <span class="hljs-number">3</span> 也是一个峰值。<br><span class="hljs-number">18</span> 是所有美丽塔方案中的最大高度和。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n == maxHeights &lt;= 103</code></li><li><code>1 &lt;= maxHeights[i] &lt;= 109</code></li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>第一眼认为选最高做塔顶就对了，但是答案是求和，肯定有奇怪的组合导致选最高为顶是错的，比如8888888888819这种。</p><p>赶时间睡觉，给的数据量做两次循环也不爆，直接遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>,maxx = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> prefix = maxHeights[i];<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                    temp+=<span class="hljs-built_in">min</span>(prefix,maxHeights[j]);<br>                    prefix = <span class="hljs-built_in">min</span>(prefix,maxHeights[j]);<br>                &#125;<br>            &#125;<br>            prefix = maxHeights[i];<br>            <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i+<span class="hljs-number">1</span>;k&lt;n;k++)&#123;<br>                    temp+=<span class="hljs-built_in">min</span>(prefix,maxHeights[k]);<br>                    prefix = <span class="hljs-built_in">min</span>(prefix,maxHeights[k]);<br>                &#125;<br>            &#125;<br>            temp += maxHeights[i];<br>            <span class="hljs-keyword">if</span>(maxx&lt;temp)&#123;<br>                res = temp;<br>                maxx = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>testing</title>
    <link href="/2024/07/17/testing/"/>
    <url>/2024/07/17/testing/</url>
    
    <content type="html"><![CDATA[<h1 id="testing-0717"><a href="#testing-0717" class="headerlink" title="testing 0717"></a>testing 0717</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem240124</title>
    <link href="/2024/01/24/dailyProblem20240124/"/>
    <url>/2024/01/24/dailyProblem20240124/</url>
    
    <content type="html"><![CDATA[<h4 id="2865-美丽塔-I"><a href="#2865-美丽塔-I" class="headerlink" title="2865. 美丽塔 I"></a><a href="https://leetcode.cn/problems/beautiful-towers-i/description/">2865. 美丽塔 I</a></h4><p>给你一个长度为 <code>n</code> 下标从 <code>0</code> 开始的整数数组 <code>maxHeights</code> 。</p><p>你的任务是在坐标轴上建 <code>n</code> 座塔。第 <code>i</code> 座塔的下标为 <code>i</code> ，高度为 <code>heights[i]</code> 。</p><p>如果以下条件满足，我们称这些塔是 <strong>美丽</strong> 的：</p><p><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code><br><code>heights</code> 是一个 山脉 数组。<br>如果存在下标 <code>i</code> 满足以下条件，那么我们称数组 <code>heights</code> 是一个 <strong>山脉</strong> 数组：</p><p>对于所有 <code>0 &lt; j &lt;= i</code> ，都有 <code>heights[j - 1] &lt;= heights[j]</code><br>对于所有 <code>i &lt;= k &lt; n - 1</code> ，都有 <code>heights[k + 1] &lt;= heights[k]</code><br>请你返回满足 <strong>美丽塔</strong> 要求的方案中，高度和的最大值 。</p><p>—————————————————————————————————————<br><strong>示例 1：</strong></p><p>输入：maxHeights &#x3D; [5,3,4,1,1]</p><p>输出：13</p><p>解释：和最大的美丽塔方案为 heights &#x3D; [5,3,3,1,1] ，这是一个美丽塔方案，因为：</p><ul><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]  </li><li>heights 是个山脉数组，峰值在 i &#x3D; 0 处。<br>13 是所有美丽塔方案中的最大高度和。</li></ul><p>—————————————————————————————————————<br><strong>示例 2：</strong></p><p>输入：maxHeights &#x3D; [6,5,3,9,2,7]</p><p>输出：22</p><p>解释： 和最大的美丽塔方案为 heights &#x3D; [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：</p><ul><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是个山脉数组，峰值在 i &#x3D; 3 处。<br>22 是所有美丽塔方案中的最大高度和。<br>—————————————————————————————————————<br><strong>示例 3：</strong></li></ul><p>输入：maxHeights &#x3D; [3,2,5,5,2,3]</p><p>输出：18</p><p>解释：和最大的美丽塔方案为 heights &#x3D; [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：</p><ul><li>1 &lt;&#x3D; heights[i] &lt;&#x3D; maxHeights[i]</li><li>heights 是个山脉数组，最大值在 i &#x3D; 2 处。<br>注意，在这个方案中，i &#x3D; 3 也是一个峰值。<br>18 是所有美丽塔方案中的最大高度和。</li></ul><p>—————————————————————————————————————<br>提示：</p><p>1 &lt;&#x3D; n &#x3D;&#x3D; maxHeights &lt;&#x3D; 10^3</p><p>1 &lt;&#x3D; maxHeights[i] &lt;&#x3D; 10^9</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>第一眼认为选最高做塔顶就对了，但是答案是求和，肯定有奇怪的组合导致选最高为顶是错的，比如8888888888819这种。</p><p>赶时间睡觉，给的数据量做两次循环也不爆，直接遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; maxHeights)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>,maxx = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = maxHeights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> temp = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> prefix = maxHeights[i];<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                    temp+=<span class="hljs-built_in">min</span>(prefix,maxHeights[j]);<br>                    prefix = <span class="hljs-built_in">min</span>(prefix,maxHeights[j]);<br>                &#125;<br>            &#125;<br>            prefix = maxHeights[i];<br>            <span class="hljs-keyword">if</span>(i&lt;n)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i+<span class="hljs-number">1</span>;k&lt;n;k++)&#123;<br>                    temp+=<span class="hljs-built_in">min</span>(prefix,maxHeights[k]);<br>                    prefix = <span class="hljs-built_in">min</span>(prefix,maxHeights[k]);<br>                &#125;<br>            &#125;<br>            temp += maxHeights[i];<br>            <span class="hljs-keyword">if</span>(maxx&lt;temp)&#123;<br>                res = temp;<br>                maxx = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sysu2023WaitFor0401LimitationGame</title>
    <link href="/2023/03/13/Sysu2023WaitFor0401LimitationGame/"/>
    <url>/2023/03/13/Sysu2023WaitFor0401LimitationGame/</url>
    
    <content type="html"><![CDATA[<h1 id="2023中大四月表等表赛战报"><a href="#2023中大四月表等表赛战报" class="headerlink" title="2023中大四月表等表赛战报"></a>2023中大四月表等表赛战报</h1><p>笑死，打完比赛8点konami跳票等表赛没等到表。</p><p>使用60多种龙链接</p><p>R1：VS 海晶少女（绅士哥），🎲✔，OO</p><p>G1吃了锁鸟只能做天球+烙印兽过，对面海龟吞了天球拉了鳞虫，跳7星冰水用烙印兽互动，然后通召海晶下级最后做到大堡礁没打死，然后轮到我一个波动没拦住被斩杀。</p><p>G2对面7星冰水登场吃G，对面G没通过用鳞虫跟冰水啼互动，然后就正常展开。</p><p>R2：VS 闪刀姬（KAS哥），🎲❌，OX</p><p>G1对面让先我中G，停牌之后对面没打死，之后轮到我曳光吃抓锚没抢，神兽吃抓锚被抢走，然后用深渊兽互动，利用扇区场差复活补怪做满赢。</p><p>G2对面先攻增援成金强贪壶，通召01盖宇宙风过，轮到我开割草堆了33，场地，曳光弹三张全在墓地，没堆到辉光龙，卡组深渊兽剩下最后一张萨隆魔龙（此时手上起手就有一张萨隆魔龙），路由龙拿了装填龙。对面没有一开始丢G，我先跳黑白龙用混沌领域回1抽到灰，之后展开的时候丢G我丢灰，顾忌后场所以先做了阿泽莉亚点了，然后做到左龙对面C1零衣C2陨石被停牌，中途亡龙放了血剩下4500。对面回合，先做了泽克处理token然后直击，我因为顾忌连刀+抓锚combo打死所以没跳手里的萨隆，被对面打了2次1500（风刀直击过）之后跳萨隆挡住地刀。对面资源量爆棚做满处理了萨隆前面水刀+后面跳楼机+4后。轮到我，开胜负的时候进死三，对面留了抓锚，通召弹丸同调士吃抓锚被抢走，用最后的资源量做了天球，盖上手里的烙印之兽，手里留着一个鳞虫等待机会交换。然后对面通召零衣跳露世，直接变阿泽莉亚处理了后场烙印兽。我自己这边的视角是自己的弹丸同调士不能被打，对面阿泽莉亚变火刀拿了交闪再拿再燃炸了天球我弹自己弹丸同调士，对面变风刀游戏结束。（一时间短路忘记风刀能直击，手里的鳞虫没办法挡，所以这里的办法就是搏对面没有连刀直接弹上阿泽莉亚连锁萨隆刨零衣。还得是多跟糖师傅学习如何玩好天球……）</p><p>R3：VS 电脑界（十月），🎲✔，OXO</p><p>G1先攻做了神兽前托红阵，对面九龙青龙无效前托，通召娘娘，老老点娘娘，我神兽忘记电脑堺先堆再特招被对面堆了青龙，然后对面青龙拿瑞瑞点青龙堆青龙拿了豸豸，我要防天霆，所以让对面瑞瑞结算，然后对面出了瑚之龙打算跟我红阵交换，然后我补跳鳞虫，红阵chain瑚龙效果把对面青龙和瑚龙都送墓了，对面draw1没办法出豸豸，投牌。</p><p>G2对面九龙瑞瑞开，丢圣枪，被看一次手牌，星尘充能抽到技能抽取，做了两个9叠王战。我先跟王战交互然后输技能抽取。</p><p>G3先攻做了白枪渊前托，然后对面熔岩魔神吃了前托渊，白枪康九龙，赢。</p><p>R4：VS 纯爱妖精（萝卜），🎲✔，XO</p><p>G1先攻混沌领域中锁鸟交墓指，做黑白龙单卡展开做完前托考虑了一下还是做了混沌魔龙，这里没打仔细混沌魔龙守表出，没翻到能用的只拿了个鳞虫过，手里有灰和兔。对面上来先开裂缝，然后开金谦壶交灰，拍小黑交前托，拍朋友拿玩波摇出第二只小黑变玩波，先打了混沌魔龙拿吃饭然后狂打前托最后还杀了混沌魔龙，最后的检索拿了场地，终场是7素材大黑+抽1。轮到我，先做阿泽莉亚除去裂缝，然后凑够4个怪，对面似乎忌惮冥神没有弹，说是不知道曳光开完效果有暗自肃不能出冥神，然后没能骗到对面交第一次效果，出刺刀被弹了，前托管不住5素材大黑，输。</p><p>G2先攻不知道是吃G还是锁鸟，还是卡手来着？不记得了好像是停牌了，轮到对面好像我也管住了然后对面只做了肥猫抽2，那个时候死三了。轮到我爆展赢了，平局齐齐出轮。</p><p>TOP4：VS 闪灵铁兽（遗老），🎲✔，XOO</p><p>G1吃G拜拜。</p><p>G2先攻亡龙增殖G萨隆魔封红阵，无奈盖2过。对面通召河狸展开中G，他没斩杀只做了招财猫+双龙。轮到我展开的时候抽了墓指，但是那个时候对面丢G有魔封开不了，然后通召曳光炸魔封展开，尽量快做出前托神兽进BP打死，对面没抽到深渊兽。</p><p>G3对面起手应该是：红指，纳贝尔，萝卜，剑指，灰流，盖下2后+纳贝尔到我。然后对面开红指，我手牌是：双始龙，星蛇，萨隆，旋转，G，灰；飞了双始龙灰了旋转停牌。对面通召萝卜我丢G对面没剑指，然后link龙炮C1龙炮C2纳贝尔我灰被指，然后就是拉2河狸，做徒花拉姬特，那个时候我抽到了圣枪，C1圣枪C2玛格巨龙。对面没得打死，终端是淘气+闪灵红+萝卜。手卡资源量爆棚正常展开拿下对局。</p><p>决赛：VS 四加六世坏（白铭），🎲❌，OXX</p><p>G1对面空过，到我没做大吃了锁鸟做了天球，对面继续卡手，然后我抽到了赫界对面灰，激活手里星蛇对面投。</p><p>G2手里圣枪锁鸟，对面直接飞独角兽，独角兽拿自在天，我觉得这里开了锁鸟牌效也低而且还要被看额外，本着不想过独角兽+狼的组合尝试赌对面做不做香格里拉。然后自在天拿狼拿男人，飞男人，对面这里考虑防陨石直接叫男人效果，我连锁圣枪被对面狗狗连锁除外墓地的自在天拿回停泊地。三体直接出阿莱斯哈特被一卡通关。</p><p>G3对面SP丢G，我连锁开旋转。在考虑出天球还是做红绿阵的时候我因为忌惮俱舍，选择做红绿。用赫界拿玛格，上级召唤萨隆，跳起赫界做红绿阵。轮到对面开胜负我剩下红阵。然后通召四世坏男人拿新星做狗拿场地拿四世坏男人，手里直接跳维萨斯和四世坏男人，这下我手里玛格巨龙+红阵也拦不住了，刨了墓地男人跳出来，红阵想炸的时候吃了幽鬼兔。对面还自然上手了一张新星，做了承影+鲜花，我找遍卡组都没找到能用的最后拿了混源龙。topdeck抽魔封，GG。</p>]]></content>
    
    
    
    <tags>
      
      <tag>YuGiOh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230311</title>
    <link href="/2023/03/11/dailyProblem230311/"/>
    <url>/2023/03/11/dailyProblem230311/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-17-05-字母与数字"><a href="#面试题-17-05-字母与数字" class="headerlink" title="面试题 17.05.  字母与数字"></a><a href="https://leetcode.cn/problems/find-longest-subarray-lcci/">面试题 17.05.  字母与数字</a></h4><p>难度中等</p><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p><p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p><p><strong>示例 1:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>array.length &lt;= 100000</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>能想到是前缀和+哈希转换，但是只想到了0，1计数，没想到-1，1计数。</p><p>这样计算前缀和的话只需要找到对应有相同count的对应下标作差找最大长度即可。抄一下答案</p><p>一个子数组包含的字母和数字的个数相同，等价于该子数组包含的字母和数字的个数之差为 0。因此可以将原数组做转换，每个字母对应 1，每个数字对应 −1，则转换后的数组中，每个子数组的元素和为该子数组对应的原始子数组的字母和数字的个数之差，如果转换后数组中的一个子数组的元素和为 0，则该子数组对应的原始子数组包含的字母和数字的个数相同。问题等价于在转换后的数组中寻找元素和为 0 的最长子数组。</p><p>为了在转换后的数组中寻找元素和为 0的子数组，可以计算转换后的数组的前缀和，如果两个下标对应的前缀和相等，则这两个下标之间的子数组的元素和为 0。</p><p>如果同一个前缀和出现多次，则该前缀和对应的最长子数组的长度为该前缀和的第一次出现的下标与最后一次出现的下标之间的子数组，因此为了在转换后的数组中寻找元素和为 0 的最长子数组，需要记录每个前缀和第一次出现的下标。</p><p>使用哈希表记录每个前缀和第一次出现的下标。由于空前缀的前缀和是 0 且对应下标 −1，因此首先将前缀和 0 与下标 −1 存入哈希表。</p><p>从左到右遍历数组，遍历过程中维护元素和为 0 的最长子数组的长度 maxLength 与开始下标  startIndex，初始时 maxLength&#x3D;0，startIndex&#x3D;−1。当遍历到下标 i 时，如果前缀和是 sum，则执行如下操作。</p><p>如果哈希表中已经存在前缀和 sum，则从哈希表中得到前缀和 sum 第一次出现的下标 firstIndex，以下标 i 结尾的元素和为 0 的最长子数组的长度是 i−firstIndex，该最长子数组的下标范围是 [firstIndex+1,i]。如果 i−firstIndex&gt;maxLength，则将 maxLength 更新为 i−firstIndex，将 startIndex 更新为 firstIndex+1；如果 i−firstIndex≤maxLength，则不更新 maxLength 与 startIndex。</p><p>如果哈希表中不存在前缀和 sum，则下标 i 为前缀和 sum 第一次出现的下标，将前缀和 sum 与下标 i 存入哈希表。</p><p>遍历结束之后，根据 maxLength 与 startIndex 的值返回结果。</p><p>如果 maxLength&gt;0，则原数组中存在字母和数字的个数相同的子数组，根据 maxLength 与 startIndex 得到原数组中包含的字母和数字的个数相同的最长子数组，返回该最长子数组。</p><p>如果 maxLength&#x3D;0，则原数组中不存在字母和数字的个数相同的子数组，返回空数组。</p><p>从左到右遍历数组的过程中，只有当遇到的子数组长度大于已有的最大长度时才会更新最大子数组的长度与开始下标，因此每次更新最大子数组的长度与开始下标之后，不存在长度等于已有的最大长度且开始下标更小的子数组。如果有多个最长子数组，则 startIndex 为这些最长子数组中的最小的左端点下标值。</p><p>实现方面，不需要创建并计算转换后的数组，只需要将原数组中的字母和数字分别对应 1 和 −1，在遍历过程中计算前缀和即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230302</title>
    <link href="/2023/03/02/dailyProblem230302/"/>
    <url>/2023/03/02/dailyProblem230302/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode.cn/problems/bianry-number-to-string-lcci/">面试题 05.02. 二进制数转字符串</a></h4><p>难度中等</p><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p><p><strong>示例1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.625</span><br>输出：<span class="hljs-string">&quot;0.101&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.1</span><br>输出：<span class="hljs-string">&quot;ERROR&quot;</span><br>提示：<span class="hljs-number">0.1</span>无法被二进制准确表示<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>32位包括输出中的 <code>&quot;0.&quot;</code> 这两位。</li><li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不难，按照题目的意思直接去按位操作就好。</p><p>一开始没想到的地方是如何判断不能被二进制准确表示，后来再看一次题目想到：只要32位之内都没把它转换成功就可以输出ERROR了。</p><p>要做的操作就是：</p><p>1，每次把num乘以2，然后取整数，再用num减去这个整数部分 &#x2F;&#x2F;是十进制小数转二进制的操作</p><p>2，如果num减至0或者字符串长度超32，就停止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">printBin</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>        string ans=<span class="hljs-string">&quot;0.&quot;</span>;<br>        <span class="hljs-keyword">while</span>(ans.<span class="hljs-built_in">length</span>()&lt;=<span class="hljs-number">32</span>&amp;&amp;num!=<span class="hljs-number">0</span>)&#123;<br>            num *=<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> bit = num;<span class="hljs-comment">//只取整数部分，按照整数部分的0/1情况添0/1</span><br>            num -= bit;<br>            ans+=(<span class="hljs-string">&#x27;0&#x27;</span>+bit);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ERROR&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230227</title>
    <link href="/2023/02/27/dailyProblem230227/"/>
    <url>/2023/02/27/dailyProblem230227/</url>
    
    <content type="html"><![CDATA[<h4 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a><a href="https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/">1144. 递减元素使数组呈锯齿状</a></h4><p>难度中等</p><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3]<br>输出：2<br>解释：我们可以把<span class="hljs-number"> 2 </span>递减到 0，或把<span class="hljs-number"> 3 </span>递减到 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[9,6,1,6,2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可能还是对动态规划不熟？一开始在想要怎么安排规划，后来没想到状态方程只好作罢。</p><p>再次读题目，要求是奇数位都比偶数位大或者偶数位都比奇数位大，而可以进行的操作只能是减操作。</p><p>令操作数最少肯定是只改奇数位或者只改偶数位，既然如此，那就分奇偶两次分别遍历计数，然后选出最小的那个数。</p><p>途中修改了代码逻辑很多次，还是不够专注或者不够熟练，尝试每天都花一个小时的专注时间优先解决问题再做其他事情。</p><p>（从数据上来说似乎不是好解法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movesToMakeZigzag</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>,n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//修改奇数位</span><br>            <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//防越界</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>                        ans1+=(nums[i]-nums[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>]||nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>                    ans1+=(nums[i]-<span class="hljs-built_in">min</span>(nums[i<span class="hljs-number">-1</span>],nums[i+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;=nums[<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//第一位的特殊判断</span><br>            ans2+=(nums[<span class="hljs-number">0</span>]-nums[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//修改偶数位</span><br>            <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//防越界</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>                        ans2+=(nums[i]-nums[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>]||nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>                    ans2+=(nums[i]-<span class="hljs-built_in">min</span>(nums[i<span class="hljs-number">-1</span>],nums[i+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans2;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ans1,ans2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230226</title>
    <link href="/2023/02/26/dailyProblem230226/"/>
    <url>/2023/02/26/dailyProblem230226/</url>
    
    <content type="html"><![CDATA[<h4 id="1255-得分最高的单词集合"><a href="#1255-得分最高的单词集合" class="headerlink" title="1255. 得分最高的单词集合"></a><a href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/">1255. 得分最高的单词集合</a></h4><p>难度困难</p><p>你将会得到一份单词表 <code>words</code>，一个字母表 <code>letters</code> （可能会有重复字母），以及每个字母对应的得分情况表 <code>score</code>。</p><p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 <code>letters</code> 里的字母拼写出的 <strong>任意</strong> 属于 <code>words</code> 单词子集中，分数最高的单词集合的得分。</p><p>单词拼写游戏的规则概述如下：</p><ul><li>玩家需要用字母表 <code>letters</code> 里的字母来拼写单词表 <code>words</code> 中的单词。</li><li>可以只使用字母表 <code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li><li>单词表 <code>words</code> 中每个单词只能计分（使用）一次。</li><li>根据字母得分情况表<code>score</code>，字母 <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, … , <code>&#39;z&#39;</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>, …, <code>score[25]</code>。</li><li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>], letters = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]<br>输出：23<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">c</span>=9, <span class="hljs-attribute">d</span>=5, <span class="hljs-attribute">g</span>=3, <span class="hljs-attribute">o</span>=2<br>使用给定的字母表 letters，我们可以拼写单词 <span class="hljs-string">&quot;dad&quot;</span> (5+1+5)和 <span class="hljs-string">&quot;good&quot;</span> (3+2+2+5)，得分为 23 。<br>而单词 <span class="hljs-string">&quot;dad&quot;</span> 和 <span class="hljs-string">&quot;dog&quot;</span> 只能得到 21 分。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;xxxz&quot;</span>,<span class="hljs-string">&quot;ax&quot;</span>,<span class="hljs-string">&quot;bx&quot;</span>,<span class="hljs-string">&quot;cx&quot;</span>], letters = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]<br>输出：27<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=4, <span class="hljs-attribute">b</span>=4, <span class="hljs-attribute">c</span>=4, <span class="hljs-attribute">x</span>=5, <span class="hljs-attribute">z</span>=10<br>使用给定的字母表 letters，我们可以组成单词 <span class="hljs-string">&quot;ax&quot;</span> (4+5)， <span class="hljs-string">&quot;bx&quot;</span> (4+5) 和 <span class="hljs-string">&quot;cx&quot;</span> (4+5) ，总得分为 27 。<br>单词 <span class="hljs-string">&quot;xxxz&quot;</span> 的得分仅为 25 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;leetcode&quot;</span>], letters = [<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>], score = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<br>字母 <span class="hljs-string">&quot;e&quot;</span> 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 14</code></li><li><code>1 &lt;= words[i].length &lt;= 15</code></li><li><code>1 &lt;= letters.length &lt;= 100</code></li><li><code>letters[i].length == 1</code></li><li><code>score.length == 26</code></li><li><code>0 &lt;= score[i] &lt;= 10</code></li><li><code>words[i]</code> 和 <code>letters[i]</code> 只包含小写的英文字母。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>自己的想法是给每个单词赋分，然后遍历所有可能找出最高得分，但我觉得这个太笨，而且遍历的时候还要对letters数组数数，不是合理的解法，去看答案了。</p><p>解题思路：<br>1，提供的字母集合，每个字母只能用一次<br>2，提供的单词集合，每个单词也只能用一次<br>3，单词集合的大小，1 &lt;&#x3D; words[i].length &lt;&#x3D; 15<br>4，枚举 words 子集总共 2^15 种情况<br>5，对每一种情况统计使用了哪些字母<br>        如果字母超出范围了，就不符合要求，否则按照字母表计算得分<br>        记录最大得分<br>位压缩：<br>1，对于单词集合中每一个词，都可以选择，用&#x2F;不用</p><p>​所以就可以用位 0&#x2F;1 来表示</p><p>2，单词集合中每个单词都表示出来，总和就是 2的N次方种</p><p>​可以用 1 &lt;&lt; N 来表示</p><p>3，当遍历到其中一个组合时，其数字的二进制位表示的就是各个单词的使用状态</p><p>​比如 5，二进制 101，代表第 0 个和第 2 个单词使用，第 1 个单词不使用</p><p>4，检查时，对于第 i 个单词，使用 1 &lt;&lt; i，得到二进制除了第 i 位（顺序是从右至左）其余全 0 的数字</p><p>​比如第 2 个单词，1 &lt;&lt; 2 之后得到 4（二进制 100）</p><p>5，再与状态位进行&amp;操作，得到是否使用<br>    4（二进制100）与刚才的 5（二进制101）&amp;操作，得到 true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 将第（bit）种组合情况，所使用的单词中的字母数量统计出来</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">group</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> bit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(bit &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : words[i])<br>        &#123;<br>            g[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> g;<br>&#125;<br><br><span class="hljs-comment">// 根据规则计算得分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; group, vector&lt;<span class="hljs-type">int</span>&gt;&amp; lettercnt, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (lettercnt[j] &lt; group[j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        s += group[j] * score[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScoreWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 统计给出的字母的数量</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lettercnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : letters)<br>    &#123;<br>        lettercnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; words.<span class="hljs-built_in">size</span>()); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">group</span>(words, i);<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">calcScore</span>(g, lettercnt, score));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FlowersForAlgernon</title>
    <link href="/2023/02/24/FlowersForAlgernon/"/>
    <url>/2023/02/24/FlowersForAlgernon/</url>
    
    <content type="html"><![CDATA[<p>献给阿尔吉侬的花束》</p><p>本周由于心情的和兴趣缺乏的缘故，无意中了解到了这本书，决定阅读。随手写写</p><p>跟一般书的标题不一样，虽然用阿尔吉侬命名，但阿尔吉侬在书中是一只白老鼠。</p><p>本作的主角是查理·高登，以为天生低智的男人。</p><p>他有着善良且努力学习的特质，因为他的与众不同才会被选上当人智提升计划的实验对象。</p><p>他接受实验之后逐渐变得比普通的聪明人更加聪明，但快速的智力成长和与之不匹配的心智让他对原来的世界产生了不同的看法。他之前渴望被社会接纳渴望变聪明，但社会反馈给他的更多是欺辱和霸凌，而自己的母亲也无法接受自己的儿子是弱智的。</p><p>查理看到了这一切之后，觉得这一切都是不可接受的，反而对弱势群体产生了更强的怜悯。</p><p>而关于书中描写查理的情感和爱情，我个人认为这部分是勾勒出，他作为一个正常人，完整的生活必不可缺的元素，他渴望被爱，同时也想学会去爱。</p><p>书中也表达了一个观点——无论你的智慧多么高超深邃，但如果缺少爱，那将毫无意义。</p><p>这个观点可以从查理变聪明之后会变自大，目中无人看出，也可以是实验团队将查理看成是实验物品这个行为去提炼。</p><p>查理在觉醒了智慧之后，明确了他是一个人，是一个个体，在拥有智慧的时候是，在进行手术前也是，所以他对整个实验会产生控诉，认为研究人员没有把他当作人，只是用来攫取名利的科学证据。但是在逐渐对世界产生认识的过程中他也开始理解自己存在的意义，在知道自己在不久的将来会退化之后马上着手写分析，希望能造福智障群体。</p><p>在查理实验的全过程中，阿尔吉侬的存在是很重要的，他在显现智力的一开始非常抗拒与阿尔吉侬比赛，直至后来战胜这只小白鼠，我个人认为是自尊的一种觉醒。他也在体验世界的过程中发现这是他真正的好友，因为这只小白鼠跟他一样，都是实验对象，都经历了智力的觉醒和衰退。他在还清醒的时候一直会给阿尔吉侬的坟墓上放花，也在小说的最后，希望读到他写的报告的人也可以给阿尔吉侬献花。我个人认为这体现了对需要帮助群体的爱，以及查理在阿尔吉侬身上看到了自己，他不希望自己被大家遗忘，所以题目写《献给阿尔吉侬的花束》其实是双关的，同样也是，献给查理高登的花。</p><blockquote><p>任何有常识的人都会记得迷乱的眼睛可以区分为两类，而且是由两种原因造成的；不是自光明进入黑暗，就是自黑暗进入光明，这些心灵之眼与肉体之眼完全真实；记得这些事情的人，在见到眼神困惑而又微弱的人时，并不会因此而取笑这个人。首先，他会问这个人的灵魂是否自更光明的生活进入黑暗的生活，因为还不习惯黑暗而无法看见，或是刚自黑暗的生活进入光明的生活，由于太亮而目眩。因此，他会以所处的条件与生存环境判断别人是否快乐，然后，以此同情别人。或是，如果他对于一个从黑暗进入光明的灵魂产生取笑之心，那他就有更多的理由去取笑自光明返回黑暗洞穴的人。</p></blockquote><p>书中开头引用的这段柏拉图的话，其实是查理的人生缩影。</p><p>他从无到有再到无，在无知的时候他没有执念，但是在从有到无的过程中他非常痛苦，他不想失去智慧和阅读写作的能力。换做我们自己也是一样的，在失去重视之物的时候也会想拼命挽留。实验的持续时间就像是命运，生命中有太多的东西不能由我们自己决定去留。凡人终究是会有执念，查理在几个月的实验经理，像是度过了相对完整的一生，希望我能在他的生活沉淀出更利好我成长的养分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230224</title>
    <link href="/2023/02/24/dailyProblem230224/"/>
    <url>/2023/02/24/dailyProblem230224/</url>
    
    <content type="html"><![CDATA[<h4 id="2357-使数组中所有元素都等于零"><a href="#2357-使数组中所有元素都等于零" class="headerlink" title="2357. 使数组中所有元素都等于零"></a><a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">2357. 使数组中所有元素都等于零</a></h4><p>难度简单</p><p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p><ul><li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li><li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li></ul><p>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,5,0,3,5]</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>第一步操作：选出 x = <span class="hljs-number">1</span> ，之后 nums = <span class="hljs-string">[0,4,0,2,4]</span> 。<br>第二步操作：选出 x = <span class="hljs-number">2</span> ，之后 nums = <span class="hljs-string">[0,2,0,0,2]</span> 。<br>第三步操作：选出 x = <span class="hljs-number">2</span> ，之后 nums = <span class="hljs-string">[0,0,0,0,0]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br>解释：nums 中的每个元素都已经是 <span class="hljs-number">0</span> ，所以不需要执行任何操作。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单题，一种方法是直接按照题意进行一次遍历，因为减操作是累积的，所以用一个minus变量记录当前已经减去多少，就不需要逐个位置去修改了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minus = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            nums[i] += minus;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                minus -= nums[i];<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种方法，从数学的角度出发，这个答案其实是求原数组有多少个不同的正整数。</p><p>证明：</p><p>假如不是的话，说明在某一次操作能将开始就不同的两个数同时抹零，但我们又知道每次减操作是所有数一同进行的，故两个开始就不同的数他们之间的差值在整个过程中都是固定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                hash.<span class="hljs-built_in">insert</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230223</title>
    <link href="/2023/02/23/dailyProblem230223/"/>
    <url>/2023/02/23/dailyProblem230223/</url>
    
    <content type="html"><![CDATA[<h4 id="1238-循环码排列"><a href="#1238-循环码排列" class="headerlink" title="1238. 循环码排列"></a><a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/">1238. 循环码排列</a></h4><p>难度中等</p><p>给你两个整数 <code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p><ul><li><code>p[0] = start</code></li><li><code>p[i]</code> 和 <code>p[i+1]</code> 的二进制表示形式只有一位不同</li><li><code>p[0]</code> 和 <code>p[2^n -1]</code> 的二进制表示形式也只有一位不同</li></ul><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">2</span>, start = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3,2,0,1</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">11,10,00,01</span>)<br>     所有的相邻元素都有一位是不同的，另一个有效的排列是 [<span class="hljs-number">3,1,0,2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输出：n = <span class="hljs-number">3</span>, start = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2,6,7,5</span>,<span class="hljs-number">4,0,1,3</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">010,110,111</span>,<span class="hljs-number">101,100,000</span>,<span class="hljs-number">001,011</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li><li><code>0 &lt;= start &lt; 2^n</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本质就是格雷编码。二进制编码转换格雷编码的公式为：i 异或 （i&gt;&gt;1) 。i为当前数组下标。</p><p>不过本题跟格雷编码的区别在于，格雷的初始要求是0，而题目是给定的start。</p><p>所以，要在之前求出格雷编码的情况下，与start进行一次异或。（每一个格雷码跟start异或都不会改变只有一位相差的性质，而一开始的格雷码是0，右移一位也是0，那么与start异或就是start本身了。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ret[i] = (i &gt;&gt; <span class="hljs-number">1</span>) ^ i ^ start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTCG-YUGIOH-REPORT</title>
    <link href="/2023/02/20/CTCG-YUGIOH-REPORT/"/>
    <url>/2023/02/20/CTCG-YUGIOH-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CTCG东莞站-深渊龙link-4-0-3-战报"><a href="#CTCG东莞站-深渊龙link-4-0-3-战报" class="headerlink" title="CTCG东莞站 深渊龙link 4-0-3 战报"></a>CTCG东莞站 深渊龙link 4-0-3 战报</h1><p>R1 VS珠泪哀歌族，🎲✔，OXX</p><p>G1能动，顺利做满对面投降。</p><p>G2起手只有鳞虫和萨隆魔龙两张手坑，对面一上来就是天魔世界跳芬里尔狼+塞壬丢古尖兵，古尖兵堆古卫兵。萨隆魔龙点梅洛对面飞红人鱼躲开继续展开，鳞虫点小美人鱼成功干扰但是被狼除外，终场对面有时潜+狼+哀唱。到我展开吃G对面墓地还有影依，投了。</p><p>G3先攻因为有龙谷先用黑白龙做了天球，扇区拉曳光中G，想着手里还有玛格，前场有天球就直接过了。然后对面拍天魔世界，天球弹完拉鸟龙兽。对面直接手拍芬里尔狼检索红人鱼，魔神王拿融合，通召宿神像跟手里魔神王和古尖兵融合，排连锁资源量直接打穿，无奈输。</p><p>R2 VS闪灵深渊兽，🎲✔，OO</p><p>G1先攻顺利做完，对面看完第六抽投降。</p><p>G2对面卡手盖烙印之兽过了，然后我一手展开牌，对面两个深渊兽交互质量不高，顺利拿下。</p><p>R3 VS神碑，🎲❌，OO</p><p>G1对面开穗先找泉，摇人出穆宁，微睡点穆宁，泉抽3被我用灰打断，盖2过。在我的准备阶段开了群雄割据+千查万别。我手牌有辉光龙混沌领域和赫界龙，决定直接找混源龙炸贴纸，之后成功展开做完白枪前托管住然后胜利。</p><p>G2对面做完穆宁+泉没盖卡，我手牌比较好，交互完之后都做了前托白枪，但是对面下回合有天岩户，还是顺利转起，还有set卡，然后我只能单前托beat，其中有一个回合对面用速攻喊完人因为紧张没用神碑之泉效果抽3，然后两回合没抽到神碑魔法被前托打死。</p><p>R4 VS俱舍怒威，🎲❌，XOX</p><p>G1起手2速攻旋转2赫界龙1装填龙，对面做满，有天魔世界+香格里拉+阿莱斯哈特+芬里尔狼，无得过直接投</p><p>G2对面丢G我丢灰，然后始枪龙吃了灰，手里拿着萨隆魔龙，盖魔毒+烙印之兽停牌，然后先开金谦out6吃灰，接着通召莱斯哈特先进BP打死始枪龙，然后先叫效果再开停泊地，我跳萨隆魔龙出场然后开魔毒炸了停泊地和手里的结界波。T3topdeck抽辉白龙，出场对面投降。</p><p>G3虽然起手2张叠光延迟，但是对面满中满：有天魔世界+香格里拉+阿莱斯哈特+芬里尔狼+电脑兽+停泊地+明牌六根清净，out了我前托还盖了2未知后场。抽阶要处理香格里拉只能双交叠光延迟弹阿莱斯哈特和香格里拉。赫界龙吃墓指，也都还行，用黑白龙和旋转运转用扇区拉场差突破，但没想到扇区竟然吃了宇宙旋风。。直接无晒资源投牌。。。</p><p>R5 VS珠泪哀歌，🎲❌，XOX</p><p>G1对面堆墓质量很高，我只丢了锁鸟，但墓地神官神像齐，还出了小米，深渊兽被露莎卡管住，突破失败投牌。</p><p>G2混沌轴+赫界龙展开，对面在我出了神兽之后再叫小美人鱼，被管住，然后跳红人鱼质量不高，我做完对面投牌。</p><p>G3无手坑对面做完：龙神王+露莎卡+深渊潜伏+哀唱+一手，混沌领域被龙神王管住，手里有深渊兽和复烙印，墓地有尖兵堆下去的鳞虫，因为被封墓效所以不能用路由龙找弹丸边，尝试用6+4出混沌双翼解场。于是玛格巨龙想出场被露莎卡管住，复烙印想着多拉鳞虫处理掉龙神王，结果就是因为忘记了封墓效导致没用好复烙印的复活（应该复活玛格巨龙逼哀唱，要么多一个续航要么可以成功解决哀唱），只有混沌双翼一个除去，点哀唱被哀唱无效，BP打死深渊潜伏M2出阿泽莉亚拆龙神王，然后过，结果对面神抽梅洛人鱼，配合哀唱融出卡雷多哈特直接摁死我，两个topdeck质量都低，无法返场，GAMELOST。</p><p>R6 轮空 O</p><p>R7 VS珠泪哀歌，🎲❌，OXO</p><p>对面估计没心机玩了。</p><p>G1用深渊兽交互一下对面只做露莎卡，后来被我做出前托就投了</p><p>G2对面塞壬丢古尖开堆，我丢了G他只做了露莎卡，但他手里有红人鱼和反击，我读错牌以为是哀唱没交宇宙旋风，被对面管死。</p><p>G3我做到一半对面就投降了。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>骰子运真的不行，而且后手基本抽不到有效交互牌，感觉就是差一点神助之力。</p><p>但是以往去打赛都没犯错，跟珠泪打细节还是太多，结果就是漏掉了关键的一着没复活玛格巨龙，否则说不定还不会止步第一天。不过就，我自认也认真去打这场比赛了，下次再努力吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>yugioh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230220</title>
    <link href="/2023/02/20/dailyProblem230220/"/>
    <url>/2023/02/20/dailyProblem230220/</url>
    
    <content type="html"><![CDATA[<h4 id="2347-最好的扑克手牌"><a href="#2347-最好的扑克手牌" class="headerlink" title="2347. 最好的扑克手牌"></a><a href="https://leetcode.cn/problems/best-poker-hand/">2347. 最好的扑克手牌</a></h4><p>难度简单</p><p>给你一个整数数组 <code>ranks</code> 和一个字符数组 <code>suit</code> 。你有 <code>5</code> 张扑克牌，第 <code>i</code> 张牌大小为 <code>ranks[i]</code> ，花色为 <code>suits[i]</code> 。</p><p>下述是从好到坏你可能持有的 <strong>手牌类型</strong> ：</p><ol><li><code>&quot;Flush&quot;</code>：同花，五张相同花色的扑克牌。</li><li><code>&quot;Three of a Kind&quot;</code>：三条，有 3 张大小相同的扑克牌。</li><li><code>&quot;Pair&quot;</code>：对子，两张大小一样的扑克牌。</li><li><code>&quot;High Card&quot;</code>：高牌，五张大小互不相同的扑克牌。</li></ol><p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好手牌类型</strong> 。</p><p><strong>注意：</strong>返回的字符串 <strong>大小写</strong> 需与题目描述相同。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">13</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], suits = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>]<br>输出：<span class="hljs-string">&quot;Flush&quot;</span><br>解释：<span class="hljs-number">5</span> 张扑克牌的花色相同，所以返回 <span class="hljs-string">&quot;Flush&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>], suits = [<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>输出：<span class="hljs-string">&quot;Three of a Kind&quot;</span><br>解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 。<br>注意我们也可以得到 <span class="hljs-string">&quot;Pair&quot;</span> ，但是 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 是更好的手牌类型。<br>有其他的 <span class="hljs-number">3</span> 张牌也可以组成 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 手牌类型。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>], suits = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br>输出：<span class="hljs-string">&quot;Pair&quot;</span><br>解释：第一和第二张牌大小相同，所以得到 <span class="hljs-string">&quot;Pair&quot;</span> 。<br>我们无法得到 <span class="hljs-string">&quot;Flush&quot;</span> 或者 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>ranks.length == suits.length == 5</code></li><li><code>1 &lt;= ranks[i] &lt;= 13</code></li><li><code>&#39;a&#39; &lt;= suits[i] &lt;= &#39;d&#39;</code></li><li>任意两张扑克牌不会同时有相同的大小和花色。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>按照优先级顺序判断就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">bestHand</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ranks, vector&lt;<span class="hljs-type">char</span>&gt;&amp; suits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> kinds[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> nums[<span class="hljs-number">14</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            nums[ranks[i]]++;<br>            kinds[suits[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(kinds[i]==<span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Flush&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">14</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=<span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Three of a Kind&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">14</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;High Card&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230217</title>
    <link href="/2023/02/17/dailyProblem230217/"/>
    <url>/2023/02/17/dailyProblem230217/</url>
    
    <content type="html"><![CDATA[<h4 id="1139-最大的以-1-为边界的正方形"><a href="#1139-最大的以-1-为边界的正方形" class="headerlink" title="1139. 最大的以 1 为边界的正方形"></a><a href="https://leetcode.cn/problems/largest-1-bordered-square/">1139. 最大的以 1 为边界的正方形</a></h4><p>难度中等</p><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code>，请你找出边界全部由 <code>1</code> 组成的最大 <strong>正方形</strong> 子网格，并返回该子网格中的元素数量。如果不存在，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 100</code></li><li><code>1 &lt;= grid[0].length &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用动态规划解决，</p><p>在位置i,j，我们可以标记up[i][j]和left[i][j]。代表在ij位置左起最大连续1和上方最大连续1的数量。</p><p>而构成正方形的边长肯定是这两个连续1的数量的较小值，以这个值作为边长l，去寻找另外两个对角的长度，枚举出可以构成正方形的情况，然后更新最大边界的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largest1BorderedSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(),n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">left</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>)), <span class="hljs-built_in">up</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> maxborder = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<span class="hljs-comment">//因为下标不是从0开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)&#123;<br>                    left[i][j] = left[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>;<br>                    up[i][j] = up[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> border = <span class="hljs-built_in">min</span>(left[i][j],up[i][j]);<br>                    <span class="hljs-keyword">while</span>(left[i-border+<span class="hljs-number">1</span>][j]&lt;border||up[i][j-border+<span class="hljs-number">1</span>]&lt;border)&#123;<br>                        border--;<br>                    &#125;<br>                    maxborder = <span class="hljs-built_in">max</span>(maxborder,border);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxborder*maxborder;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230210</title>
    <link href="/2023/02/11/dailyProblem230210/"/>
    <url>/2023/02/11/dailyProblem230210/</url>
    
    <content type="html"><![CDATA[<h4 id="1223-掷骰子模拟"><a href="#1223-掷骰子模拟" class="headerlink" title="1223. 掷骰子模拟"></a><a href="https://leetcode.cn/problems/dice-roll-simulation/">1223. 掷骰子模拟</a></h4><p>难度困难</p><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字 <code>i</code> 的次数不能超过 <code>rollMax[i]</code>（<code>i</code> 从 1 开始编号）。</p><p>现在，给你一个整数数组 <code>rollMax</code> 和一个整数 <code>n</code>，请你来计算掷 <code>n</code> 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模 <code>10^9 + 7</code></strong> 之后的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">2</span>, rollMax = <span class="hljs-string">[1,1,1,1,1,1]</span><br>输出：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">3</span>, rollMax = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">181</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>rollMax.length == 6</code></li><li><code>1 &lt;= rollMax[i] &lt;= 15</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>动态规划问题。</p><p>使用dp[i][j]来记录i位置时是j的序列数量，即长度为i的序列总数为dp[i][1~6]。</p><p>要怎么用上约束条件呢？</p><p>假设目前i位置上为X，分两种情况。</p><p>1，假如添加X后还没超过限制，就不做任何处理。</p><p>2，添加X后超过了限制，可知这必定是第一次超过限制，</p><p>如果都把可能性直接相加，那么可知是要减掉一些的。</p><p>假设数字5在第10位已经连续出现了4次，而5限制只能连续出现3次。那么就代表第6位是1，2，3，4，6。把这些数量减去就好了</p><p>于是状态方程为：<br>$$<br>\sum_{k&#x3D;1}^6dp[i-1][k] - \sum_{k&#x3D;1,k!&#x3D;j}^6dp[i-rollMax[j-1]-1][k]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; rollMax)</span> </span>&#123;<br>        vector&lt;vector&lt;LL&gt; &gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;LL&gt;(<span class="hljs-number">7</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>            dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>                <span class="hljs-comment">// 加入第 i-1 次得所有可能序列总数</span><br>                LL ans = <span class="hljs-built_in">accumulate</span>(dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(), dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<br>                <span class="hljs-type">int</span> idx = i - <span class="hljs-number">1</span> - rollMax[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span> (idx &gt;= <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 减去 i - 1 - rollMax[j-1]次掷出1，2，3，4，5 的所有序列总数</span><br>                    ans = <span class="hljs-built_in">accumulate</span>(dp[idx].<span class="hljs-built_in">begin</span>(), dp[idx].<span class="hljs-built_in">end</span>(), ans, [&amp;](LL init, LL e) &#123;<br>                        <span class="hljs-keyword">return</span> init + MOD - e;<br>                    &#125;);<br>                    ans += dp[idx][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 特殊情况处理</span><br>                    ans -= <span class="hljs-number">1</span>;<br>                &#125;<br>                dp[i][j] = ans % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp[n].<span class="hljs-built_in">begin</span>(), dp[n].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) % MOD;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230211</title>
    <link href="/2023/02/11/dailyProblem230211/"/>
    <url>/2023/02/11/dailyProblem230211/</url>
    
    <content type="html"><![CDATA[<h4 id="2335-装满杯子需要的最短总时长"><a href="#2335-装满杯子需要的最短总时长" class="headerlink" title="2335. 装满杯子需要的最短总时长"></a><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/">2335. 装满杯子需要的最短总时长</a></h4><p>难度简单47</p><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [1,4,2]<br>输出：4<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水。<br>可以证明最少需要<span class="hljs-number"> 4 </span>秒才能装满所有杯子。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [5,4,4]<br>输出：7<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 5 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 6 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 7 </span>秒：装满一杯热水。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> [5,0,0]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：每秒装满一杯冷水。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>amount.length == 3</code></li><li><code>0 &lt;= amount[i] &lt;= 100</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单的数学题，题中明确了只有三个杯子而一次可以倒两个杯子。</p><p>最少的次数肯定就是需求数量比较少的两个杯子之和与最多的那个杯子做差有关系。</p><p>因为一次能倒满两个杯子，就要争取每一次都有两个杯子可以倒。</p><p>用需求数量最多的杯子去调整剩下两个杯子的数量（使得用完最多的杯子的时候那两个杯子数量尽可能相等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fillCups</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; amount)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(amount.<span class="hljs-built_in">begin</span>(),amount.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>((amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>])&lt;=amount[<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> temp = amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>]-amount[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230208</title>
    <link href="/2023/02/08/dailyProblem230208/"/>
    <url>/2023/02/08/dailyProblem230208/</url>
    
    <content type="html"><![CDATA[<h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><p>难度中等</p><p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p><p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p><ul><li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/d/e&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>解释：<span class="hljs-string">&quot;/a/b&quot;</span> 是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹，而 <span class="hljs-string">&quot;/c/d/e&quot;</span> 是 <span class="hljs-string">&quot;/c/d&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>]<br>解释：文件夹 <span class="hljs-string">&quot;/a/b/c&quot;</span> 和 <span class="hljs-string">&quot;/a/b/d&quot;</span> 都会被删除，因为它们都是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: folder = [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出: [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= folder.length &lt;= 4 * 104</code></li><li><code>2 &lt;= folder[i].length &lt;= 100</code></li><li><code>folder[i]</code> 只包含小写字母和 <code>&#39;/&#39;</code></li><li><code>folder[i]</code> 总是以字符 <code>&#39;/&#39;</code> 起始</li><li>每个文件夹名都是 <strong>唯一</strong> 的</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>读完题目后，判断是否是子文件夹其实就是找子串。</p><p>因为目录的逻辑，解答的要求应该是，文件夹与子文件夹的路径只有开头部分重复。</p><p>并且按照文件夹的定义，字母间需要用 ‘&#x2F;’ 隔开。</p><p>所以解题的步骤就是，先将这些字符串排序（短的在前），然后给它添加一个 ‘&#x2F;’ 。</p><p>逐个验证是否是子串，如果是就标记为1，减少遍历次数以及标记答案。</p><p>因为即使是子串也有可能不是因为开头相同而匹配，所以还要额外验证一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = folder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(),folder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i] == <span class="hljs-number">0</span>)&#123;<br>                string temp = folder[i]+<span class="hljs-string">&#x27;/&#x27;</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(folder[j].<span class="hljs-built_in">find</span>(temp)!=folder[j].npos&amp;&amp;temp[<span class="hljs-number">1</span>]==folder[j][<span class="hljs-number">1</span>])&#123;<br>                        hash[j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i]==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(folder[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230209</title>
    <link href="/2023/02/08/dailyProblem230209/"/>
    <url>/2023/02/08/dailyProblem230209/</url>
    
    <content type="html"><![CDATA[<h4 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797. 设计一个验证系统"></a><a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></h4><p>难度中等</p><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code> 类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li></ul><p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：<br>[<span class="hljs-string">&quot;AuthenticationManager&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, null, null, null, <span class="hljs-number">0</span>]<br><br>解释：<br>AuthenticationManager authenticationManager = new AuthenticationManager(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 构造 AuthenticationManager ，设置 timeToLive = <span class="hljs-number">5</span> 秒。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">1</span> 时，没有验证码的 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> ，没有验证码被更新。<br>authenticationManager.generate(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">2</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的新验证码。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">6</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">6</span> 时，只有 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码未过期，所以返回 <span class="hljs-number">1</span> 。<br>authenticationManager.generate(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">7</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的新验证码。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，且 <span class="hljs-number">8</span> &gt;= <span class="hljs-number">7</span> ，所以时刻 <span class="hljs-number">8</span> 的renew 操作被忽略，没有验证码被更新。<br>authenticationManager.renew(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">10</span> 没有过期，所以 renew 操作会执行，该 token 将在时刻 <span class="hljs-number">15</span> 过期。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">15</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">15</span> 过期，tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，所有验证码均已过期，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li><li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>其实只是哈希表的分函数调用。所以均可访问的变量要在private定义。</p><p>用map给所有字符串和有效时间做映射，generate就初始化时间节点，renew就延长。</p><p>最后count的时候把所有字符串对应的时间和currentTime比较大小就可以返回答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> timeToLive;<br>    unordered_map&lt;string,<span class="hljs-type">int</span>&gt; valid;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AuthenticationManager</span>(<span class="hljs-type">int</span> timeToLive) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;timeToLive = timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        valid[tokenId] = currentTime + timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">renew</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (valid.<span class="hljs-built_in">count</span>(tokenId) &amp;&amp; valid[tokenId] &gt; currentTime) &#123;<span class="hljs-comment">//unorderedmap不能用find</span><br>            valid[tokenId] = currentTime + timeToLive;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countUnexpiredTokens</span><span class="hljs-params">(<span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//for (auto &amp;[_, time] : mp) &#123;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = valid.<span class="hljs-built_in">begin</span>();it!=valid.<span class="hljs-built_in">end</span>();it++)&#123;<br>            <span class="hljs-keyword">if</span> (it -&gt; second &gt; currentTime) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your AuthenticationManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * AuthenticationManager* obj = new AuthenticationManager(timeToLive);</span><br><span class="hljs-comment"> * obj-&gt;generate(tokenId,currentTime);</span><br><span class="hljs-comment"> * obj-&gt;renew(tokenId,currentTime);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;countUnexpiredTokens(currentTime);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading-02</title>
    <link href="/2022/12/03/PaperReading-02/"/>
    <url>/2022/12/03/PaperReading-02/</url>
    
    <content type="html"><![CDATA[<h1 id="Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences"><a href="#Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences" class="headerlink" title="Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences"></a>Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences</h1><h4 id="A-Paper-summary"><a href="#A-Paper-summary" class="headerlink" title="A. Paper summary"></a>A. Paper summary</h4><h4 id="Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions"><a href="#Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions" class="headerlink" title="Please provide a short summary of the paper that captures the key contributions."></a>Please provide a short summary of the paper that captures the key contributions.</h4><p>DNN inference tasks can be divided into two types according to whether it has real-time demand. However, current GPU scheduling systems don’t maintain throughput well while satisfying real-time preemption. To remedy this problem, this paper presented REEF, the first DNN inference serving system for commodity GPUs. It allows BE task to be executed with RT task without affecting it concurrently.</p><p>The two core technologies respectively are:</p><p>1, Reset-base Preemption: It is proved that the GPU based on DNN inference tasks is idempotent, so it can be quickly preempted by “kill”, and task can be recovery at breakpoints.</p><p>2, Dynamic Kernel Padding: Based on the observation of the predictability of delay of the GPU kernel of DNN inference tasks, the author proposes a controllable concurrent execution method, in the real-time kernel execution, according to its execution delay, dynamically fill the appropriate best-effort kernel with its concurrent execution.</p><h4 id="B-Key-strengths-and-weaknesses"><a href="#B-Key-strengths-and-weaknesses" class="headerlink" title="B. Key strengths and weaknesses"></a>B. Key strengths and weaknesses</h4><h4 id="Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively"><a href="#Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively" class="headerlink" title="Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively."></a>Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively.</h4><p>(+) REEF can preempt concurrent DNN tasks in Microsecond-scale.</p><p>(+) Compared with RT-Only in the DISB test, REEF can increase the throughput by 1.14~7.7 times under the premise of only increasing the latency of RT tasks by 2%.</p><p>(+) REEF are feasible for the closed-source GPUs, and evaluating result shows it reduces the preemption latency.</p><p>(-) When the execution time of best-effort kernels is often longer than that of real-time kernels, the throughput improvement of dynamic kernel padding may be trivial. But it also bring scheduling delay.</p><p>(-) Many commodity GPUs are closed-source, so REEF is unable to manipulate host queues and device queues directly.</p><p>(-) Latency predictability need to develop an offline kernel profiler to measure the computational requirements and the execution time. That is like a pretraining, which needs more time or computing power.</p><h4 id="C-Comments-to-authors"><a href="#C-Comments-to-authors" class="headerlink" title="C. Comments to authors"></a>C. Comments to authors</h4><h4 id="Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review"><a href="#Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review" class="headerlink" title="Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review."></a>Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review.</h4><p>For preemption, this paper shows REEF preemption delay is reduced by 15~18 times compared with existing methods. Not only promising RT tasks demand, but also maintain the throughput, which is instructive in some IoT scheme. Moreover, REEF-N runs on the closed-source GPUs such as NVIDIA and AMD GPUs. It’s available for Users and researchers. But the flaw is it cannot perform well as open source GPUs. In the end, I think if latency predicting judge RT tasks when they put into queue without offline measure in advance is better.</p><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1202</title>
    <link href="/2022/12/02/dailyProblem1202/"/>
    <url>/2022/12/02/dailyProblem1202/</url>
    
    <content type="html"><![CDATA[<h4 id="1769-移动所有球到每个盒子所需的最小操作数"><a href="#1769-移动所有球到每个盒子所需的最小操作数" class="headerlink" title="1769. 移动所有球到每个盒子所需的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/">1769. 移动所有球到每个盒子所需的最小操作数</a></h4><p>难度中等</p><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 <strong>一个</strong> 小球。</p><p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = &quot;110&quot;<br>输出：[1,1,3]<br>解释：每个盒子对应的最小操作数如下：<br>1) 第<span class="hljs-number"> 1 </span>个盒子：将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 1 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>2) 第<span class="hljs-number"> 2 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 2 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>3) 第<span class="hljs-number"> 3 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 2 </span>步操作。将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。共计<span class="hljs-number"> 3 </span>步操作。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">boxes </span>= <span class="hljs-string">&quot;001011&quot;</span><br>输出：[<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直观地理解，其实就是每一个小球都只能一步移动。</p><p>让所有球都集中到某个盒子，所需的次数其实就是小球与这个盒子的距离。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(string boxes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxes.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(boxes[j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans[i] += <span class="hljs-built_in">abs</span>(i-j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading_01</title>
    <link href="/2022/11/29/PaperReading-01/"/>
    <url>/2022/11/29/PaperReading-01/</url>
    
    <content type="html"><![CDATA[<h1 id="L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites"><a href="#L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites" class="headerlink" title="L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites"></a>L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites</h1><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><p>实时高分辨率的地球图片回传非常具有挑战性；因为轨道很低并且在高速移动。集中式架构的地面接收站会招致小时级别的数据下载延迟，并且因为造价原因难以扩展。作者希望降低数据回传时延。</p><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><p>L2D2——地面分布式站点设计。</p><p>是使用低成本的商品硬件提供低时延和鲁棒下载链接的混合地面站模型，只有一部分地面站有上行链路功能。还设计了用于调度和速率自适应的新算法，尽管仅接收地面站存在局限性，但仍可实现低延迟和高鲁棒性。</p><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><p>1，L2D2模型拥有全球分布式的地面站点</p><p>——使得卫星可以follow动态下行链路的调度，并降低了数据下行的时延。</p><p>2，混合式站点部署</p><p>——大部分站点只有接收功能，不传输任何数据，使得模型整体易于扩展。</p><p>3，低复杂度降低维护成本</p><p>——单个地面站没有专用设备，而是易于部署的商品硬件，通过多个地面站互补链路容量。</p><p>4，利用机器学习的方法来建模解决速率适应问题</p><p>——梯度提升回归树，基于深度学习的回归。</p><p><img src="C:\Users\Aki\OneDrive\桌面\model.png" alt="model"></p><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><p>使用真实世界链路质量测量和模拟的组合</p><p>作者从 X 波段运行的 16 对地面站-卫星和在 Ka 波段运行的 1 对地面站-卫星对中收集真实世界的数据，</p><p>使用从开源的SatNOGS地面站部署收集的数据用于仿真来评估L2D2，这些地站会监听政府和学术机构卫星的广播信号，数据放在一个公开数据集。选择了可运行的地面站并且进行了至少 1000 次观察。</p><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3><p>提出了新的模型：仅能下载的和上下行皆可的。其地理分布式以及新的调度方案、速率适应方案使得L2D2可以从大规模的LEO中经过数分钟成功下载数据，而传统的则需要几个小时。由于设计比较简单、低成本，所以易于推广。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1129</title>
    <link href="/2022/11/29/dailyProblem1129/"/>
    <url>/2022/11/29/dailyProblem1129/</url>
    
    <content type="html"><![CDATA[<h4 id="1758-生成交替二进制字符串的最少操作数"><a href="#1758-生成交替二进制字符串的最少操作数" class="headerlink" title="1758. 生成交替二进制字符串的最少操作数"></a><a href="https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/">1758. 生成交替二进制字符串的最少操作数</a></h4><p>给你一个仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code> ，或者将 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code> 。</p><p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code> 是交替字符串，而字符串 <code>&quot;0100&quot;</code> 不是。</p><p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;0100&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：如果将最后一个字符变为 &#x27;1&#x27; ，s 就变成 <span class="hljs-string">&quot;0101&quot;</span> ，即符合交替字符串定义。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：s 已经是交替字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：需要 <span class="hljs-number">2</span> 步操作得到 <span class="hljs-string">&quot;0101&quot;</span> 或 <span class="hljs-string">&quot;1010&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，答案字符串只有两种可能性，一种是0开头，另一种是1开头，然后让字符串s分别变成这两种字符串，取最小变化次数的一个就行。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;<br>        string s2 = s;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            cnt1++;<br>            s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i+<span class="hljs-number">1</span>])&#123;<br>                s[i+<span class="hljs-number">1</span>] = (s[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt1++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s2[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            cnt2++;<br>            s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s2.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s2[i]==s2[i+<span class="hljs-number">1</span>])&#123;<br>                s2[i+<span class="hljs-number">1</span>] = (s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cnt1,cnt2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LABOBASE TEST</title>
    <link href="/2022/11/18/LABOBASE-TEST/"/>
    <url>/2022/11/18/LABOBASE-TEST/</url>
    
    <content type="html"><![CDATA[<h1 id="再部署"><a href="#再部署" class="headerlink" title="再部署"></a>再部署</h1><p>在实验室也重新搭建了博客，以后用来update一些论文阅读，周报，以及题解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>LOG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/18/hello-world/"/>
    <url>/2022/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Essay-05</title>
    <link href="/2022/05/02/essay-05/"/>
    <url>/2022/05/02/essay-05/</url>
    
    <content type="html"><![CDATA[<h3 id="找不到的终点"><a href="#找不到的终点" class="headerlink" title="找不到的终点"></a>找不到的终点</h3><p>现在是五月，距离考研成功已经过去快40天了，五一假期之前都是一个人自己干自己的，也没怎么和朋友联系，聊天也只是那种吹吹水的闲聊程度，大部分时间都在打牌（四月上半MTGA，下半研究游戏王）。找工作似乎因为没有在读学籍没有企业想要，也就有了借口玩牌了。</p><p>五一假期见了同学和朋友，刷刷朋友圈，大家似乎都逐渐步入常规化的“人生正轨”或者在享受充实而又有趣的人生，突然就负能量爆棚了。</p><p>觉得自己没钱没女朋友没本事，突然就反思起自己怎么就过成这个鬼样了，又把自己投身于同龄人的比较中，又被peer pressure裹挟了。从大学入学我就开始想，我似乎在很久的时间都把人生价值的实现放在“与他人竞争并获胜”这一件事中，在一次次地意识到自己的无力感之后开始逐渐怀疑自己。这似乎是内心不够充盈的表现，在落败后逃避，沉沦，只会导致更多的败北。最终我一战失败，再浪费一年的时间来考研，虽然今年也考上了，但并没有那种发自内心的快乐，知道结果的那一刻最大的感受只是松了一口气——幸好没有被大伙继续抛下。</p><p>今晚想了很多，我其实很羡慕大家那种“正轨人生”，有异性伴侣，会享受生活，会努力学习工作，可能还会有确切的人生目标。相反，我就只care每一次的“较量”，一直没有正视过我的人生目标。其实从大二开始也有想过，自己要成为什么样的人。我还是记得中学阶段那个狂妄的梦想：我要改变世界：通过我的智力成果，来改变人们的生活方式，或者说，我希望的我的科研成果能推动世界发展。但是在大学里有很多的学术机会，我都没把握住，我不好说是因为娱乐和游戏的诱惑，还是说自己的兴趣根本就不足以支撑完成高难度任务。总之，本科期间没做出什么拿得出手的项目，甚至连实习经历都没有。而时常跟幻龙骑群友口嗨的：我想要当决斗王，其实自己也没有往心里去。因为在心底里，其实一直都认为这个卡牌游戏，他只是一个游戏，他并不是我实现人生价值的工具，才会一直“只是玩玩的程度”，重心其实还是在学业上。什么都想要等于什么都没有，就是这种贪，才导致今天因为无能而自责。</p><p>我没有出众的相貌和身材；曾经以为能成为优势的智力，在优秀的群体里也发不出光芒；生在不富有的家庭，但好在父母非常爱我。就是这种软硬件都没有办法成为个人竞争力的我，在进入社会后，只能变成一块不起眼的石头。都说是金子总会发光，但是多次的挫折已经使我失去了旧有的自信：大学里面成绩不够拔尖，考研失败，应届985毕业并没有拿到国内一线大厂offer，二战上岸后找不到实习……虽然要我在人前里面似乎都能找到各种理由来掩盖自己的无能与脆弱。但，我知道的，我自己是明知情况不乐观，却没有奋身去为一个目标去努力。我会感叹和赞赏努力家，也会暗示自己是需要努力了，但每一次每一次，都只有三分钟热度，没有长期的坚持。</p><p>我也害怕，读完研，我还是没有成长，我还记得自己以前对未来的自己有很多寄望，甚至相信自己有能力实现“改变世界”的梦想。在今天24岁的我看来是真的愧对以前充满自信朝气的自己，尽管那个时候的我只是为了在一次一次的竞争中取胜。</p><p>我很疑惑，我不知道我未来能不能找到人生的终点，我很功利，我很担心在在一条路上奔跑，却跑不到终点（不能成功），所以可能也解释了为什么我没有办法为一个目标长期奋斗。但是浑浑噩噩地度日是没有办法走到我的终点的。</p><p>思绪很乱，想整理这些bad mood然后思考自己应该何去何从，这不是一件易事。从小都是自己给自己挖坑，非要先落后再追赶，一次一次地追赶身边优秀的个体，跑着跑着身边的人也都变成了都在奔跑的player，现在的落后只会逐渐积累成不可超越的距离，距离会大到我一看到追赶所需要付出的努力程度就足以让我放弃。</p><p>所以，把“胜利”当成人生价值和人生目标，大概是一个不可实现的命题了。不去考虑自己是否能成为社会评价中的“人生赢家”，仅仅是让自己留在同龄人的领跑队伍中足以让我背负沉重的压力。因为要强的个性和强势的性格，我不可能容忍自己摆烂的，如果要让自己从这种“自讨苦吃”的竞争循环中抽离出来，除了需要着眼于当下应做之事以外，对我而言未来三年的人生最重要的命题就是找到：愿意为之而奉献人生之事。希望未来人生的道路不是追赶，而是能找到，属于自己的道路，focus自己的目标，在前进的途中逐渐丰盈自己的心灵。</p><p>这大概是唯一能从这种周期性循环的emotion中解脱，并且能让自己在短短的人生中跑到自己的终点的途径了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-30 每日一题</title>
    <link href="/2022/04/30/2022.4.30%20daily%20problem/"/>
    <url>/2022/04/30/2022.4.30%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="908-最小差值-I"><a href="#908-最小差值-I" class="headerlink" title="908. 最小差值 I"></a><a href="https://leetcode-cn.com/problems/smallest-range-i/">908. 最小差值 I</a></h2><p>难度简单</p><p>给你一个整数数组 <code>nums</code>，和一个整数 <code>k</code> 。</p><p>在一个操作中，您可以选择 <code>0 &lt;= i &lt; nums.length</code> 的任何索引 <code>i</code> 。将 <code>nums[i]</code> 改为 <code>nums[i] + x</code> ，其中 <code>x</code> 是一个范围为 <code>[-k, k]</code> 的整数。对于每个索引 <code>i</code> ，最多 <strong>只能</strong> 应用 <strong>一次</strong> 此操作。</p><p><code>nums</code> 的 <strong>分数</strong> 是 <code>nums</code> 中最大和最小元素的差值。 </p><p><em>在对 <code>nums</code> 中的每个索引最多应用一次上述操作后，返回 <code>nums</code> 的最低 <strong>分数</strong></em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1]</span>, k = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br>解释：分数是 <span class="hljs-built_in">max</span>(nums) - <span class="hljs-built_in">min</span>(nums) = <span class="hljs-number">1</span> - <span class="hljs-number">1</span> = <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[0,10]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">6</span><br>解释：将 nums 改为 <span class="hljs-selector-attr">[2,8]</span>。分数是 <span class="hljs-built_in">max</span>(nums) - <span class="hljs-built_in">min</span>(nums) = <span class="hljs-number">8</span> - <span class="hljs-number">2</span> = <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,3,6]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">0</span><br>解释：将 nums 改为 <span class="hljs-selector-attr">[4,4,4]</span>。分数是 <span class="hljs-built_in">max</span>(nums) - <span class="hljs-built_in">min</span>(nums) = <span class="hljs-number">4</span> - <span class="hljs-number">4</span> = <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 104</code></li><li><code>0 &lt;= k &lt;= 104</code></li></ul></li></ul><h2 id="方法一：找最大最小"><a href="#方法一：找最大最小" class="headerlink" title="方法一：找最大最小"></a>方法一：找最大最小</h2><p>简单点想，这个答案肯定是从原本的最小和原本的最大里面组合出来的，因为在区间内的在通过”往中间靠拢后“都不可能比原本的最小最大更小或更大。</p><p>秒杀！</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallestRangeI</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> min = INT_MAX,max = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;max)&#123;<br>                max = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;min)&#123;<br>                min = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max - k&lt;=min+k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max - min <span class="hljs-number">-2</span>*k;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <link href="/2022/04/29/%E7%AE%97%E6%B3%95%20-%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2022/04/29/%E7%AE%97%E6%B3%95%20-%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><p>难度中等753</p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-meta">#,2,3,#,4,5,6,7,#]</span><br>解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 <span class="hljs-keyword">next</span> 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 <span class="hljs-keyword">next</span> 指针连接，<span class="hljs-string">&#x27;#&#x27;</span> 标志着每一层的结束。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul></li></ul><h2 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h2><p>这道题目主要就是考察层序遍历，自己也想到了用队列然后每层循环之前进行当前队列大小的获取，用来确定当前层的循环结束，不过之前都没有认真写过一次层序，这次正好自己写一遍。</p><p>但是我写if（!tempnode-&gt;left）跑不通，要if（tempnode-&gt;left!&#x3D;nullptr）才行，为什么呢？</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="hljs-comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        queue&lt;Node*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                Node* tempnode = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(i&lt;n<span class="hljs-number">-1</span>)&#123;<br>                    tempnode -&gt; next = q.<span class="hljs-built_in">front</span>();<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span>(tempnode-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(tempnode-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tempnode-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(tempnode-&gt;right);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并二叉树</title>
    <link href="/2022/04/29/%E7%AE%97%E6%B3%95%20-%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/04/29/%E7%AE%97%E6%B3%95%20-%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><p>难度简单</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li></ul></li></ul><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>深搜就对了，先做左边后做右边。</p><p>需要注意的是，不要用root！-&gt; left这种语句去判空，这种语句在递归的时候容易发生访问nullptr节点的右边，</p><p>所以把判空放在函数的开头，如果1空就返回2，2空就返回1。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1)&#123;<br>            <span class="hljs-keyword">return</span> root2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!root2)&#123;<br>            <span class="hljs-keyword">return</span> root1;<br>        &#125;<br>        root1-&gt;val = root1-&gt;val + root2-&gt;val;<br>        root1 -&gt; left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);<br>        root1 -&gt; right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br><br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-29 每日一题</title>
    <link href="/2022/04/29/2022.4.29%20daily%20problem/"/>
    <url>/2022/04/29/2022.4.29%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="427-建立四叉树"><a href="#427-建立四叉树" class="headerlink" title="427. 建立四叉树"></a><a href="https://leetcode-cn.com/problems/construct-quad-tree/">427. 建立四叉树</a></h2><p>难度中等</p><p>给你一个 <code>n * n</code> 矩阵 <code>grid</code> ，矩阵由若干 <code>0</code> 和 <code>1</code> 组成。请你用四叉树表示该矩阵 <code>grid</code> 。</p><p>你需要返回能表示矩阵的 四叉树 的根结点。</p><p>注意，当 <code>isLeaf</code> 为 <strong>False</strong> 时，你可以把 <strong>True</strong> 或者 <strong>False</strong> 赋值给节点，两种值都会被判题机制 <strong>接受</strong> 。</p><p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p><ul><li><code>val</code>：储存叶子结点所代表的区域的值。1 对应 <strong>True</strong>，0 对应 <strong>False</strong>；</li><li><code>isLeaf</code>: 当这个节点是一个叶子结点时为 <strong>True</strong>，如果它有 4 个子节点则为 <strong>False</strong> 。</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">class <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">    public</span> boolean val;<br>    public boolean isLeaf;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">topRight</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomLeft</span>;<br>    public <span class="hljs-keyword">Node</span> <span class="hljs-title">bottomRight</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以按以下步骤为二维区域构建四叉树：</p><ol><li>如果当前网格的值相同（即，全为 <code>0</code> 或者全为 <code>1</code>），将 <code>isLeaf</code> 设为 True ，将 <code>val</code> 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li><li>如果当前网格的值不同，将 <code>isLeaf</code> 设为 False， 将 <code>val</code> 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li><li>使用适当的子网格递归每个子节点。</li></ol><p><img src="https://assets.leetcode.com/uploads/2020/02/11/new_top.png" alt="img"></p><p>如果你想了解更多关于四叉树的内容，可以参考 <a href="https://en.wikipedia.org/wiki/Quadtree">wiki</a> 。</p><p><strong>四叉树格式：</strong></p><p>输出为使用层序遍历后四叉树的序列化形式，其中 <code>null</code> 表示路径终止符，其下面不存在节点。</p><p>它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 <code>[isLeaf, val]</code> 。</p><p>如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 True ，则表示它在列表 <code>[isLeaf, val]</code> 中的值为 <strong>1</strong> ；如果 <code>isLeaf</code> 或者 <code>val</code> 的值为 False ，则表示值为 <strong>0</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/11/grid1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,1],[1,0]]</span><br>输出：<span class="hljs-string">[[0,1],[1,0],[1,1],[1,1],[1,0]]</span><br>解释：此示例的解释如下：<br>请注意，在下面四叉树的图示中，<span class="hljs-number">0</span> 表示 <span class="hljs-literal">false</span>，<span class="hljs-number">1</span> 表示 True 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/02/12/e2mat.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,1,1,1,1]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>,<span class="hljs-comment">[1,1,1,1,0,0,0,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>,null,null,null,null,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,1]</span>]</span><br>解释：网格中的所有值都不相同。我们将网格划分为四个子网格。<br>topLeft，bottomLeft 和 bottomRight 均具有相同的值。<br>topRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。<br>解释如下图所示：<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1],[1,1]]</span><br>输出：<span class="hljs-string">[[1,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0]]</span><br>输出：<span class="hljs-string">[[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：grid = <span class="hljs-comment">[<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[1,1,0,0]</span>,<span class="hljs-comment">[0,0,1,1]</span>,<span class="hljs-comment">[0,0,1,1]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[1,1]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,0]</span>,<span class="hljs-comment">[1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>n == grid.length == grid[i].length</code></li><li><code>n == 2^x</code> 其中 <code>0 &lt;= x &lt;= 6</code></li></ol></li></ul><h2 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h2><p>不会，抄答案。</p><p>我们可以使用递归的方法构建出四叉树。</p><p>具体地，我们用递归函数<br>$$<br>\text{dfs}(r_0, c_0, r_1, c_1)<br>$$<br>处理给定的矩阵 grid 从 r_0行开始到<br>$$<br>r_1-1<br>$$<br>行，从 c_0和<br>$$<br>c_1-1<br>$$<br>列的部分。我们首先判定这一部分是否均为 0 或 1，如果是，那么这一部分对应的是一个叶节点，我们构造出对应的叶节点并结束递归；如果不是，那么这一部分对应的是一个非叶节点，我们需要将其分成四个部分：行的分界线为<br>$$<br>\dfrac{r_0+r_1}{2}<br>$$<br> ，列的分界线为<br>$$<br>\dfrac{c_0+c_1}{2}<br>$$<br>，根据这两条分界线递归地调用dfs函数得到四个部分对应的树，再将它们对应地挂在非叶节点的四个子节点上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a QuadTree node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    bool val;</span><br><span class="hljs-comment">    bool isLeaf;</span><br><span class="hljs-comment">    Node* topLeft;</span><br><span class="hljs-comment">    Node* topRight;</span><br><span class="hljs-comment">    Node* bottomLeft;</span><br><span class="hljs-comment">    Node* bottomRight;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node() &#123;</span><br><span class="hljs-comment">        val = false;</span><br><span class="hljs-comment">        isLeaf = false;</span><br><span class="hljs-comment">        topLeft = NULL;</span><br><span class="hljs-comment">        topRight = NULL;</span><br><span class="hljs-comment">        bottomLeft = NULL;</span><br><span class="hljs-comment">        bottomRight = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(bool _val, bool _isLeaf) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        isLeaf = _isLeaf;</span><br><span class="hljs-comment">        topLeft = NULL;</span><br><span class="hljs-comment">        topRight = NULL;</span><br><span class="hljs-comment">        bottomLeft = NULL;</span><br><span class="hljs-comment">        bottomRight = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        isLeaf = _isLeaf;</span><br><span class="hljs-comment">        topLeft = _topLeft;</span><br><span class="hljs-comment">        topRight = _topRight;</span><br><span class="hljs-comment">        bottomLeft = _bottomLeft;</span><br><span class="hljs-comment">        bottomRight = _bottomRight;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node *<span class="hljs-title">construct</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        function&lt;Node*(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> r0, <span class="hljs-type">int</span> c0, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> c1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r0; i &lt; r1; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = c0; j &lt; c1; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (grid[i][j] != grid[r0][c0]) &#123; <span class="hljs-comment">// 不是叶节点</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<br>                                <span class="hljs-literal">true</span>,<br>                                <span class="hljs-literal">false</span>,<br>                                <span class="hljs-built_in">dfs</span>(r0, c0, (r0 + r1) / <span class="hljs-number">2</span>, (c0 + c1) / <span class="hljs-number">2</span>),<br>                                <span class="hljs-built_in">dfs</span>(r0, (c0 + c1) / <span class="hljs-number">2</span>, (r0 + r1) / <span class="hljs-number">2</span>, c1),<br>                                <span class="hljs-built_in">dfs</span>((r0 + r1) / <span class="hljs-number">2</span>, c0, r1, (c0 + c1) / <span class="hljs-number">2</span>),<br>                                <span class="hljs-built_in">dfs</span>((r0 + r1) / <span class="hljs-number">2</span>, (c0 + c1) / <span class="hljs-number">2</span>, r1, c1)<br>                        );<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 是叶节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(grid[r0][c0], <span class="hljs-literal">true</span>);<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, grid.<span class="hljs-built_in">size</span>(), grid.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿的最大面积</title>
    <link href="/2022/04/28/%E7%AE%97%E6%B3%95%20-%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%88DFS%EF%BC%89/"/>
    <url>/2022/04/28/%E7%AE%97%E6%B3%95%20-%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF%EF%BC%88DFS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><p>难度中等</p><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p><p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p><p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：grid = [[<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,1,0</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,1,0,0</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">1,1,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,1,0,0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,1</span>,<span class="hljs-number">1,0,0,0</span>,<span class="hljs-number">0</span>]]<br>输出：<span class="hljs-number">6</span><br>解释：答案不应该是 <span class="hljs-number">11</span> ，因为岛屿只能包含水平或垂直这四个方向上的 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[0,0,0,0,0,0,0,0]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul></li></ul><h2 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h2><p>不知道是不是第一次独立完成带visited数组的广度搜索题目。</p><p>总之就是每次遍历到非0位置就开始搜索，计算该区域的最大面积，利用访问数组获知哪些位置已经参与过计算来减少计算量。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//为了代码简洁而事先设置得位移数组</span><br>        <span class="hljs-type">int</span> my[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(),n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        vector&lt; vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">visit</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<span class="hljs-comment">//记录访问过的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>&amp;&amp;visit[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-type">int</span> temp = <span class="hljs-number">1</span>;<span class="hljs-comment">//当前区域的面积变量</span><br>                    visit[i][j] = <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(i,j);<br>                    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//用栈广搜</span><br>                        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>().first,s = q.<span class="hljs-built_in">front</span>().second;<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;<br>                            <span class="hljs-type">int</span> x = t+mx[k],y = s+my[k];<br>                            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;m&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]==<span class="hljs-number">1</span>&amp;&amp;visit[x][y]==<span class="hljs-number">0</span>)&#123;<br>                                temp++;<br>                                q.<span class="hljs-built_in">emplace</span>(x,y);<br>                                visit[x][y]=<span class="hljs-number">1</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    ans = <span class="hljs-built_in">max</span>(temp,ans);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-27 每日一题</title>
    <link href="/2022/04/27/2022.4.27%20daily%20problem/"/>
    <url>/2022/04/27/2022.4.27%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h2><p>难度中等379收藏分享切换为英文接收动态反馈</p><p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong> 处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p><p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p><p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回 <em>网格坐标 <code>result</code> 的 <strong>2D列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水可以从单元格 <code>(ri, ci)</code> 流向 <strong>太平洋和大西洋</strong></em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: heights = <span class="hljs-comment">[<span class="hljs-comment">[1,2,2,3,5]</span>,<span class="hljs-comment">[3,2,3,4,4]</span>,<span class="hljs-comment">[2,4,5,3,1]</span>,<span class="hljs-comment">[6,7,1,4,5]</span>,<span class="hljs-comment">[5,1,1,2,4]</span>]</span><br>输出: <span class="hljs-comment">[<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[2,2]</span>,<span class="hljs-comment">[3,0]</span>,<span class="hljs-comment">[3,1]</span>,<span class="hljs-comment">[4,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: heights = <span class="hljs-string">[[2,1],[1,2]]</span><br>输出: <span class="hljs-string">[[0,0],[0,1],[1,0],[1,1]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == heights.length</code></li><li><code>n == heights[r].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= heights[r][c] &lt;= 105</code></li></ul></li></ul><h2 id="方法一：DFS"><a href="#方法一：DFS" class="headerlink" title="方法一：DFS"></a>方法一：DFS</h2><p>雨水的流动方向是从高到低，每个单元格上的雨水只能流到高度小于等于当前单元格的相邻单元格。从一个单元格开始，通过搜索的方法模拟雨水的流动，则可以判断雨水是否可以从该单元格流向海洋。</p><p>如果直接以每个单元格作为起点模拟雨水的流动，则会重复遍历每个单元格，导致时间复杂度过高。为了降低时间复杂度，可以从矩阵的边界开始反向搜索寻找雨水流向边界的单元格，反向搜索时，每次只能移动到高度相同或更大的单元格。</p><p>由于矩阵的左边界和上边界是太平洋，矩阵的右边界和下边界是大西洋，因此从矩阵的左边界和上边界开始反向搜索即可找到雨水流向太平洋的单元格，从矩阵的右边界和下边界开始反向搜索即可找到雨水流向大西洋的单元格。</p><p>可以使用深度优先搜索实现反向搜索，搜索过程中需要记录每个单元格是否可以从太平洋反向到达以及是否可以从大西洋反向到达。反向搜索结束之后，遍历每个网格，如果一个网格既可以从太平洋反向到达也可以从大西洋反向到达，则该网格满足太平洋和大西洋都可以到达，将该网格添加到答案中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> dirs[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; heights;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, <span class="hljs-type">int</span> col, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp; ocean)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = ocean.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = ocean[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (ocean[row][col]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ocean[row][col] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>            <span class="hljs-type">int</span> newRow = row + dirs[i][<span class="hljs-number">0</span>], newCol = col + dirs[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (newRow &gt;= <span class="hljs-number">0</span> &amp;&amp; newRow &lt; m &amp;&amp; newCol &gt;= <span class="hljs-number">0</span> &amp;&amp; newCol &lt; n &amp;&amp; heights[newRow][newCol] &gt;= heights[row][col]) &#123;<br>                <span class="hljs-built_in">dfs</span>(newRow, newCol, ocean);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;heights = heights;<br>        <span class="hljs-type">int</span> m = heights.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">pacific</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">atlantic</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">0</span>, pacific);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, j, pacific);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-built_in">dfs</span>(i, n - <span class="hljs-number">1</span>, atlantic);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-built_in">dfs</span>(m - <span class="hljs-number">1</span>, j, atlantic);<br>        &#125;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; cell;<br>                    cell.<span class="hljs-built_in">emplace_back</span>(i);<br>                    cell.<span class="hljs-built_in">emplace_back</span>(j);<br>                    result.<span class="hljs-built_in">emplace_back</span>(cell);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串的排列</title>
    <link href="/2022/04/27/%E7%AE%97%E6%B3%95%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%88%E4%BE%8B%EF%BC%89/"/>
    <url>/2022/04/27/%E7%AE%97%E6%B3%95%20-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h2><p>难度中等</p><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：<span class="hljs-built_in">s1</span> = <span class="hljs-string">&quot;ab&quot;</span> <span class="hljs-built_in">s2</span> = <span class="hljs-string">&quot;eidbaooo&quot;</span><br>输出：true<br>解释：<span class="hljs-built_in">s2</span> 包含 <span class="hljs-built_in">s1</span> 的排列之一 (<span class="hljs-string">&quot;ba&quot;</span>).<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s1<span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span> s2 <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eidboaoo&quot;</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> 和 <code>s2</code> 仅包含小写字母</li></ul></li></ul><h2 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h2><p>首先是利用只有小写字母 转化成0~25，这样就不需要用unordered_map来计数，直接使用int数组。</p><p>第二个重点也是这道题的难点，就是当发现了不在1号串的字符时，要把左侧下标一直平移至最新位置，已在注释中标出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s1.<span class="hljs-built_in">length</span>(), m = s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            --cnt[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; m; ++right) &#123;<br>            <span class="hljs-type">int</span> x = s2[right] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            ++cnt[x];<br>            <span class="hljs-keyword">while</span> (cnt[x] &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//这里要用while，是因为要把左侧一直前移到当前位置。</span><br>                --cnt[s2[left] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>                ++left;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> == n) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="/2022/04/27/%E7%AE%97%E6%B3%95%20-%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%88%E4%BE%8B%EF%BC%89/"/>
    <url>/2022/04/27/%E7%AE%97%E6%B3%95%20-%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>难度中等</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul></li></ul><h2 id="方法一：滑动窗口"><a href="#方法一：滑动窗口" class="headerlink" title="方法一：滑动窗口"></a>方法一：滑动窗口</h2><p>在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度。</p><p>在失配的时候的理解：因为在失配的时候，right指针并没有右移，所以在下一次的遍历左指针左移后为开始，直到right指针作为结束的子串也是没有重复字符的，所以可以逐步尝试右移right，只要失配就继续尝试下一次遍历。</p><p>在上面的流程中，我们还需要使用一种数据结构来判断 是否有重复的字符，常用的数据结构为哈希集合。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; jishu;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">-1</span>,result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>                jishu.<span class="hljs-built_in">erase</span>(s[i<span class="hljs-number">-1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right +<span class="hljs-number">1</span>&lt; n&amp;&amp;!jishu.<span class="hljs-built_in">count</span>(s[right+<span class="hljs-number">1</span>]))&#123;<br>                jishu.<span class="hljs-built_in">insert</span>(s[right+<span class="hljs-number">1</span>]);<br>                right++;<br>            &#125;<br>            result = <span class="hljs-built_in">max</span>(result,right-i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第 N 个结点</title>
    <link href="/2022/04/26/%E7%AE%97%E6%B3%95%20-%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2022/04/26/%E7%AE%97%E6%B3%95%20-%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p>难度中等</p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p></li></ul><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>记录两个指针p和q。</p><p>q先前进n步，之后p和q再一起前进直至q访问到链表尾。</p><p>思路是没错的但是那个长度为一的特殊测例一直过不去，看了答案发现是要使用“哑节点”</p><p>让他的next指针指向链表的头节点，之后我们就不用对头节点进行特殊判断了。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>, head);<br>        ListNode* first = head;<br>        ListNode* second = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            first = first-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (first) &#123;<br>            first = first-&gt;next;<br>            second = second-&gt;next;<br>        &#125;<br>        second-&gt;next = second-&gt;next-&gt;next;<br>        ListNode* ans = dummy-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummy;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-26 每日一题</title>
    <link href="/2022/04/26/2022.4.26%20daily%20problem/"/>
    <url>/2022/04/26/2022.4.26%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="883-三维形体投影面积"><a href="#883-三维形体投影面积" class="headerlink" title="883. 三维形体投影面积"></a><a href="https://leetcode-cn.com/problems/projection-area-of-3d-shapes/">883. 三维形体投影面积</a></h2><p>难度简单</p><p>在 <code>n x n</code> 的网格 <code>grid</code> 中，我们放置了一些与 x，y，z 三轴对齐的 <code>1 x 1 x 1</code> 立方体。</p><p>每个值 <code>v = grid[i][j]</code> 表示 <code>v</code> 个正方体叠放在单元格 <code>(i, j)</code> 上。</p><p>现在，我们查看这些立方体在 <code>xy</code> 、<code>yz</code> 和 <code>zx</code> 平面上的<em>投影</em>。</p><p><strong>投影</strong> 就像影子，将 <strong>三维</strong> 形体映射到一个 <strong>二维</strong> 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。</p><p>返回 <em>所有三个投影的总面积</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-number">17</span><br>解释：这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[2]]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-string">[[1,0],[0,2]]</span><br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == grid.length == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 50</code></li><li><code>0 &lt;= grid[i][j] &lt;= 50</code></li></ul></li></ul><h2 id="方法一：直接投影"><a href="#方法一：直接投影" class="headerlink" title="方法一：直接投影"></a>方法一：直接投影</h2><p>读题读了很久很久，一直没get到题目的形体是怎么给出的。</p><p>最后终于发现了，他是按每列每行给出的，比如第一个元组的里面的元素，是按x&#x3D;1，然后保持x坐标不变，y轴坐标递增放置，然后元素的值就代表形体在这个坐标的的高度。</p><p>之后就不难了。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">projectionArea</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> xyArea = <span class="hljs-number">0</span>, yzArea = <span class="hljs-number">0</span>, zxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> yzHeight = <span class="hljs-number">0</span>, zxHeight = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                xyArea += grid[i][j] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                yzHeight = <span class="hljs-built_in">max</span>(yzHeight, grid[i][j]);<br>                zxHeight = <span class="hljs-built_in">max</span>(zxHeight, grid[j][i]);<br>            &#125;<br>            yzArea += yzHeight;<br>            zxArea += zxHeight;<br>        &#125;<br>        <span class="hljs-keyword">return</span> xyArea + yzArea + zxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-25 每日一题</title>
    <link href="/2022/04/25/2022.4.25%20daily%20problem/"/>
    <url>/2022/04/25/2022.4.25%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="398-随机数索引"><a href="#398-随机数索引" class="headerlink" title="398. 随机数索引"></a><a href="https://leetcode-cn.com/problems/random-pick-index/">398. 随机数索引</a></h2><p>难度中等</p><p>给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。</p><p><strong>注意：</strong><br>数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。</p><p><strong>示例:</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>&#125;;<br>Solution solution = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Solution(<span class="hljs-params">nums</span>)</span>;<br><br><span class="hljs-comment">// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。</span><br>solution.pick(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// pick(1) 应该返回 0。因为只有nums[0]等于1。</span><br>solution.pick(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：哈希链表"><a href="#方法一：哈希链表" class="headerlink" title="方法一：哈希链表"></a>方法一：哈希链表</h2><p>建立哈希表，把每个相同的元素的位置，挂到哈希表尾，要取某个目标数的位置时，在哈希表中随机取一个值，题目要只要求概率均等，使用模除法就可以。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; pos;<span class="hljs-comment">//哈希表</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            pos[nums[i]].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//挂在表尾部</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pick</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> &amp;indices = pos[target];<br>        <span class="hljs-keyword">return</span> indices[<span class="hljs-built_in">rand</span>() % indices.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;pick(target);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <link href="/2022/04/24/%E7%AE%97%E6%B3%95%20-%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/04/24/%E7%AE%97%E6%B3%95%20-%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h2><p>难度中等</p><p>给你一个下标从 <strong>1</strong> 开始的整数数组 <code>numbers</code> ，该数组已按 <strong>非递减顺序排列</strong> ，请你从数组中找出满足相加之和等于目标数 <code>target</code> 的两个数。如果设这两个数分别是 <code>numbers[index1]</code> 和 <code>numbers[index2]</code> ，则 <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code> 。</p><p>以长度为 2 的整数数组 <code>[index1, index2]</code> 的形式返回这两个整数的下标 <code>index1</code> 和 <code>index2</code>。</p><p>你可以假设每个输入 <strong>只对应唯一的答案</strong> ，而且你 <strong>不可以</strong> 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：numbers = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[1,2]</span><br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 <span class="hljs-comment">[1, 2]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：numbers = <span class="hljs-comment">[2,3,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,3]</span><br>解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 <span class="hljs-comment">[1, 3]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：numbers = [<span class="hljs-string">-1</span>,0], target = <span class="hljs-string">-1</span><br>输出：[1,2]<br>解释：<span class="hljs-string">-1</span> 与 0 之和等于目标数 <span class="hljs-string">-1</span> 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li><li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li><li><code>numbers</code> 按 <strong>非递减顺序</strong> 排列</li><li><code>-1000 &lt;= target &lt;= 1000</code></li><li><strong>仅存在一个有效答案</strong></li></ul></li><li></li></ul><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>一个指针指向左侧，另一个指向右侧，每次把指针指向的元素求和。</p><p>如果和比target小，左边指针右移一位，否则右边指针左移一位，直至和与target相等，然后返回。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j=numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]+numbers[j]&gt;target)&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[i]+numbers[j]&lt;target)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>                ans.<span class="hljs-built_in">push_back</span>(j+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-24 每日一题</title>
    <link href="/2022/04/24/2022.4.24%20daily%20problem/"/>
    <url>/2022/04/24/2022.4.24%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="868-二进制间距"><a href="#868-二进制间距" class="headerlink" title="868. 二进制间距"></a><a href="https://leetcode-cn.com/problems/binary-gap/">868. 二进制间距</a></h2><p>难度简单</p><p>给定一个正整数 <code>n</code>，找到并返回 <code>n</code> 的二进制表示中两个 <strong>相邻</strong> 1 之间的 <strong>最长距离</strong> 。如果不存在两个相邻的 1，返回 <code>0</code> 。</p><p>如果只有 <code>0</code> 将两个 <code>1</code> 分隔开（可能不存在 <code>0</code> ），则认为这两个 1 彼此 <strong>相邻</strong> 。两个 <code>1</code> 之间的距离是它们的二进制表示中位置的绝对差。例如，<code>&quot;1001&quot;</code> 中的两个 <code>1</code> 的距离为 3 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 22<br>输出：2<br>解释：22 的二进制是 &quot;10110&quot; 。<br>在<span class="hljs-number"> 22 </span>的二进制表示中，有三个 1，组成两对相邻的<span class="hljs-number"> 1 </span>。<br>第一对相邻的<span class="hljs-number"> 1 </span>中，两个<span class="hljs-number"> 1 </span>之间的距离为<span class="hljs-number"> 2 </span>。<br>第二对相邻的<span class="hljs-number"> 1 </span>中，两个<span class="hljs-number"> 1 </span>之间的距离为<span class="hljs-number"> 1 </span>。<br>答案取两个距离之中最大的，也就是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-number">8</span> 的二进制是 <span class="hljs-string">&quot;1000&quot;</span> 。<br>在 <span class="hljs-number">8</span> 的二进制表示中没有相邻的两个 <span class="hljs-number">1</span>，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">5</span> 的二进制是 <span class="hljs-string">&quot;101&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 109</code></li></ul></li></ul><h2 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h2><p>首先要知道 对int变量进行&amp;1运算，是用最低位与1进行与运算，所以可以通过在每一个循环中看看当前最低位是0还是1，然后对目标数进行右移，在验证最低位，直至n变为0 。</p><p>然后计算1的距离，需要用一个变量记录上一次的1的位置，然后在循环中若n&amp;1为真，那么就用当前位置减去上一次1的位置获得距离。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binaryGap</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (last != <span class="hljs-number">-1</span>) &#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, i - last);<br>                &#125;<br>                last = i;<br>            &#125;<br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>704.二分查找</title>
    <link href="/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h2><p>难度简单776收藏分享切换为英文接收动态反馈</p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol></li></ul><h2 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h2><p>基础题，</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">if</span>(nums[(left+right)/<span class="hljs-number">2</span>]&gt;target)&#123;<br>                right = (left+right)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[(left+right)/<span class="hljs-number">2</span>]&lt;target)&#123;<br>                left = (left+right)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans = (left+right)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>704.二分查找</title>
    <link href="/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%E5%88%86%E8%A6%81%E6%B1%82%EF%BC%89/"/>
    <url>/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%E5%88%86%E8%A6%81%E6%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h2><p>难度简单</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 5</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 2</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [1,3,5,6], target = 7</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul></li></ul><h2 id="方法一：二分"><a href="#方法一：二分" class="headerlink" title="方法一：二分"></a>方法一：二分</h2><p>跟其他二分不一样的地方在于确定插入位置，而根据二分法，最后查找不到的left变量就代表应该插入的位置（链表有序的前提下）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">if</span>(nums[(left+right)/<span class="hljs-number">2</span>]&gt;target)&#123;<br>                right = (left+right)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[(left+right)/<span class="hljs-number">2</span>]&lt;target)&#123;<br>                left = (left+right)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans = (left+right)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>704.二分查找</title>
    <link href="/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/04/22/%E7%AE%97%E6%B3%95%20-%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h2><p>难度简单</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p></li></ul><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>一个指针指向每一个非零元素，另一个指针从数组开始逐个位置向前移动。</p><p>第二个指针把第一个指针遍历到的非零元素，逐个按顺序写入数组。</p><p>之后把剩下的位置全部填充0即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> nonzero = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>                nonzero++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(t&lt;nonzero)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)&#123;<br>                    nums[t]=nums[i];<br>                    t++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(t&lt;n)&#123;<br>            nums[t] = <span class="hljs-number">0</span>;<br>            t++;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-04-22 每日一题</title>
    <link href="/2022/04/22/2022.4.22%20daily%20problem/"/>
    <url>/2022/04/22/2022.4.22%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="396-旋转函数"><a href="#396-旋转函数" class="headerlink" title="396. 旋转函数"></a><a href="https://leetcode-cn.com/problems/rotate-function/">396. 旋转函数</a></h2><p>难度中等143收藏分享切换为英文接收动态反馈</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p><p>假设 <code>arrk</code> 是数组 <code>nums</code> 顺时针旋转 <code>k</code> 个位置后的数组，我们定义 <code>nums</code> 的 <strong>旋转函数</strong> <code>F</code> 为：</p><ul><li><code>F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]</code></li></ul><p>返回 <em><code>F(0), F(1), ..., F(n-1)</code>中的最大值</em> 。</p><p>生成的测试用例让答案符合 <strong>32 位</strong> 整数。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [4,3,2,6]<br>输出: 26<br>解释:<br>F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 18 </span>= 25<br>F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 6 </span>= 16<br>F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 9 </span>= 23<br>F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 12 </span>+<span class="hljs-number"> 12 </span>= 26<br>所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) =<span class="hljs-number"> 26 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [100]</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul></li></ul><h2 id="方法一：迭代-找规律"><a href="#方法一：迭代-找规律" class="headerlink" title="方法一：迭代+找规律"></a>方法一：迭代+找规律</h2><p>类似以前的等差等比数列求和：</p><p>记数组 nums 的元素之和为 numSum。根据公式，可以得到：</p><p>$$<br>F(0) &#x3D; 0 \times \textit{nums}[0] + 1 \times \textit{nums}[1] + \ldots + (n-1) \times \textit{nums}[n-1]\<br>F(1) &#x3D; 1 \times \textit{nums}[0] + 2 \times \textit{nums}[1] + \ldots + 0 \times \textit{nums}[n-1] &#x3D; F(0) + \textit{numSum} - n \times \textit{nums}[n-1]<br>$$<br>更一般地，当 1≤k&lt;n 时，<br>$$<br>F(k) &#x3D; F(k-1) + \textit{numSum} - n \times \textit{nums}[n-k]<br>$$<br>我们可以不停迭代计算出不同的 F(k)，并求出最大值。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxRotateFunction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> numSum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            f += i * nums[i];<br>        &#125;<br>        <span class="hljs-type">int</span> res = f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            f += numSum - n * nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, f);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-25 每日一题</title>
    <link href="/2022/02/25/2022.2.25%20daily%20problem/"/>
    <url>/2022/02/25/2022.2.25%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="537-复数乘法"><a href="#537-复数乘法" class="headerlink" title="537. 复数乘法"></a><a href="https://leetcode-cn.com/problems/complex-number-multiplication/">537. 复数乘法</a></h4><p>难度中等</p><p><a href="https://baike.baidu.com/item/%E5%A4%8D%E6%95%B0/254365?fr=aladdin">复数</a> 可以用字符串表示，遵循 <code>&quot;**实部**+**虚部**i&quot;</code> 的形式，并满足下述条件：</p><ul><li><code>实部</code> 是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>虚部</code> 也是一个整数，取值范围是 <code>[-100, 100]</code></li><li><code>i2 == -1</code></li></ul><p>给你两个字符串表示的复数 <code>num1</code> 和 <code>num2</code> ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;1+1i&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;1+1i&quot;</span><br>输出：<span class="hljs-string">&quot;0+2i&quot;</span><br>解释：<span class="hljs-comment">(1 + i)</span> * <span class="hljs-comment">(1 + i)</span> = <span class="hljs-number">1</span> + i<span class="hljs-number">2</span> + <span class="hljs-number">2</span> * i = <span class="hljs-number">2</span>i ，你需要将它转换为 <span class="hljs-number">0</span><span class="hljs-number">+2</span>i 的形式。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-string">&quot;1+-1i&quot;</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-string">&quot;1+-1i&quot;</span><br>输出：<span class="hljs-string">&quot;0+-2i&quot;</span><br>解释：<span class="hljs-comment">(1 - i)</span> * <span class="hljs-comment">(1 - i)</span> = <span class="hljs-number">1</span> + i<span class="hljs-number">2</span> - <span class="hljs-number">2</span> * i = <span class="hljs-number">-2</span>i ，你需要将它转换为 <span class="hljs-number">0</span>+<span class="hljs-number">-2</span>i 的形式。 <br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>num1</code> 和 <code>num2</code> 都是有效的复数表示。</li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>只要求熟练运用字符串转数字和数字转字符串。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        string a,b,c,d;<br>        <span class="hljs-type">int</span> a1,a2,a3,a4;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-comment">//步进</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num1[i]!=<span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>                a+=num1[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num1[i]!=<span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>                b+=num1[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        i=<span class="hljs-number">0</span>;<span class="hljs-comment">//复位</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num2[i]!=<span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>                c+=num2[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(num2[i]!=<span class="hljs-string">&#x27;i&#x27;</span>)&#123;<br>                d+=num2[i];<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        a1 = <span class="hljs-built_in">stoi</span>(a);<br>        a2 = <span class="hljs-built_in">stoi</span>(b);<br>        a3 = <span class="hljs-built_in">stoi</span>(c);<br>        a4 = <span class="hljs-built_in">stoi</span>(d);<br>        <span class="hljs-type">int</span> temp1 = a1*a3 - a2*a4;<br>        <span class="hljs-type">int</span> temp2 = a1*a4 + a2*a3;<br>        string ans1 = <span class="hljs-built_in">to_string</span>(temp1);<br>        string ans2 = <span class="hljs-built_in">to_string</span>(temp2);<br>        string ans = ans1+<span class="hljs-string">&#x27;+&#x27;</span>+ans2+<span class="hljs-string">&#x27;i&#x27;</span>;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-24 每日一题</title>
    <link href="/2022/02/24/2022.2.24%20daily%20problem/"/>
    <url>/2022/02/24/2022.2.24%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1706-球会落何处"><a href="#1706-球会落何处" class="headerlink" title="1706. 球会落何处"></a><a href="https://leetcode-cn.com/problems/where-will-the-ball-fall/">1706. 球会落何处</a></h4><p>难度中等</p><p>用一个大小为 <code>m x n</code> 的二维网格 <code>grid</code> 表示一个箱子。你有 <code>n</code> 颗球。箱子的顶部和底部都是开着的。</p><p>箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。</p><ul><li>将球导向右侧的挡板跨过左上角和右下角，在网格中用 <code>1</code> 表示。</li><li>将球导向左侧的挡板跨过右上角和左下角，在网格中用 <code>-1</code> 表示。</li></ul><p>在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。</p><p>返回一个大小为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是球放在顶部的第 <code>i</code> 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/12/26/ball.jpg" alt="img"></strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：grid = [[1,1,1,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>],[1,1,1,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>],[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,1,1],[1,1,1,1,<span class="hljs-string">-1</span>],[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>]]<br>输出：[1,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>]<br>解释：示例如图：<br>b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。<br>b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。<br>b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。<br>b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。<br>b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[-1]]</span><br>输出：[<span class="hljs-number">-1</span>]<br>解释：球被卡在箱子左侧边上。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：grid = [[1,1,1,1,1,1],[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>],[1,1,1,1,1,1],[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>]]<br>输出：[0,1,2,3,4,<span class="hljs-string">-1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>1</code> 或 <code>-1</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>这个小球只要注意方向，然后观察下一层相邻的挡板是否同向，根据方向选择左邻还是右邻。</p><p>最后记得判断左壁和右壁，要先判断k的合法性再用grid检查。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findBall</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>,k=i;<span class="hljs-comment">//j是行k是列</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(j==m)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(k);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(grid[j][k]==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>((k+<span class="hljs-number">1</span>&lt;n)&amp;&amp;(grid[j][k+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>))&#123;<br>                        j++;<br>                        k++;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[j][k]==<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>((k<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&amp;&amp;(grid[j][k<span class="hljs-number">-1</span>]==<span class="hljs-number">-1</span>))&#123;<br>                        j++;<br>                        k--;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-23 每日一题</title>
    <link href="/2022/02/23/2022.2.23%20daily%20problem/"/>
    <url>/2022/02/23/2022.2.23%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="917-仅仅反转字母"><a href="#917-仅仅反转字母" class="headerlink" title="917. 仅仅反转字母"></a><a href="https://leetcode-cn.com/problems/reverse-only-letters/">917. 仅仅反转字母</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code> ，根据下述规则反转字符串：</p><ul><li>所有非英文字母保留在原有位置。</li><li>所有英文字母（小写或大写）位置反转。</li></ul><p>返回反转后的 <code>s</code> <em>。</em></p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab-cd&quot;</span><br>输出：<span class="hljs-string">&quot;dc-ba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a-bC-dEf-ghIj&quot;</span><br>输出：<span class="hljs-string">&quot;j-Ih-gfE-dCba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Test1ng-Leet=code-Q!&quot;</span><br>输出：<span class="hljs-string">&quot;Qedo1ct-eeLg=ntse-T!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅由 ASCII 值在范围 <code>[33, 122]</code> 的字符组成</li><li><code>s</code> 不含 <code>&#39;\&quot;&#39;</code> 或 <code>&#39;\\&#39;</code></li></ul></li></ul><h2 id="方法一：栈"><a href="#方法一：栈" class="headerlink" title="方法一：栈"></a>方法一：栈</h2><p>就是先将字母入栈，利用先进后出在第二次遍历的时候原地填补。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        stack&lt;<span class="hljs-type">char</span>&gt; words;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>((s[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)||(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>))&#123;<br>                words.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>((s[i]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)||(s[i]&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;s[i]&lt;=<span class="hljs-string">&#x27;z&#x27;</span>))<br>            &#123;<br>                s[i] = words.<span class="hljs-built_in">top</span>();<br>                words.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h2><p>其实一开始就是用双指针做的，但是某些测例会越界，一直没找到问题，原来是增减前也要check左右的大小，以后记住。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; !<span class="hljs-built_in">isalpha</span>(s[left])) &#123; <span class="hljs-comment">// 判断左边是否扫描到字母</span><br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//不要忘记这两个left和right的比较</span><br>            <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; !<span class="hljs-built_in">isalpha</span>(s[right])) &#123; <span class="hljs-comment">// 判断右边是否扫描到字母</span><br>                right--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-20 每日一题</title>
    <link href="/2022/02/20/2022.2.20%20daily%20problem/"/>
    <url>/2022/02/20/2022.2.20%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="717-1比特与2比特字符"><a href="#717-1比特与2比特字符" class="headerlink" title="717. 1比特与2比特字符"></a><a href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">717. 1比特与2比特字符</a></h4><p>难度简单</p><p>有两种特殊字符：</p><ul><li>第一种字符可以用一个比特 <code>0</code> 来表示</li><li>第二种字符可以用两个比特(<code>10</code> 或 <code>11</code>)来表示、</li></ul><p>给定一个以 <code>0</code> 结尾的二进制数组 <code>bits</code> ，如果最后一个字符必须是一位字符，则返回 <code>true</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: bits = [1, 0, 0]</span><br><span class="hljs-section">输出: true</span><br><span class="hljs-section">解释: 唯一的编码方式是一个两比特字符和一个一比特字符。</span><br>所以最后一个字符是一比特字符。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: bits = [1, 1, 1, 0]</span><br><span class="hljs-section">输出: false</span><br><span class="hljs-section">解释: 唯一的编码方式是两比特字符和两比特字符。</span><br>所以最后一个字符不是一比特字符。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= bits.length &lt;= 1000</code></li><li><code>bits[i] == 0 or 1</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>按题意，其实就是开头为1的字符长度必为2，开头为0的字符长度必为1。所以只要按这个规律，把字符串切分看看最后一个分片长度就知道true or false了。</p><p>碰到1，步进2；碰到0，步进1。如果最后一个字符是0，那么必定是步进一步，计数器（从0开始）等于字符串长度。不过最后一个字符长度为2，步进2后计数器也等于字符串长度，那么再添加一个变量记录最后前进的步数。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOneBitCharacter</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = bits.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(bits[i]==<span class="hljs-number">1</span>)&#123;<br>                i+=<span class="hljs-number">2</span>;<br>                flag = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                i++;<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==n&amp;&amp;flag==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-18 每日一题</title>
    <link href="/2022/02/18/2022%202.18%20daily%20problem/"/>
    <url>/2022/02/18/2022%202.18%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1791-找出星型图的中心节点"><a href="#1791-找出星型图的中心节点" class="headerlink" title="1791. 找出星型图的中心节点"></a><a href="https://leetcode-cn.com/problems/find-center-of-star-graph/">1791. 找出星型图的中心节点</a></h4><p>难度简单</p><p>有一个无向的 <strong>星型</strong> 图，由 <code>n</code> 个编号从 <code>1</code> 到 <code>n</code> 的节点组成。星型图有一个 <strong>中心</strong> 节点，并且恰有 <code>n - 1</code> 条边将中心节点与其他每个节点连接起来。</p><p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ui, vi]</code> 表示在节点 <code>ui</code> 和 <code>vi</code> 之间存在一条边。请你找出并返回 <code>edges</code> 所表示星型图的中心节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：edges = <span class="hljs-string">[[1,2],[2,3],[4,2]]</span><br>  输出：<span class="hljs-number">2</span><br>解释：如上图所示，节点 <span class="hljs-number">2</span> 与其他每个节点都相连，所以节点 <span class="hljs-number">2</span> 是中心节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：edges = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[5,1]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[1,4]</span>]</span><br>输出：1<br></code></pre></td></tr></table></figure></li></ul><p><strong>提示：</strong></p><ul><li><code>3 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code><ul><li><code>ui != vi</code></li></ul></li><li>题目数据给出的 <code>edges</code> 表示一个有效的星型图</li></ul><h2 id="方法一：哈希"><a href="#方法一：哈希" class="headerlink" title="方法一：哈希"></a>方法一：哈希</h2><p>因为必有解，而星状图中心是所有边的连接点，所以只需要找出在每条边都出现过的元素即可。</p><p>于是，计数，然后返回。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCenter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            hash[edges[i][<span class="hljs-number">0</span>]]++;<br>            hash[edges[i][<span class="hljs-number">1</span>]]++;<br>            <span class="hljs-keyword">if</span>(hash[edges[i][<span class="hljs-number">0</span>]]==n)&#123;<br>                <span class="hljs-keyword">return</span> edges[i][<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(hash[edges[i][<span class="hljs-number">1</span>]]==n)&#123;<br>                <span class="hljs-keyword">return</span> edges[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-15 每日一题</title>
    <link href="/2022/02/17/2022%202.15%20daily%20problem/"/>
    <url>/2022/02/17/2022%202.15%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1380-矩阵中的幸运数"><a href="#1380-矩阵中的幸运数" class="headerlink" title="1380. 矩阵中的幸运数"></a><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/">1380. 矩阵中的幸运数</a></h4><p>难度简单</p><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的数字 <strong>各不相同</strong> 。请你按 <strong>任意</strong> 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><ul><li>在同一行的所有元素中最小</li><li>在同一列的所有元素中最大</li></ul><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[3,7,8]</span>,<span class="hljs-comment">[9,11,13]</span>,<span class="hljs-comment">[15,16,17]</span>]</span><br>输出：<span class="hljs-comment">[15]</span><br>解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[1,10,4,2]</span>,<span class="hljs-comment">[9,3,8,7]</span>,<span class="hljs-comment">[15,16,17,12]</span>]</span><br>输出：<span class="hljs-comment">[12]</span><br>解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[7,8],[1,2]]</span><br>输出：[<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= n, m &lt;= 50</code></li><li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li><li>矩阵中的所有元素都是不同的</li></ul></li></ul><h2 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h2><p>三重循环（对每个元素进行行列遍历）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">luckyNumbers</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">bool</span> isMin = <span class="hljs-literal">true</span>, isMax = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (matrix[i][k] &lt; matrix[i][j]) &#123;<br>                        isMin = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!isMin) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; m; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (matrix[k][j] &gt; matrix[i][j]) &#123;<br>                        isMax = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (isMax) &#123;<br>                    ret.<span class="hljs-built_in">push_back</span>(matrix[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用DP的答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n)));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step = <span class="hljs-number">0</span>; step &lt;= k; step++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">0</span>) &#123;<br>                        dp[step][i][j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; dir : dirs) &#123;<br>                            <span class="hljs-type">int</span> ni = i + dir[<span class="hljs-number">0</span>], nj = j + dir[<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span> (ni &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; n) &#123;<br>                                dp[step][i][j] += dp[step - <span class="hljs-number">1</span>][ni][nj] / <span class="hljs-number">8</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][row][column];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-16 每日一题</title>
    <link href="/2022/02/17/2022%202.16%20daily%20problem/"/>
    <url>/2022/02/17/2022%202.16%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1719-重构一棵树的方案数"><a href="#1719-重构一棵树的方案数" class="headerlink" title="1719. 重构一棵树的方案数"></a><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/">1719. 重构一棵树的方案数</a></h4><p>难度困难</p><p>给你一个数组 <code>pairs</code> ，其中 <code>pairs[i] = [xi, yi]</code> ，并且满足：</p><ul><li><code>pairs</code> 中没有重复元素</li><li><code>xi &lt; yi</code></li></ul><p>令 <code>ways</code> 为满足下面条件的有根树的方案数：</p><ul><li>树所包含的所有节点值都在 <code>pairs</code> 中。</li><li>一个数对 <code>[xi, yi]</code> 出现在 <code>pairs</code> 中 <strong>当且仅当</strong> <code>xi</code> 是 <code>yi</code> 的祖先或者 <code>yi</code> 是 <code>xi</code> 的祖先。</li><li><strong>注意：</strong>构造出来的树不一定是二叉树。</li></ul><p>两棵树被视为不同的方案当存在至少一个节点在两棵树中有不同的父节点。</p><p>请你返回：</p><ul><li>如果 <code>ways == 0</code> ，返回 <code>0</code> 。</li><li>如果 <code>ways == 1</code> ，返回 <code>1</code> 。</li><li>如果 <code>ways &gt; 1</code> ，返回 <code>2</code> 。</li></ul><p>一棵 <strong>有根树</strong> 指的是只有一个根节点的树，所有边都是从根往外的方向。</p><p>我们称从根到一个节点路径上的任意一个节点（除去节点本身）都是该节点的 <strong>祖先</strong> 。根节点没有祖先。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/trees2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1,2],[2,3]]</span><br>输出：<span class="hljs-number">1</span><br>解释：如上图所示，有且只有一个符合规定的有根树。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/09/tree.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1,2],[2,3],[1,3]]</span><br>输出：<span class="hljs-number">2</span><br>解释：有多个符合规定的有根树，其中三个如上图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：<span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1,2],[2,3],[2,4],[1,5]]</span><br>输出：<span class="hljs-number">0</span><br>解释：没有符合规定的有根树。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= pairs.length &lt;= 105</code></li><li><code>1 &lt;= xi &lt; yi &lt;= 500</code></li><li><code>pairs</code> 中的元素互不相同。</li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>困难 开摆</p><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/zhong-gou-yi-ke-shu-de-fang-an-shu-by-le-36e1/">https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/solution/zhong-gou-yi-ke-shu-de-fang-an-shu-by-le-36e1/</a></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkWays</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, unordered_set&lt;<span class="hljs-type">int</span>&gt;&gt; adj;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p : pairs) &#123;<br>            adj[p[<span class="hljs-number">0</span>]].<span class="hljs-built_in">emplace</span>(p[<span class="hljs-number">1</span>]);<br>            adj[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">emplace</span>(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">/* 检测是否存在根节点*/</span><br>        <span class="hljs-type">int</span> root = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[node, neighbours] : adj) &#123;<br>            <span class="hljs-keyword">if</span> (neighbours.<span class="hljs-built_in">size</span>() == adj.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                root = node;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[node, neighbours] : adj) &#123;<br>            <span class="hljs-keyword">if</span> (node == root) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> currDegree = neighbours.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> parent = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> parentDegree = INT_MAX;<br><br>            <span class="hljs-comment">/* 根据 degree 的大小找到 node 的父节点 parent */</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;neighbour : neighbours) &#123;<br>                <span class="hljs-keyword">if</span> (adj[neighbour].<span class="hljs-built_in">size</span>() &lt; parentDegree &amp;&amp; adj[neighbour].<span class="hljs-built_in">size</span>() &gt;= currDegree) &#123;<br>                    parent = neighbour;<br>                    parentDegree = adj[neighbour].<span class="hljs-built_in">size</span>();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (parent == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 检测 neighbours 是否是 adj[parent] 的子集 */</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;neighbour : neighbours) &#123;<br>                <span class="hljs-keyword">if</span> (neighbour == parent) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (!adj[parent].<span class="hljs-built_in">count</span>(neighbour)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (parentDegree == currDegree) &#123;<br>                res = <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用DP的答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n)));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step = <span class="hljs-number">0</span>; step &lt;= k; step++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">0</span>) &#123;<br>                        dp[step][i][j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; dir : dirs) &#123;<br>                            <span class="hljs-type">int</span> ni = i + dir[<span class="hljs-number">0</span>], nj = j + dir[<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span> (ni &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; n) &#123;<br>                                dp[step][i][j] += dp[step - <span class="hljs-number">1</span>][ni][nj] / <span class="hljs-number">8</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][row][column];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-17 每日一题</title>
    <link href="/2022/02/17/2022%202.17%20daily%20problem/"/>
    <url>/2022/02/17/2022%202.17%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="688-骑士在棋盘上的概率"><a href="#688-骑士在棋盘上的概率" class="headerlink" title="688. 骑士在棋盘上的概率"></a><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/">688. 骑士在棋盘上的概率</a></h4><p>难度中等</p><p>在一个 <code>n x n</code> 的国际象棋棋盘上，一个骑士从单元格 <code>(row, column)</code> 开始，并尝试进行 <code>k</code> 次移动。行和列是 <strong>从 0 开始</strong> 的，所以左上单元格是 <code>(0,0)</code> ，右下单元格是 <code>(n - 1, n - 1)</code> 。</p><p>象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/knight.png" alt="img"></p><p>每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。</p><p>骑士继续移动，直到它走了 <code>k</code> 步或离开了棋盘。</p><p>返回 <em>骑士在棋盘停止移动后仍留在棋盘上的概率</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>, k = <span class="hljs-number">2</span>, <span class="hljs-built_in">row</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">column</span> = <span class="hljs-number">0</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-number">0.0625</span><br>解释<span class="hljs-symbol">:</span> 有两步(到(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)，(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))可以让骑士留在棋盘上。<br>在每一个位置上，也有两种移动可以让骑士留在棋盘上。<br>骑士留在棋盘上的总概率是<span class="hljs-number">0.0625</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>, <span class="hljs-built_in">row</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">column</span> = <span class="hljs-number">0</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-number">1.00000</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 25</code></li><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= row, column &lt;= n</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>这种方法是按照：一出棋盘就停的思路做的，但他答案显然是全可能性，就是出了棋盘继续走。</p><p>他文字上面有歧义，搞了那么久，如果是全走法合理只需要记录点坐标就行了。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; ffinal;<span class="hljs-comment">//有效可能性</span><br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; temp;<br>        <span class="hljs-type">int</span> totalk = k;<br>        temp.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(row,column));<br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> ss = temp.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(ss&gt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">int</span> a = temp.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> b = temp.<span class="hljs-built_in">front</span>().second;<br>                temp.<span class="hljs-built_in">pop</span>();<br>                vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; direction;<br>                direction.<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-type">int</span> a1 = a+<span class="hljs-number">1</span>,a_1 = a<span class="hljs-number">-1</span>,a2 = a+<span class="hljs-number">2</span>,a_2 = a<span class="hljs-number">-2</span>,b1 = b+<span class="hljs-number">1</span>,b_1 = b<span class="hljs-number">-1</span>,b2 = b+<span class="hljs-number">2</span>,b_2 = b<span class="hljs-number">-2</span>;<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a1,b_2));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a1,b2));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a_2,b1));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a_2,b_1));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a_1,b2));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a_1,b_2));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a2,b1));<br>                direction.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a2,b_1));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;direction.<span class="hljs-built_in">size</span>();i++)&#123;<br>                    <span class="hljs-keyword">if</span>(direction[i].first&lt;<span class="hljs-number">0</span>||direction[i].first&gt;=n||direction[i].second&lt;<span class="hljs-number">0</span>||direction[i].second&gt;=n)&#123;<br>                        <span class="hljs-comment">//ffinal.push_back(direction[i]);</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>                            ffinal.<span class="hljs-built_in">push_back</span>(direction[i]);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            temp.<span class="hljs-built_in">push</span>(direction[i]);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                ss--;<br>            &#125;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(totalk==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">double</span> possible = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;ffinal.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>((ffinal[i].first&gt;=<span class="hljs-number">0</span>&amp;&amp;ffinal[i].first&lt;n)&amp;&amp;(ffinal[i].second&gt;=<span class="hljs-number">0</span>&amp;&amp;ffinal[i].second&lt;n))&#123;<br>                possible++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">double</span> ans = possible/<span class="hljs-built_in">pow</span>(<span class="hljs-number">8</span>,totalk);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用DP的答案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">knightProbability</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> row, <span class="hljs-type">int</span> column)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(k + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">double</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(n)));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step = <span class="hljs-number">0</span>; step &lt;= k; step++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">0</span>) &#123;<br>                        dp[step][i][j] = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; dir : dirs) &#123;<br>                            <span class="hljs-type">int</span> ni = i + dir[<span class="hljs-number">0</span>], nj = j + dir[<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span> (ni &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= <span class="hljs-number">0</span> &amp;&amp; nj &lt; n) &#123;<br>                                dp[step][i][j] += dp[step - <span class="hljs-number">1</span>][ni][nj] / <span class="hljs-number">8</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k][row][column];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-14 每日一题</title>
    <link href="/2022/02/16/2022%202.14%20daily%20problem/"/>
    <url>/2022/02/16/2022%202.14%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540. 有序数组中的单一元素"></a><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h4><p>难度中等</p><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p><p>请你找出并返回只出现一次的那个数。</p><p>你设计的解决方案必须满足 <code>O(log n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,1,2,3</span>,<span class="hljs-number">3,4,4,8</span>,<span class="hljs-number">8</span>]<br>输出: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums =  [3,3,7,7,10,11,11]</span><br><span class="hljs-section">输出: 10</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul></li></ul><h2 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h2><p>因为题目是有序，并且必有解，而那个数只出现一次，意味着他跟相邻两个元素都不一样。</p><p>只需要care一下首尾即可。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=nums[i<span class="hljs-number">-1</span>]&amp;&amp;nums[i+<span class="hljs-number">1</span>]!=nums[i])&#123;<br>                ans = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[n<span class="hljs-number">-1</span>]!=nums[n<span class="hljs-number">-2</span>])&#123;<br>                ans = nums[n<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-10 每日一题</title>
    <link href="/2022/02/10/2022%202.10%20daily%20problem/"/>
    <url>/2022/02/10/2022%202.10%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447. 最简分数"></a><a href="https://leetcode-cn.com/problems/simplified-fractions/">1447. 最简分数</a></h4><p>难度中等</p><p>给你一个整数 <code>n</code> ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 <code>n</code> 的 <strong>最简</strong> 分数 。分数可以以 <strong>任意</strong> 顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：[<span class="hljs-string">&quot;1/2&quot;</span>]<br>解释：<span class="hljs-string">&quot;1/2&quot;</span> 是唯一一个分母小于等于 <span class="hljs-number">2</span> 的最简分数。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;1/2&quot;</span>,<span class="hljs-string">&quot;1/3&quot;</span>,<span class="hljs-string">&quot;2/3&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">4</span><br>输出：[<span class="hljs-string">&quot;1/2&quot;</span>,<span class="hljs-string">&quot;1/3&quot;</span>,<span class="hljs-string">&quot;1/4&quot;</span>,<span class="hljs-string">&quot;2/3&quot;</span>,<span class="hljs-string">&quot;3/4&quot;</span>]<br>解释：<span class="hljs-string">&quot;2/4&quot;</span> 不是最简分数，因为它可以化简为 <span class="hljs-string">&quot;1/2&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul></li></ul><h2 id="方法一：数学法"><a href="#方法一：数学法" class="headerlink" title="方法一：数学法"></a>方法一：数学法</h2><p>超捞解法，完全就是枚举。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;b)&#123;<br>            <span class="hljs-type">int</span> temp = b;<br>            b = a;<br>            a = temp;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-type">int</span> temp = a%b;<br>            a = b;<br>            b = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">simplifiedFractions</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>)&#123;<br>                    string temp = <span class="hljs-string">&quot;&quot;</span>;<br>                    stringstream ss;<br>                    ss&lt;&lt;j;<br>                    string fenzi = ss.<span class="hljs-built_in">str</span>();<br>                    stringstream xx;<br>                    xx&lt;&lt;i;<br>                    string fenmu = xx.<span class="hljs-built_in">str</span>();<br>                    temp += fenzi;<br>                    temp += <span class="hljs-string">&#x27;/&#x27;</span>;<br>                    temp += fenmu;<br>                    ans.<span class="hljs-built_in">push_back</span>(temp);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gcd</span>(i,j)==<span class="hljs-number">1</span>)&#123;<br>                        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>                        stringstream ss;<br>                        ss&lt;&lt;j;<br>                        string fenzi = ss.<span class="hljs-built_in">str</span>();<br>                        stringstream xx;<br>                        xx&lt;&lt;i;<br>                        string fenmu = xx.<span class="hljs-built_in">str</span>();<br>                        temp += fenzi;<br>                        temp += <span class="hljs-string">&#x27;/&#x27;</span>;<br>                        temp += fenmu;<br>                        ans.<span class="hljs-built_in">push_back</span>(temp);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后我想看看答案有什么高见，但实际他也是暴力。。。</p><p>不过学到了新函数。。。__gcd和to_string</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">simplifiedFractions</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> denominator = <span class="hljs-number">2</span>; denominator &lt;= n; ++denominator) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> numerator = <span class="hljs-number">1</span>; numerator &lt; denominator; ++numerator) &#123;<br>                <span class="hljs-keyword">if</span> (__gcd(numerator, denominator) == <span class="hljs-number">1</span>) &#123;<br>                    ans.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">to_string</span>(numerator) + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">to_string</span>(denominator));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-04 每日一题</title>
    <link href="/2022/02/09/2022%202.4%20daily%20problem/"/>
    <url>/2022/02/09/2022%202.4%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1725-可以形成最大正方形的矩形数目"><a href="#1725-可以形成最大正方形的矩形数目" class="headerlink" title="1725. 可以形成最大正方形的矩形数目"></a><a href="https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/">1725. 可以形成最大正方形的矩形数目</a></h4><p>难度简单</p><p>给你一个数组 <code>rectangles</code> ，其中 <code>rectangles[i] = [li, wi]</code> 表示第 <code>i</code> 个矩形的长度为 <code>li</code> 、宽度为 <code>wi</code> 。</p><p>如果存在 <code>k</code> 同时满足 <code>k &lt;= li</code> 和 <code>k &lt;= wi</code> ，就可以将第 <code>i</code> 个矩形切成边长为 <code>k</code> 的正方形。例如，矩形 <code>[4,6]</code> 可以切成边长最大为 <code>4</code> 的正方形。</p><p>设 <code>maxLen</code> 为可以从矩形数组 <code>rectangles</code> 切分得到的 <strong>最大正方形</strong> 的边长。</p><p>请你统计有多少个矩形能够切出边长为 <code>maxLen</code> 的正方形，并返回矩形 <strong>数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rectangles = <span class="hljs-comment">[<span class="hljs-comment">[5,8]</span>,<span class="hljs-comment">[3,9]</span>,<span class="hljs-comment">[5,12]</span>,<span class="hljs-comment">[16,5]</span>]</span><br>输出：3<br>解释：能从每个矩形中切出的最大正方形边长分别是 <span class="hljs-comment">[5,3,5,5]</span> 。<br>最大正方形的边长为 5 ，可以由 3 个矩形切分得到。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：rectangles = <span class="hljs-comment">[<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[3,7]</span>,<span class="hljs-comment">[4,3]</span>,<span class="hljs-comment">[3,7]</span>]</span><br>输出：3<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rectangles.length &lt;= 1000</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= li, wi &lt;= 109</code></li><li><code>li != wi</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>先找最大值，然后用最大值去测试每个矩形。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countGoodRectangles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rectangles.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>])&gt;maxlen)&#123;<br>                maxlen = <span class="hljs-built_in">min</span>(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rectangles.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(rectangles[i][<span class="hljs-number">0</span>],rectangles[i][<span class="hljs-number">1</span>])&gt;=maxlen)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-06 每日一题</title>
    <link href="/2022/02/09/2022%202.6%20daily%20problem/"/>
    <url>/2022/02/09/2022%202.6%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1748-唯一元素的和"><a href="#1748-唯一元素的和" class="headerlink" title="1748. 唯一元素的和"></a><a href="https://leetcode-cn.com/problems/sum-of-unique-elements/">1748. 唯一元素的和</a></h4><p>难度简单</p><p>给你一个整数数组 <code>nums</code> 。数组中唯一元素是那些只出现 <strong>恰好一次</strong> 的元素。</p><p>请你返回 <code>nums</code> 中唯一元素的 <strong>和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,2]</span><br>输出：4<br>解释：唯一元素为 <span class="hljs-comment">[1,3]</span> ，和为 4 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,1,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：没有唯一元素，和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">15</span><br>解释：唯一元素为 <span class="hljs-string">[1,2,3,4,5]</span> ，和为 <span class="hljs-number">15</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></li></ul><h2 id="方法一：哈希"><a href="#方法一：哈希" class="headerlink" title="方法一：哈希"></a>方法一：哈希</h2><p>先记录，然后求和。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfUnique</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            hash[nums[i]]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = hash.<span class="hljs-built_in">begin</span>();i!=hash.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second==<span class="hljs-number">1</span>)&#123;<br>                ans+= i-&gt;first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-02-09 每日一题</title>
    <link href="/2022/02/09/2022%202.9%20daily%20problem/"/>
    <url>/2022/02/09/2022%202.9%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="2006-差的绝对值为-K-的数对数目"><a href="#2006-差的绝对值为-K-的数对数目" class="headerlink" title="2006. 差的绝对值为 K 的数对数目"></a><a href="https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/">2006. 差的绝对值为 K 的数对数目</a></h4><p>难度简单</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对 <code>(i, j)</code> 的数目，满足 <code>i &lt; j</code> 且 <code>|nums[i] - nums[j]| == k</code> 。</p><p><code>|x|</code> 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,2,1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">4</span><br>解释：差的绝对值为 <span class="hljs-number">1</span> 的数对为：<br>- [<span class="hljs-number">1,2,2,1</span>]<br>- [<span class="hljs-number">1,2,2,1</span>]<br>- [<span class="hljs-number">1,2,2,1</span>]<br>- [<span class="hljs-number">1,2,2,1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,3], k = 3</span><br><span class="hljs-string">输出：0</span><br><span class="hljs-string">解释：没有任何数对差的绝对值为 3 。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,2,1,5,4]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：差的绝对值为 <span class="hljs-number">2</span> 的数对为：<br>- <span class="hljs-string">[3,2,1,5,4]</span><br>- <span class="hljs-string">[3,2,1,5,4]</span><br>- <span class="hljs-string">[3,2,1,5,4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 99</code></li></ul></li></ul><h2 id="方法一：双重循环"><a href="#方法一：双重循环" class="headerlink" title="方法一：双重循环"></a>方法一：双重循环</h2><p>简单，类似冒泡。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countKDifference</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(nums[i]-nums[j])==k)&#123;<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-22 每日一题</title>
    <link href="/2022/01/22/2022%201.22%20daily%20problem/"/>
    <url>/2022/01/22/2022%201.22%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1332-删除回文子序列"><a href="#1332-删除回文子序列" class="headerlink" title="1332. 删除回文子序列"></a><a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code>，它仅由字母 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。</p><p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p><p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p><p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ababa&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：字符串本身就是回文序列，只需要删除一次。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;abb&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;abb&quot;</span> -&gt; <span class="hljs-string">&quot;bb&quot;</span> -&gt; <span class="hljs-string">&quot;&quot;</span>. <br>先删除回文子序列 <span class="hljs-string">&quot;a&quot;</span>，然后再删除 <span class="hljs-string">&quot;bb&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：s = <span class="hljs-string">&quot;baabb&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-string">&quot;baabb&quot;</span> -&gt; <span class="hljs-string">&quot;b&quot;</span> -&gt; <span class="hljs-string">&quot;&quot;</span>. <br>先删除回文子序列 <span class="hljs-string">&quot;baab&quot;</span>，然后再删除 <span class="hljs-string">&quot;b&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅包含字母 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code></li></ul></li></ul><h2 id="方法一：直接判断"><a href="#方法一：直接判断" class="headerlink" title="方法一：直接判断"></a>方法一：直接判断</h2><p>由于字符串本身只含有字母 ‘a’ 和 ‘b’ 两种字符，题目要求每次删除回文子序列（不一定连续）而使得字符串最终为空。题目中只包含两种不同的字符，由于相同的字符组成的子序列一定是回文子序列，因此最多只需要删除 2 次即可删除所有的字符。删除判断如下：</p><p>如果该字符串本身为回文串，此时只需删除 1 次即可，删除次数为 1。<br>如果该字符串本身不是回文串，此时只需删除 2 次即可，比如可以先删除所有的 ‘a’，再删除所有的 ‘b’，删除次数为 2。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removePalindromeSub</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != s[n - <span class="hljs-number">1</span> - i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-19 每日一题</title>
    <link href="/2022/01/19/2022%201.19%20daily%20problem/"/>
    <url>/2022/01/19/2022%201.19%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">219. 存在重复元素 II</a></h4><p>难度简单</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，判断数组中是否存在两个 <strong>不同的索引</strong> <code>i</code> 和 <code>j</code> ，满足 <code>nums[i] == nums[j]</code> 且 <code>abs(i - j) &lt;= k</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul></li></ul><h2 id="方法一：哈希链表"><a href="#方法一：哈希链表" class="headerlink" title="方法一：哈希链表"></a>方法一：哈希链表</h2><p>遍历数组，把相同数字的下标加入对应的链表里面，最后遍历每一个数字对应的链表检查是否存在符合题意的数字就可以，就是运行效率比较低。</p><p>（但如果直接用双重循环会超时，于是就用哈希表法了）</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            hash[nums[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;hash[nums[i]].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(hash[nums[i]][j+<span class="hljs-number">1</span>]-hash[nums[i]][j]&lt;=k)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-18 每日一题</title>
    <link href="/2022/01/18/2022%201.18%20daily%20problem/"/>
    <url>/2022/01/18/2022%201.18%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="539-最小时间差"><a href="#539-最小时间差" class="headerlink" title="539. 最小时间差"></a><a href="https://leetcode-cn.com/problems/minimum-time-difference/">539. 最小时间差</a></h4><p>难度中等</p><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：timePoints = [<span class="hljs-string">&quot;23:59&quot;</span>,<span class="hljs-string">&quot;00:00&quot;</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：timePoints = [<span class="hljs-string">&quot;00:00&quot;</span>,<span class="hljs-string">&quot;23:59&quot;</span>,<span class="hljs-string">&quot;00:00&quot;</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li><li><code>timePoints[i]</code> 格式为 <strong>“HH:MM”</strong></li></ul></li></ul><h2 id="方法一：时钟转两圈"><a href="#方法一：时钟转两圈" class="headerlink" title="方法一：时钟转两圈"></a>方法一：时钟转两圈</h2><p>看到题目第一时间想到的方法是把给出的时间全部转换成分钟，这个方法肯定是没问题的，给出的数据只有2w个，不会超时或者爆内存。</p><p>但是要注意的是，如果直接以24小时的时间换算分钟会出现问题，那就是凌晨时分跟晚上的时间跟接近，但是在换算分钟的时候前面的时间数值小，后面的时间数值大，遍历比较的话会导致无法比较晚上和凌晨。</p><p>所以采用48小时计数法，每一个时间除了算出24小时制的分钟数值，多算一个对应的24~48小时分钟数值，这样子就可以在一个循环里面比较出结果。</p><p>于是代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinDifference</span><span class="hljs-params">(vector&lt;string&gt;&amp; timePoints)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; minutes;<br>        <span class="hljs-type">int</span> n = timePoints.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> shi = <span class="hljs-number">10</span>*(timePoints[i][<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)+(timePoints[i][<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> fen = <span class="hljs-number">10</span>*(timePoints[i][<span class="hljs-number">3</span>]-<span class="hljs-string">&#x27;0&#x27;</span>)+(timePoints[i][<span class="hljs-number">4</span>]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> fenzhong = shi*<span class="hljs-number">60</span>+fen;<br>            minutes.<span class="hljs-built_in">push_back</span>(fenzhong);<br>            minutes.<span class="hljs-built_in">push_back</span>((shi+<span class="hljs-number">24</span>)*<span class="hljs-number">60</span>+fen);<span class="hljs-comment">//多加一个时钟循环</span><br>        &#125;<br>        <span class="hljs-built_in">sort</span>(minutes.<span class="hljs-built_in">begin</span>(),minutes.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> least = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;minutes.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>((minutes[i]-minutes[i<span class="hljs-number">-1</span>])&lt;least)&#123;<br>                least = minutes[i]-minutes[i<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> least;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-17 每日一题</title>
    <link href="/2022/01/17/2022%201.17%20daily%20problem/"/>
    <url>/2022/01/17/2022%201.17%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1220-统计元音字母序列的数目"><a href="#1220-统计元音字母序列的数目" class="headerlink" title="1220. 统计元音字母序列的数目"></a><a href="https://leetcode-cn.com/problems/count-vowels-permutation/">1220. 统计元音字母序列的数目</a></h4><p>难度困难</p><p>给你一个整数 <code>n</code>，请你帮忙统计一下我们可以按下述规则形成多少个长度为 <code>n</code> 的字符串：</p><ul><li>字符串中的每个字符都应当是小写元音字母（<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>）</li><li>每个元音 <code>&#39;a&#39;</code> 后面都只能跟着 <code>&#39;e&#39;</code></li><li>每个元音 <code>&#39;e&#39;</code> 后面只能跟着 <code>&#39;a&#39;</code> 或者是 <code>&#39;i&#39;</code></li><li>每个元音 <code>&#39;i&#39;</code> 后面 <strong>不能</strong> 再跟着另一个 <code>&#39;i&#39;</code></li><li>每个元音 <code>&#39;o&#39;</code> 后面只能跟着 <code>&#39;i&#39;</code> 或者是 <code>&#39;u&#39;</code></li><li>每个元音 <code>&#39;u&#39;</code> 后面只能跟着 <code>&#39;a&#39;</code></li></ul><p>由于答案可能会很大，所以请你返回 模 <code>10^9 + 7</code> 之后的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">5</span><br>解释：所有可能的字符串分别是：<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;i&quot;</span> , <span class="hljs-string">&quot;o&quot;</span> 和 <span class="hljs-string">&quot;u&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">10</span><br>解释：所有可能的字符串分别是：<span class="hljs-string">&quot;ae&quot;</span>, <span class="hljs-string">&quot;ea&quot;</span>, <span class="hljs-string">&quot;ei&quot;</span>, <span class="hljs-string">&quot;ia&quot;</span>, <span class="hljs-string">&quot;ie&quot;</span>, <span class="hljs-string">&quot;io&quot;</span>, <span class="hljs-string">&quot;iu&quot;</span>, <span class="hljs-string">&quot;oi&quot;</span>, <span class="hljs-string">&quot;ou&quot;</span> 和 <span class="hljs-string">&quot;ua&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">68</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>题目给我一种要用动态规划的感觉，因为每个字母都有约束紧接着的一个字母，明显的是前一个状态推导后一个动态。</p><p>简要分析一下可以发现，假如我知道某一个位置，’a’的出现次数是多少，那么就可以推出下一个位置的’e’的出现次数，用这个思路可以有状态转移方程：</p><p>yuanyin[‘a’] &#x3D; (e+i+u);<br>yuanyin[‘e’] &#x3D; (a+i);<br>yuanyin[‘i’] &#x3D; (e+o);<br>yuanyin[‘o’] &#x3D; i;<br>yuanyin[‘u’] &#x3D; (i+o);</p><p>yuanyin[‘x’]代表当前位置上x的可能次数，y代表上一个位置的字符出现次数。很显然，是马尔科夫链，当前状态只与前一个状态有关。用草稿纸写一下再可以发现，只要把最后位置的所有字母出现次数相加即是题目所要的结果。</p><p>于是代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countVowelPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> MAX = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; yuanyin;<br>        yuanyin[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">1</span>;<br>        yuanyin[<span class="hljs-string">&#x27;e&#x27;</span>] = <span class="hljs-number">1</span>;<br>        yuanyin[<span class="hljs-string">&#x27;i&#x27;</span>] = <span class="hljs-number">1</span>;<br>        yuanyin[<span class="hljs-string">&#x27;o&#x27;</span>] = <span class="hljs-number">1</span>;<br>        yuanyin[<span class="hljs-string">&#x27;u&#x27;</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> a = yuanyin[<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> e = yuanyin[<span class="hljs-string">&#x27;e&#x27;</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> i = yuanyin[<span class="hljs-string">&#x27;i&#x27;</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> o = yuanyin[<span class="hljs-string">&#x27;o&#x27;</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u = yuanyin[<span class="hljs-string">&#x27;u&#x27;</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt; n;k++)&#123;<span class="hljs-comment">//这里不能用i！！！！</span><br>            a = yuanyin[<span class="hljs-string">&#x27;a&#x27;</span>];<br>            e = yuanyin[<span class="hljs-string">&#x27;e&#x27;</span>];<br>            i = yuanyin[<span class="hljs-string">&#x27;i&#x27;</span>];<br>            o = yuanyin[<span class="hljs-string">&#x27;o&#x27;</span>];<br>            u = yuanyin[<span class="hljs-string">&#x27;u&#x27;</span>];<br>            yuanyin[<span class="hljs-string">&#x27;a&#x27;</span>] = (e+i+u)%MAX;<br>            yuanyin[<span class="hljs-string">&#x27;e&#x27;</span>] = (a+i)%MAX;<br>            yuanyin[<span class="hljs-string">&#x27;i&#x27;</span>] = (e+o)%MAX;<br>            yuanyin[<span class="hljs-string">&#x27;o&#x27;</span>] = i%MAX;<br>            yuanyin[<span class="hljs-string">&#x27;u&#x27;</span>] = (i+o)%MAX;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans =(yuanyin[<span class="hljs-string">&#x27;a&#x27;</span>]+yuanyin[<span class="hljs-string">&#x27;e&#x27;</span>]+yuanyin[<span class="hljs-string">&#x27;i&#x27;</span>]+yuanyin[<span class="hljs-string">&#x27;o&#x27;</span>]+yuanyin[<span class="hljs-string">&#x27;u&#x27;</span>])%MAX;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>贴一下题解更简洁的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countVowelPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; <span class="hljs-title">ndp</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-comment">/* a前面可以为e,u,i */</span><br>            ndp[<span class="hljs-number">0</span>] = (dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">4</span>]) % mod;<br>            <span class="hljs-comment">/* e前面可以为a,i */</span><br>            ndp[<span class="hljs-number">1</span>] = (dp[<span class="hljs-number">0</span>] + dp[<span class="hljs-number">2</span>]) % mod;<br>            <span class="hljs-comment">/* i前面可以为e,o */</span><br>            ndp[<span class="hljs-number">2</span>] = (dp[<span class="hljs-number">1</span>] + dp[<span class="hljs-number">3</span>]) % mod;<br>            <span class="hljs-comment">/* o前面可以为i */</span><br>            ndp[<span class="hljs-number">3</span>] = dp[<span class="hljs-number">2</span>];<br>            <span class="hljs-comment">/* u前面可以为i,o */</span><br>            ndp[<span class="hljs-number">4</span>] = (dp[<span class="hljs-number">2</span>] + dp[<span class="hljs-number">3</span>]) % mod;<br>            dp = ndp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) % mod;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-16 每日一题</title>
    <link href="/2022/01/16/2022%201.16%20daily%20problem/"/>
    <url>/2022/01/16/2022%201.16%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="382-链表随机节点"><a href="#382-链表随机节点" class="headerlink" title="382. 链表随机节点"></a><a href="https://leetcode-cn.com/problems/linked-list-random-node/">382. 链表随机节点</a></h4><p>难度中等</p><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 <strong>被选中的概率一样</strong> 。</p><p>实现 <code>Solution</code> 类：</p><ul><li><code>Solution(ListNode head)</code> 使用整数数组初始化对象。</li><li><code>int getRandom()</code> 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li></ul><p><strong>示例：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入<br>[<span class="hljs-string">&quot;Solution&quot;</span>, <span class="hljs-string">&quot;getRandom&quot;</span>, <span class="hljs-string">&quot;getRandom&quot;</span>, <span class="hljs-string">&quot;getRandom&quot;</span>, <span class="hljs-string">&quot;getRandom&quot;</span>, <span class="hljs-string">&quot;getRandom&quot;</span>]<br>[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [], [], [], [], []]<br>输出<br>[null, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>解释<br>Solution solution = new Solution([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>solution.getRandom(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">1</span><br>solution.getRandom(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">3</span><br>solution.getRandom(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">2</span><br>solution.getRandom(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">2</span><br>solution.getRandom(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> getRandom() 方法应随机返回 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span>中的一个，每个元素被返回的概率相等。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中的节点数在范围 <code>[1, 104]</code> 内</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li>至多调用 <code>getRandom</code> 方法 <code>104</code> 次</li></ul><p><strong>进阶：</strong></p><ul><li>如果链表非常大且长度未知，该怎么处理？</li><li>你能否在不使用额外空间的情况下解决此问题？</li></ul></li></ul><h2 id="方法一：水塘抽样"><a href="#方法一：水塘抽样" class="headerlink" title="方法一：水塘抽样"></a>方法一：水塘抽样</h2><p>实话说我一直不知道这种题目是否允许调用rand函数的，如果可以的话，那似乎是没什么技术含量，开一个vector数组储存链表的元素，然后rand一下再对数组长度取模返回就可以了。</p><p>鉴于进阶说是否能实现空间O(1)，确实也没思路，当来学习一下水塘抽样好了。</p><p><a href="https://leetcode-cn.com/problems/linked-list-random-node/solution/lian-biao-sui-ji-jie-dian-by-leetcode-so-x6it/">https://leetcode-cn.com/problems/linked-list-random-node/solution/lian-biao-sui-ji-jie-dian-by-leetcode-so-x6it/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ListNode *head;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(ListNode *head) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;head = head;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> node = head; node; node = node-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 1/i 的概率选中（替换为答案）</span><br>                ans = node-&gt;val;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(head);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;getRandom();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-13 每日一题</title>
    <link href="/2022/01/15/2022%201.13%20daily%20problem/"/>
    <url>/2022/01/15/2022%201.13%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="747-至少是其他数字两倍的最大数"><a href="#747-至少是其他数字两倍的最大数" class="headerlink" title="747. 至少是其他数字两倍的最大数"></a><a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/">747. 至少是其他数字两倍的最大数</a></h4><p>难度简单</p><p>给你一个整数数组 <code>nums</code> ，其中总是存在 <strong>唯一的</strong> 一个最大整数 。</p><p>请你找出数组中的最大元素并检查它是否 <strong>至少是数组中每个其他数字的两倍</strong> 。如果是，则返回 <strong>最大元素的下标</strong> ，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,6,1,0]<br>输出：1<br>解释：6 是最大的整数，对于数组中的其他整数，6 至少是数组中其他元素的两倍。6 的下标是<span class="hljs-number"> 1 </span>，所以返回<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,2,3,4]<br>输出：<span class="hljs-string">-1</span><br>解释：4 没有超过 3 的两倍大，所以返回 <span class="hljs-string">-1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">0</span><br>解释：因为不存在其他数字，所以认为现有数字 <span class="hljs-number">1</span> 至少是其他数字的两倍。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul></li><li><p><code>nums</code> 中的最大元素是唯一的</p></li></ul><h2 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h2><p>第一轮找出最大数并记录最大数的下标，第二轮比较是否有数的两倍大于最大数，有则返回-1。若程序能运行到最后，返回最大数的下标。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dominantIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, mark = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;max)&#123;<br>                mark = i;<br>                max = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=mark)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]*<span class="hljs-number">2</span>&gt;max)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mark;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-15 每日一题</title>
    <link href="/2022/01/15/2022%201.15%20daily%20problem/"/>
    <url>/2022/01/15/2022%201.15%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1716-计算力扣银行的钱"><a href="#1716-计算力扣银行的钱" class="headerlink" title="1716. 计算力扣银行的钱"></a><a href="https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/">1716. 计算力扣银行的钱</a></h4><p>难度简单</p><p>Hercy 想要为购买第一辆车存钱。他 <strong>每天</strong> 都往力扣银行里存钱。</p><p>最开始，他在周一的时候存入 <code>1</code> 块钱。从周二到周日，他每天都比前一天多存入 <code>1</code> 块钱。在接下来每一个周一，他都会比 <strong>前一个周一</strong> 多存入 <code>1</code> 块钱。</p><p>给你 <code>n</code> ，请你返回在第 <code>n</code> 天结束的时候他在力扣银行总共存了多少块钱。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">  输入：n = 4<br>  输出：10<br>解释：第<span class="hljs-number"> 4 </span>天后，总额为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">  输入：n = 10<br>  输出：37<br>解释：第<span class="hljs-number"> 10 </span>天后，总额为 (1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+ 7) + (2 +<span class="hljs-number"> 3 </span>+ 4) =<span class="hljs-number"> 37 </span>。注意到第二个星期一，Hercy 存入<span class="hljs-number"> 2 </span>块钱。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">  输入：n = 20<br>  输出：96<br>解释：第<span class="hljs-number"> 20 </span>天后，总额为 (1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+ 7) + (2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 7 </span>+ 8) + (3 +<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 7 </span>+ 8) =<span class="hljs-number"> 96 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p></li><li><p><code>1 &lt;= n &lt;= 1000</code></p></li></ul><h2 id="方法一：简单模拟"><a href="#方法一：简单模拟" class="headerlink" title="方法一：简单模拟"></a>方法一：简单模拟</h2><p>只需要维持一个每周开始第一天的变量first，就可以用模7取余算出每一天存进去的钱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalMoney</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> money = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">7</span> == <span class="hljs-number">0</span>)&#123;<br>                first++;<br>            &#125;<br>            money += (first+i%<span class="hljs-number">7</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-12 每日一题</title>
    <link href="/2022/01/12/2022%201.12%20daily%20problem/"/>
    <url>/2022/01/12/2022%201.12%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h4><p>难度中等</p><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p><p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[1,2,3,4,5]</span><br>输出：true<br>解释：任何 <span class="hljs-selector-tag">i</span> &lt; j &lt; k 的三元组都满足题意<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：不存在满足题意的三元组<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1,5,0,4,6]</span><br>输出：true<br>解释：三元组 (3, 4, 5) 满足题意，因为 nums<span class="hljs-comment">[3]</span> == 0 &lt; nums<span class="hljs-comment">[4]</span> == 4 &lt; nums<span class="hljs-comment">[5]</span> == 6<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能实现时间复杂度为 <code>O(n)</code> ，空间复杂度为 <code>O(1)</code> 的解决方案吗？</p></li></ul><h2 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h2><p>比较容易想到的是，前面两个数尽可能小，就容易找到第三个数使得序列成立。</p><p>因此，选中的第二个数，最好是仅比第一个数大一点点。那么我们可以设定两个变量，first和second记录前两个数。</p><p>返回真的条件是第三个数大于second，所以second初值设为最大值。</p><p>首先，假设first是数组的第一个数，我们先找到一个比first大的数，设置为second。</p><p>在那之后，每次遍历数组<strong>（在没发现合适的third之前）</strong>发现比second小但比first大的数，就更新为second。因为这个second’在使得原second成立的third的场合，替换成second‘同样成立。</p><p>并且，如果发现了比first小的数，就要把他替换成first。但是这个first并不一定是最终成立序列的一员，他只是一个标杆，用于在后续的查找中发现新的second（因为一直找不到third的话就意味着前面的数组元素都没有能使得命题成立的序列，所以要以后面的新first开始构造序列）。</p><p>当然，因为这个first只是指示杆，所以我们应该先找比second大的数，所以关于second的判断放在前面。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">increasingTriplet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> first = nums[<span class="hljs-number">0</span>],second = INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;second)&#123;<span class="hljs-comment">//找thrid</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&gt;first)&#123;<span class="hljs-comment">//更新second</span><br>                second = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//找到比原first小的数，记录为潜在标杆，当发现了比second小但比新first大的数，那就以新first和新second作为待定成员继续向后查找</span><br>                first = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-09 每日一题</title>
    <link href="/2022/01/09/2022%201.9%20daily%20problem/"/>
    <url>/2022/01/09/2022%201.9%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1629-按键持续时间最长的键"><a href="#1629-按键持续时间最长的键" class="headerlink" title="1629. 按键持续时间最长的键"></a><a href="https://leetcode-cn.com/problems/slowest-key/">1629. 按键持续时间最长的键</a></h4><p>难度简单</p><p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p><p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <strong>下标都从 0 开始</strong> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <strong>恰好</strong> 在前一个键松开时被按下。</p><p>测试人员想要找出按键 <strong>持续时间最长</strong> 的键。第 <code>i</code> 次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p><p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p><p>请返回按键 <strong>持续时间最长</strong> 的键，如果有多个这样的键，则返回 <strong>按字母顺序排列最大</strong> 的那个键。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot;<br>输出：&quot;c&quot;<br>解释：按键顺序和持续时间如下：<br>按下 &#x27;c&#x27; ，持续时间 9（时间<span class="hljs-number"> 0 </span>按下，时间<span class="hljs-number"> 9 </span>松开）<br>按下 &#x27;b&#x27; ，持续时间<span class="hljs-number"> 29 </span>-<span class="hljs-number"> 9 </span>= 20（松开上一个键的时间<span class="hljs-number"> 9 </span>按下，时间<span class="hljs-number"> 29 </span>松开）<br>按下 &#x27;c&#x27; ，持续时间<span class="hljs-number"> 49 </span>-<span class="hljs-number"> 29 </span>= 20（松开上一个键的时间<span class="hljs-number"> 29 </span>按下，时间<span class="hljs-number"> 49 </span>松开）<br>按下 &#x27;d&#x27; ，持续时间<span class="hljs-number"> 50 </span>-<span class="hljs-number"> 49 </span>= 1（松开上一个键的时间<span class="hljs-number"> 49 </span>按下，时间<span class="hljs-number"> 50 </span>松开）<br>按键持续时间最长的键是 &#x27;b&#x27; 和 &#x27;c&#x27;（第二次按下时），持续时间都是 20<br>&#x27;c&#x27; 按字母顺序排列比 &#x27;b&#x27; 大，所以答案是 &#x27;c&#x27;<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：releaseTimes = [<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">36</span>,<span class="hljs-number">46</span>,<span class="hljs-number">62</span>], keysPressed = <span class="hljs-string">&quot;spuda&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br>解释：按键顺序和持续时间如下：<br>按下 <span class="hljs-string">&#x27;s&#x27;</span> ，持续时间 <span class="hljs-number">12</span><br>按下 <span class="hljs-string">&#x27;p&#x27;</span> ，持续时间 <span class="hljs-number">23</span> - <span class="hljs-number">12</span> = <span class="hljs-number">11</span><br>按下 <span class="hljs-string">&#x27;u&#x27;</span> ，持续时间 <span class="hljs-number">36</span> - <span class="hljs-number">23</span> = <span class="hljs-number">13</span><br>按下 <span class="hljs-string">&#x27;d&#x27;</span> ，持续时间 <span class="hljs-number">46</span> - <span class="hljs-number">36</span> = <span class="hljs-number">10</span><br>按下 <span class="hljs-string">&#x27;a&#x27;</span> ，持续时间 <span class="hljs-number">62</span> - <span class="hljs-number">46</span> = <span class="hljs-number">16</span><br>按键持续时间最长的键是 <span class="hljs-string">&#x27;a&#x27;</span> ，持续时间 <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>releaseTimes.length == n</code></li><li><code>keysPressed.length == n</code></li><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= releaseTimes[i] &lt;= 109</code></li><li><code>releaseTimes[i] &lt; releaseTimes[i+1]</code></li><li><code>keysPressed</code> 仅由小写英文字母组成</li></ul></li></ul><h2 id="方法一：哈希表计数"><a href="#方法一：哈希表计数" class="headerlink" title="方法一：哈希表计数"></a>方法一：哈希表计数</h2><p>题目说是26位小写字母，大大简化了问题，直接计数最后遍历就完事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">slowestKey</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; releaseTimes, string keysPressed)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">26</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;releaseTimes.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                hash[keysPressed[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = releaseTimes[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(releaseTimes[i]-releaseTimes[i<span class="hljs-number">-1</span>]&gt;hash[keysPressed[i]-<span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                    hash[keysPressed[i]-<span class="hljs-string">&#x27;a&#x27;</span>] = releaseTimes[i]-releaseTimes[i<span class="hljs-number">-1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i]&gt;=cnt)&#123;<br>                cnt = hash[i];<br>                ans = <span class="hljs-string">&#x27;a&#x27;</span>+i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-08 每日一题</title>
    <link href="/2022/01/08/2022%201.8%20daily%20problem/"/>
    <url>/2022/01/08/2022%201.8%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a><a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a></h4><p>难度中等</p><p><strong>n 位格雷码序列</strong> 是一个由 <code>2n</code> 个整数组成的序列，其中：</p><ul><li>每个整数都在范围 <code>[0, 2n - 1]</code> 内（含 <code>0</code> 和 <code>2n - 1</code>）</li><li>第一个整数是 <code>0</code></li><li>一个整数在序列中出现 <strong>不超过一次</strong></li><li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li><li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li></ul><p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2<br>输出：[0,1,3,2]<br>解释：<br>[0,1,3,2] 的二进制表示是 [00,01,11,10] 。<br>-<span class="hljs-number"> 00 </span>和<span class="hljs-number"> 01 </span>有一位不同<br>-<span class="hljs-number"> 01 </span>和<span class="hljs-number"> 11 </span>有一位不同<br>-<span class="hljs-number"> 11 </span>和<span class="hljs-number"> 10 </span>有一位不同<br>-<span class="hljs-number"> 10 </span>和<span class="hljs-number"> 00 </span>有一位不同<br>[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。<br>-<span class="hljs-number"> 00 </span>和<span class="hljs-number"> 10 </span>有一位不同<br>-<span class="hljs-number"> 10 </span>和<span class="hljs-number"> 11 </span>有一位不同<br>-<span class="hljs-number"> 11 </span>和<span class="hljs-number"> 01 </span>有一位不同<br>-<span class="hljs-number"> 01 </span>和<span class="hljs-number"> 00 </span>有一位不同<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li></ul></li></ul><h2 id="方法一：套公式"><a href="#方法一：套公式" class="headerlink" title="方法一：套公式"></a>方法一：套公式</h2><p>像是逻辑推理问题，n位格雷编码是有公式的。</p><p>如果我们有一个二进制数序列，我们也可以将它直接转换成格雷码序列。假设 n 位二进制数为 b，对应的格雷码为 g，转换规则如下：</p><p>$$<br>g(i) &#x3D; b(i+1) \oplus b(i),~~~~0 \le i \lt n</p><p>其中 \oplus 是按位异或运算，g(i) 和 b(i) 分别表示 g 和 b 的第 i 位，且 b(n)&#x3D;0。\</p><p>上述转换规则的证明如下:\</p><p>考虑 n 位二进制数 b_i</p><p>  和对应的转换码 g_i</p><p> ，并且 b_{i+1} &#x3D; b_i + 1<br> 也是 n 位二进制数。\b_{i+1} 与 b_i 的区别在于 b_{i+1} 将 b_i 二进制下末位连接的 1 全部变成 0，\然后将最低位的 0 变成 1。\假设变化涉及到的二进制位数为 k 位，则按照上述转换规则，\ g_{i+1} 与 g_i 只有在第 k - 1 位不相同，其他位都相同。\因此转换得到的码相邻的数只有一位不同，而转换码第一个整数和最后一个整数分别由二进制数 0 和 2^{n-1} 转换而来，\也只有一位不同。因为二进制数的取值范围为 [0,<del>2^n) ，且上述转换规则为一对一映射，\因此得到的转换码也是互不相同的，且取值范围也在 [0,</del>2^n)。<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">grayCode</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ret[i] = (i &gt;&gt; <span class="hljs-number">1</span>) ^ i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-07 每日一题</title>
    <link href="/2022/01/07/2022%201.7%20daily%20problem/"/>
    <url>/2022/01/07/2022%201.7%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1614-括号的最大嵌套深度"><a href="#1614-括号的最大嵌套深度" class="headerlink" title="1614. 括号的最大嵌套深度"></a><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">1614. 括号的最大嵌套深度</a></h4><p>难度简单</p><p>如果字符串满足以下条件之一，则可以称之为 <strong>有效括号字符串****（valid parentheses string</strong>，可以简写为 <strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串 <code>&quot;&quot;</code>，或者是一个不为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code> 的单字符。</li><li>字符串可以写为 <code>AB</code>（<code>A</code> 与 <code>B</code> 字符串连接），其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong> 。</li><li>字符串可以写为 <code>(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong> 。</li></ul><p>类似地，可以定义任何有效括号字符串 <code>S</code> 的 <strong>嵌套深度</strong> <code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中 <code>C</code> 是单个字符的字符串，且该字符不是 <code>&quot;(&quot;</code> 或者 <code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中 <code>A</code> 和 <code>B</code> 都是 <strong>有效括号字符串</strong></li><li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是一个 <strong>有效括号字符串</strong></li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code> 都是 <strong>有效括号字符串</strong>（嵌套深度分别为 0、1、2），而 <code>&quot;)(&quot;</code> 、<code>&quot;(()&quot;</code> 都不是 <strong>有效括号字符串</strong> 。</p><p>给你一个 <strong>有效括号字符串</strong> <code>s</code>，返回该字符串的 <code>s</code> <strong>嵌套深度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1+(2*3)+((8)/4))+1&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：数字 <span class="hljs-number">8</span> 在嵌套的 <span class="hljs-number">3</span> 层括号中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1)+((2))+(((3)))&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1+(2*3)/(2-1)&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由数字 <code>0-9</code> 和字符 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code>、<code>&#39;/&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 组成</li><li>题目数据保证括号表达式 <code>s</code> 是 <strong>有效的括号表达式</strong></li></ul></li></ul><h2 id="方法一：栈思想"><a href="#方法一：栈思想" class="headerlink" title="方法一：栈思想"></a>方法一：栈思想</h2><p>太简单了，碰到左括号就栈高度增一，右括号就高度减一，每次增长完比较当前栈高度大小，返回一个最大高度值就可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> kuohao = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                kuohao++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(kuohao&gt;ans)&#123;<br>                ans = kuohao;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                kuohao--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-06 每日一题</title>
    <link href="/2022/01/06/2022%201.6%20daily%20problem/"/>
    <url>/2022/01/06/2022%201.6%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a><a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></h4><p>难度中等</p><p>给你一个字符串 <code>path</code> ，表示指向某一文件或目录的 Unix 风格 <strong>绝对路径</strong> （以 <code>&#39;/&#39;</code> 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（<code>.</code>）表示当前目录本身；此外，两个点 （<code>..</code>） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，<code>&#39;//&#39;</code>）都被视为单个斜杠 <code>&#39;/&#39;</code> 。 对于此问题，任何其他格式的点（例如，<code>&#39;...&#39;</code>）均被视为文件&#x2F;目录名称。</p><p>请注意，返回的 <strong>规范路径</strong> 必须遵循下述格式：</p><ul><li>始终以斜杠 <code>&#39;/&#39;</code> 开头。</li><li>两个目录名之间必须只有一个斜杠 <code>&#39;/&#39;</code> 。</li><li>最后一个目录名（如果存在）<strong>不能</strong> 以 <code>&#39;/&#39;</code> 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 <code>&#39;.&#39;</code> 或 <code>&#39;..&#39;</code>）。</li></ul><p>返回简化后得到的 <strong>规范路径</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home/&quot;</span><br>输出：<span class="hljs-string">&quot;/home&quot;</span><br>解释：注意，最后一个目录名后面没有斜杠。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/../&quot;</span><br>输出：<span class="hljs-string">&quot;/&quot;</span><br>解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/home//foo/&quot;</span><br>输出：<span class="hljs-string">&quot;/home/foo&quot;</span><br>解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：path <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/a/./b/../../c/&quot;</span><br>输出：<span class="hljs-string">&quot;/c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= path.length &lt;= 3000</code></li><li><code>path</code> 由英文字母，数字，<code>&#39;.&#39;</code>，<code>&#39;/&#39;</code> 或 <code>&#39;_&#39;</code> 组成。</li><li><code>path</code> 是一个有效的 Unix 风格绝对路径。</li></ul></li></ul><h2 id="方法一：双向队列"><a href="#方法一：双向队列" class="headerlink" title="方法一：双向队列"></a>方法一：双向队列</h2><p>题目中指出当目录项为 “..” 时，要返回上一级目录，从变成的思维来说就是退栈；但是最后输出又要按照输入的先进先出顺序，从这个角度看又是队列。所以选用可以弹出尾部元素的双向队列来实现。</p><p>首先遍历字符串，把每一层目录的内容编成一个字符串str；</p><p>然后检查str，有三种情况：</p><p>1，str 为 “.” ，此时代表当前目录，不用管。</p><p>2，str为 ”..“ ，此时代表回到上一个目录，弹出一个尾部元素。</p><p>3，除去1，2情况以外，一律代表正常的文件目录，直接进队即可。</p><p>最后逐个出队生成新的字符串返回即可，要注意有可能队列为空，则直接返回根目录。</p><p>PS：这次做题中发现了个问题，假如一开始的判是否进队的逻辑，把str &#x3D;&#x3D; ”.” 单独拿出来做一个条件的话，会有一些测例过不去，单一时间想不出来什么原因，所以改成了排除法，用str !&#x3D; “.” 进行判断，就没有错误了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">simplifyPath</span><span class="hljs-params">(string path)</span> </span>&#123;<br>        deque&lt;string&gt; file;<span class="hljs-comment">//双向队列</span><br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;path.<span class="hljs-built_in">length</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(path[i]==<span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>                <span class="hljs-keyword">while</span>(path[i+<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;/&#x27;</span>&amp;&amp;i+<span class="hljs-number">1</span>&lt;path.<span class="hljs-built_in">length</span>())&#123;<br>                    str+=path[i+<span class="hljs-number">1</span>];<span class="hljs-comment">//编程目录项字符串，用于压入双向队列</span><br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">length</span>()&gt;=<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(str==<span class="hljs-string">&quot;..&quot;</span>)&#123;<span class="hljs-comment">//此时要回退一个目录</span><br>                        <span class="hljs-keyword">if</span>(!file.<span class="hljs-built_in">empty</span>())&#123;<br>                            file.<span class="hljs-built_in">pop_back</span>();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str!=<span class="hljs-string">&quot;.&quot;</span>)&#123;<span class="hljs-comment">//因为“.”属于当前目录，所以不管“.”</span><br>                        file.<span class="hljs-built_in">push_back</span>(str);<br>                    &#125;<br>                &#125;<br>                str=<span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>        &#125;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span>(file.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//若文件路径名为空，直接返回根目录</span><br>            ans+=<span class="hljs-string">&#x27;/&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!file.<span class="hljs-built_in">empty</span>())&#123;<span class="hljs-comment">//非空，逐个弹出</span><br>                ans+=<span class="hljs-string">&#x27;/&#x27;</span>;<br>                ans+=file.<span class="hljs-built_in">front</span>();<br>                file.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-04 每日一题</title>
    <link href="/2022/01/05/2022%201.4%20daily%20problem/"/>
    <url>/2022/01/05/2022%201.4%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="913-猫和老鼠"><a href="#913-猫和老鼠" class="headerlink" title="913. 猫和老鼠"></a><a href="https://leetcode-cn.com/problems/cat-and-mouse/">913. 猫和老鼠</a></h4><p>难度困难</p><p>两位玩家分别扮演猫和老鼠，在一张 <strong>无向</strong> 图上进行游戏，两人轮流行动。</p><p>图的形式是：<code>graph[a]</code> 是一个列表，由满足 <code>ab</code> 是图中的一条边的所有节点 <code>b</code> 组成。</p><p>老鼠从节点 <code>1</code> 开始，第一个出发；猫从节点 <code>2</code> 开始，第二个出发。在节点 <code>0</code> 处有一个洞。</p><p>在每个玩家的行动中，他们 <strong>必须</strong> 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 <code>1</code> ，那么它必须移动到 <code>graph[1]</code> 中的任一节点。</p><p>此外，猫无法移动到洞中（节点 <code>0</code>）。</p><p>然后，游戏在出现以下三种情形之一时结束：</p><ul><li>如果猫和老鼠出现在同一个节点，猫获胜。</li><li>如果老鼠到达洞中，老鼠获胜。</li><li>如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。</li></ul><p>给你一张图 <code>graph</code> ，并假设两位玩家都都以最佳状态参与游戏：</p><ul><li>如果老鼠获胜，则返回 <code>1</code>；</li><li>如果猫获胜，则返回 <code>2</code>；</li><li>如果平局，则返回 <code>0</code> 。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[2,5]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[0,4,5]</span>,<span class="hljs-comment">[1,4,5]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[0,2,3]</span>]</span><br>输出：0<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[0]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[0,2]</span>]</span><br>输出：1<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= graph.length &lt;= 50</code></li><li><code>1 &lt;= graph[i].length &lt; graph.length</code></li><li><code>0 &lt;= graph[i][j] &lt; graph.length</code></li><li><code>graph[i][j] != i</code></li><li><code>graph[i]</code> 互不相同</li><li>猫和老鼠在游戏中总是移动</li></ul><h2 id="方法一：记忆化搜索"><a href="#方法一：记忆化搜索" class="headerlink" title="方法一：记忆化搜索"></a>方法一：记忆化搜索</h2><p>裂开，太难了，想了好久完全没办法，当是学新技巧了。</p><p>贴一个题解：<a href="https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/">https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOUSE_WIN = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CAT_WIN = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DRAW = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">51</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> dp[MAXN][MAXN][MAXN*<span class="hljs-number">2</span>];<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">catMouseGame</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;graph = graph;<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getResult</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(<span class="hljs-type">int</span> mouse, <span class="hljs-type">int</span> cat, <span class="hljs-type">int</span> turns)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (turns == n * <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> DRAW;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dp[mouse][cat][turns] &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mouse == <span class="hljs-number">0</span>) &#123;<br>                dp[mouse][cat][turns] = MOUSE_WIN;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cat == mouse) &#123;<br>                dp[mouse][cat][turns] = CAT_WIN;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">getNextResult</span>(mouse, cat, turns);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[mouse][cat][turns];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNextResult</span><span class="hljs-params">(<span class="hljs-type">int</span> mouse, <span class="hljs-type">int</span> cat, <span class="hljs-type">int</span> turns)</span> </span>&#123;<br>        <span class="hljs-type">int</span> curMove = turns % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? mouse : cat;<br>        <span class="hljs-type">int</span> defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;<br>        <span class="hljs-type">int</span> result = defaultResult;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> next : graph[curMove]) &#123;<br>            <span class="hljs-keyword">if</span> (curMove == cat &amp;&amp; next == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> nextMouse = curMove == mouse ? next : mouse;<br>            <span class="hljs-type">int</span> nextCat = curMove == cat ? next : cat;<br>            <span class="hljs-type">int</span> nextResult = <span class="hljs-built_in">getResult</span>(nextMouse, nextCat, turns + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nextResult != defaultResult) &#123;<br>                result = nextResult;<br>                <span class="hljs-keyword">if</span> (result != DRAW) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        dp[mouse][cat][turns] = result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-02 每日一题</title>
    <link href="/2022/01/05/2022%201.2%20daily%20problem/"/>
    <url>/2022/01/05/2022%201.2%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="390-消除游戏"><a href="#390-消除游戏" class="headerlink" title="390. 消除游戏"></a><a href="https://leetcode-cn.com/problems/elimination-game/">390. 消除游戏</a></h4><p>难度中等</p><p>列表 <code>arr</code> 由在范围 <code>[1, n]</code> 中的所有整数组成，并按严格递增排序。请你对 <code>arr</code> 应用下述算法：</p><ul><li>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。</li><li>重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。</li><li>不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。</li></ul><p>给你整数 <code>n</code> ，返回 <code>arr</code> 最后剩下的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 9<br>输出：6<br>解释：<br>arr = <span class="hljs-comment">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br>arr = <span class="hljs-comment">[2, 4, 6, 8]</span><br>arr = <span class="hljs-comment">[2, 6]</span><br>arr = <span class="hljs-comment">[6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 10^9</code></li></ul></li></ul><h2 id="方法一：数学法（等差模拟）"><a href="#方法一：数学法（等差模拟）" class="headerlink" title="方法一：数学法（等差模拟）"></a>方法一：数学法（等差模拟）</h2><p>其实是一道数学题，当然题目本质就是位置的删除，对位置上的数没有影响，所以整个程序只需要把下标看成一个连续的正整数数列处理就可以了，因为题目中给出的数列本身就是正整数数列，所以也就不额外开辟数组了。（如果是无规则的数列是一样的做法，只需要多开一个存储数组就可以）。</p><p>首先不要被题目的描述所迷惑，我们可以发现每次处理完，剩下的部分都是等差数列，比如1~10，删完剩下2 4 6 8 10；由等差是1的数列变成等差是2的数列，再删第二趟，剩下4和8；等差变成4。于是我们就发现了规律。</p><p>但是我们继续观察，因为只需要最后剩下的一个数，那么换言之我们只需要知道每一趟处理完的从左往右的第一个数，记录一个数组长度，当数组长度为1的时候，就是答案了。</p><p>并且我们也发现了，每一趟处理完后数组长度会减半（如果是奇数，则向下取整）。</p><p>最后剩下一个点：题目给出来的向左和向右交替删除的要求。</p><p>再思考一下就发现了，假如当前数组长度是奇数，那么向左删和向右删是一样的；如果当前数组长度是偶数，向右删第一个会被删除，向左删第一个会被留下。至此所有前置工作都已经完成。</p><p>于是使用一个变量趟数k，记录当前方向是向右还是向左；一个总长度cnt，记录每轮处理完剩下的长度；一个记录位置ans，记录当前剩余数组的第一位；一个等差变化step，每一趟处理完都翻倍。</p><p>情况1：偶数趟，当前趟的首位必定是上一趟的首位前进了上轮等差步长。</p><p>情况2：奇数趟且长度为偶数，因为从后往前删，所以首位会保留。</p><p>情况3：奇数趟且长度为奇数，这种情况就跟偶数趟一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, cnt = n, step = <span class="hljs-number">1</span>;<span class="hljs-comment">//k表示第k趟，cnt为总数目，step是步长</span><br>        <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//偶数趟，向前删</span><br>                ans += step;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//奇数趟，向后删</span><br>                <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    ans = ans;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    ans += step;<br>                &#125;<br>            &#125;<br>            k++;<br>            cnt = cnt/<span class="hljs-number">2</span>;<br>            step = step*<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-03 每日一题</title>
    <link href="/2022/01/05/2022%201.3%20daily%20problem/"/>
    <url>/2022/01/05/2022%201.3%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1185-一周中的第几天"><a href="#1185-一周中的第几天" class="headerlink" title="1185. 一周中的第几天"></a><a href="https://leetcode-cn.com/problems/day-of-the-week/">1185. 一周中的第几天</a></h4><p>难度简单</p><p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p><p>输入为三个整数：<code>day</code>、<code>month</code> 和 <code>year</code>，分别表示日、月、年。</p><p>您返回的结果必须是这几个值中的一个 <code>&#123;&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;&#125;</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">day</span> = <span class="hljs-number">31</span>, <span class="hljs-built_in">month</span> = <span class="hljs-number">8</span>, <span class="hljs-built_in">year</span> = <span class="hljs-number">2019</span><br>输出：<span class="hljs-string">&quot;Saturday&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">day</span> = <span class="hljs-number">18</span>, <span class="hljs-built_in">month</span> = <span class="hljs-number">7</span>, <span class="hljs-built_in">year</span> = <span class="hljs-number">1999</span><br>输出：<span class="hljs-string">&quot;Sunday&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">day</span> = <span class="hljs-number">15</span>, <span class="hljs-built_in">month</span> = <span class="hljs-number">8</span>, <span class="hljs-built_in">year</span> = <span class="hljs-number">1993</span><br>输出：<span class="hljs-string">&quot;Sunday&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给出的日期一定是在 <code>1971</code> 到 <code>2100</code> 年之间的有效日期。</li></ul></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>典中典科班生本科必定做过的题目，思路就是先确定第一天，然后算中间的天数模7。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(year % <span class="hljs-number">4</span>==<span class="hljs-number">0</span> &amp;&amp; year %<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(year %<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">dayOfTheWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> day, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> year)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tianshu=<span class="hljs-number">0</span>;<br>        vector&lt;string&gt; weekday;<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Thursday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Friday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Saturday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Sunday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Monday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Tuesday&quot;</span>);<br>        weekday.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Wednesday&quot;</span>);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1971</span>;i&lt;year;i++)&#123;<br>            tianshu+=<span class="hljs-number">365</span>;<span class="hljs-comment">//非闰年天数</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLeapYear</span>(i))&#123;<br>                tianshu++;<span class="hljs-comment">//闰年多加一天</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;month;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>||i==<span class="hljs-number">6</span>||i==<span class="hljs-number">9</span>||i==<span class="hljs-number">11</span>)&#123;<br>                tianshu+=<span class="hljs-number">30</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">2</span>)&#123;<br>                tianshu += <span class="hljs-number">28</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLeapYear</span>(year))&#123;<br>                    tianshu++;<span class="hljs-comment">//如果此时是闰年的2月,多加一天</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                tianshu +=<span class="hljs-number">31</span>;<br>            &#125;<br>        &#125;<br>        tianshu+=day;<br>        <span class="hljs-keyword">return</span> weekday[tianshu%<span class="hljs-number">7</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-05 每日一题</title>
    <link href="/2022/01/05/2022%201.5%20daily%20problem/"/>
    <url>/2022/01/05/2022%201.5%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h4><p>难度简单</p><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p><p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p><p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;?zs&quot;</span><br>输出：<span class="hljs-string">&quot;azs&quot;</span><br>解释：该示例共有 <span class="hljs-number">25</span> 种解决方案，从 <span class="hljs-string">&quot;azs&quot;</span> 到 <span class="hljs-string">&quot;yzs&quot;</span> 都是符合题目要求的。只有 <span class="hljs-string">&quot;z&quot;</span> 是无效的修改，因为字符串 <span class="hljs-string">&quot;zzs&quot;</span> 中有连续重复的两个 &#x27;z&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ubv?w&quot;</span><br>输出：<span class="hljs-string">&quot;ubvaw&quot;</span><br>解释：该示例共有 <span class="hljs-number">24</span> 种解决方案，只有替换成 <span class="hljs-string">&quot;v&quot;</span> 和 <span class="hljs-string">&quot;w&quot;</span> 不符合题目要求。因为 <span class="hljs-string">&quot;ubvvw&quot;</span> 和 <span class="hljs-string">&quot;ubvww&quot;</span> 都包含连续重复的字符。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;j?qg??b&quot;</span><br>输出：<span class="hljs-string">&quot;jaqgacb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;??yw?ipkj?&quot;</span><br>输出：<span class="hljs-string">&quot;acywaipkja&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li></ul></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>太简单，不展开了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">modifyString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">char</span> alphabat[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;<br>            alphabat[i] = <span class="hljs-string">&#x27;a&#x27;</span> + i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(alphabat[k]!=s[i+<span class="hljs-number">1</span>])&#123;<br>                            s[i] = alphabat[k];<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(alphabat[k]!=s[i<span class="hljs-number">-1</span>])&#123;<br>                            s[i] = alphabat[k];<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">26</span>;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(alphabat[k]!=s[i+<span class="hljs-number">1</span>]&amp;&amp;alphabat[k]!=s[i<span class="hljs-number">-1</span>])&#123;<br>                            s[i] = alphabat[k];<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-01-01 每日一题</title>
    <link href="/2022/01/01/2022%201.1%20daily%20problem/"/>
    <url>/2022/01/01/2022%201.1%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="2022-将一维数组转变成二维数组"><a href="#2022-将一维数组转变成二维数组" class="headerlink" title="2022. 将一维数组转变成二维数组"></a><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/">2022. 将一维数组转变成二维数组</a></h4><p>难度简单</p><p>给你一个下标从 <strong>0</strong> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和 <code>n</code> 。你需要使用 <code>original</code> 中 <strong>所有</strong> 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p><p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 <strong>包含</strong> ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个 <code>m x n</code> 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/08/26/image-20210826114243-1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：original = <span class="hljs-comment">[1,2,3,4]</span>, m = 2, n = 2<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>]</span><br>解释：<br>构造出的二维数组应该包含 2 行 2 列。<br>original 中第一个 n=2 的部分为 <span class="hljs-comment">[1,2]</span> ，构成二维数组的第一行。<br>original 中第二个 n=2 的部分为 <span class="hljs-comment">[3,4]</span> ，构成二维数组的第二行。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：original = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], m = <span class="hljs-number">1</span>, n = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[[1,2,3]]</span><br>解释：<br>构造出的二维数组应该包含 <span class="hljs-number">1</span> 行 <span class="hljs-number">3</span> 列。<br>将 original 中所有三个元素放入第一行中，构成要求的二维数组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：original = <span class="hljs-comment">[1,2]</span>, m = 1, n = 1<br>输出：<span class="hljs-comment">[]</span><br>解释：<br>original 中有 2 个元素。<br>无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：original = <span class="hljs-comment">[3]</span>, m = 1, n = 2<br>输出：<span class="hljs-comment">[]</span><br>解释：<br>original 中只有 1 个元素。<br>无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= original.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= original[i] &lt;= 10^5</code></li><li><code>1 &lt;= m, n &lt;= 4 * 10^4</code></li></ul></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>2022第一天不为难大家？但也太简单了。直接分组放入完事。</p><p>就是测例有点离谱，一共107个测例只有2个测例能构造出要求的二维数组。。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">construct2DArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; original, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span>(original.<span class="hljs-built_in">size</span>()!=m*n)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                temp.<span class="hljs-built_in">push_back</span>(original[j]);<br>                j++;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-12-31 每日一题</title>
    <link href="/2021/12/31/2021.12.31%20daily%20problem/"/>
    <url>/2021/12/31/2021.12.31%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="507-完美数"><a href="#507-完美数" class="headerlink" title="507. 完美数"></a><a href="https://leetcode-cn.com/problems/perfect-number/">507. 完美数</a></h4><p>难度简单</p><p>对于一个 <strong>正整数</strong>，如果它和除了它自身以外的所有 <strong>正因子</strong> 之和相等，我们称它为 「完美数」。</p><p>给定一个 <strong>整数</strong> <code>n</code>， 如果是完美数，返回 <code>true</code>，否则返回 <code>false</code></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 28<br>输出：true<br>解释：28 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 7 </span>+ 14<br>1, 2, 4, 7, 和<span class="hljs-number"> 14 </span>是<span class="hljs-number"> 28 </span>的所有正因子。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">496</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">8128</span><br>输出：<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^8</code></li></ul></li></ul><h2 id="方法一：开根查找"><a href="#方法一：开根查找" class="headerlink" title="方法一：开根查找"></a>方法一：开根查找</h2><p>这是一道数学题，找因子的时候只要以给出的num开平方为上界就可以（因为num太大了，不能直接暴力）。</p><p>而假如num &#x3D; a*b，其中ab较小一方一定小于等于根号num，所以在找到a并累加的时候，累加上b就行（b &#x3D; num&#x2F;a)。</p><p>然后因为不需要num本体，所以从2开始遍历，于是在最后total和需要加1才是符合条件的数。</p><p>最后注意一下1，因为我们从2开始算，会把1漏掉，最后再判一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPerfectNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> temp = <span class="hljs-built_in">sqrt</span>(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=temp;i++)&#123;<br>            <span class="hljs-keyword">if</span>(num%i==<span class="hljs-number">0</span>)&#123;<br>                total+=i;<br>                total+=num/i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(total+<span class="hljs-number">1</span>==num&amp;&amp;num!=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-12-30 每日一题</title>
    <link href="/2021/12/30/2021.12.30%20daily%20problem/"/>
    <url>/2021/12/30/2021.12.30%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="846-一手顺子"><a href="#846-一手顺子" class="headerlink" title="846. 一手顺子"></a><a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></h4><p>难度中等</p><p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 <code>groupSize</code> ，并且由 <code>groupSize</code> 张连续的牌组成。</p><p>给你一个整数数组 <code>hand</code> 其中 <code>hand[i]</code> 是写在第 <code>i</code> 张牌，和一个整数 <code>groupSize</code> 。如果她可能重新排列这些牌，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：hand = <span class="hljs-comment">[1,2,3,6,2,3,4,7,8]</span>, groupSize = 3<br>输出：true<br>解释：Alice 手中的牌可以被重新排列为 <span class="hljs-comment">[1,2,3]</span>，<span class="hljs-comment">[2,3,4]</span>，<span class="hljs-comment">[6,7,8]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">hand</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">groupSize</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-literal">false</span><br>解释：Alice 手中的牌无法被重新排列成几个大小为 <span class="hljs-number">4</span> 的组。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= hand.length &lt;= 104</code></li><li><code>0 &lt;= hand[i] &lt;= 109</code></li><li><code>1 &lt;= groupSize &lt;= hand.length</code></li></ul></li></ul><h2 id="方法一：哈希表法"><a href="#方法一：哈希表法" class="headerlink" title="方法一：哈希表法"></a>方法一：哈希表法</h2><p>思路就是先排序，从每一组分割的首位数字开始检查存在性。</p><p>每个数字每出现一次，对应的哈希值增一。</p><p>然后遍历数组，若当前数的哈希值不为零，则检查<strong>HashMap[hand[i]]</strong> ~ **HashMap[hand[i]+k]**，的值是否都大于零。一旦发现这之间的哈希值有一个是0，代表有一些数无法凑成分组，与题设矛盾，即返回false。</p><p>每轮成功的遍历则把访问过的数对应的哈希值减一，从逻辑上剔除。</p><p>最后要注意的是这次数的范围比较大，所以不能直接使用一维数组，要用Map来建立映射对记录哈希值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNStraightHand</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; hand, <span class="hljs-type">int</span> groupSize)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = hand.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n%groupSize!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; HashMap;<span class="hljs-comment">//建立哈希表</span><br>            <span class="hljs-built_in">sort</span>(hand.<span class="hljs-built_in">begin</span>(),hand.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                HashMap[hand[i]]++;<span class="hljs-comment">//每出现一次哈希值加一</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>                <span class="hljs-keyword">if</span>(HashMap[hand[i]]!=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;groupSize;k++)&#123;<br>                        <span class="hljs-keyword">if</span>(HashMap[hand[i]+k]==<span class="hljs-number">0</span>)&#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;groupSize;k++)&#123;<br>                        HashMap[hand[i]+k]--;<span class="hljs-comment">//每一轮访问过的数哈希值都要减一</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-12-29 每日一题</title>
    <link href="/2021/12/29/2021.12.29%20daily%20problem/"/>
    <url>/2021/12/29/2021.12.29%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1995-统计特殊四元组"><a href="#1995-统计特殊四元组" class="headerlink" title="1995. 统计特殊四元组"></a><a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></h4><p>难度简单</p><p>给你一个 <strong>下标从 0 开始</strong> 的整数数组 <code>nums</code> ，返回满足下述条件的 <strong>不同</strong> 四元组 <code>(a, b, c, d)</code> 的 <strong>数目</strong> ：</p><ul><li><code>nums[a] + nums[b] + nums[c] == nums[d]</code> ，且</li><li><code>a &lt; b &lt; c &lt; d</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,6]<br>输出：1<br>解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>==<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,3,6,4,5]</span><br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-string">[3,3,6,4,5]</span> 中不存在满足要求的四元组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,1,3,5]<br>输出：4<br>解释：满足要求的<span class="hljs-number"> 4 </span>个四元组如下：<br>- (0, 1, 2, 3):<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>== 3<br>- (0, 1, 3, 4):<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>== 5<br>- (0, 2, 3, 4):<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>== 5<br>- (1, 2, 3, 4):<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>== 5<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>4 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>暴力四重循环，可以通过哈希记录减少为三重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countQuadruplets</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-3</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n<span class="hljs-number">-2</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=j+<span class="hljs-number">1</span>;k&lt;n<span class="hljs-number">-1</span>;k++)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=k+<span class="hljs-number">1</span>;z&lt;n;z++)&#123;<br>                        <span class="hljs-keyword">if</span>(nums[i]+nums[k]+nums[j]==nums[z])&#123;<br>                            ans++;<br>                        &#125;                        <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-12-28 每日一题</title>
    <link href="/2021/12/28/2021.12.28%20daily%20problem/"/>
    <url>/2021/12/28/2021.12.28%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="472-连接词"><a href="#472-连接词" class="headerlink" title="472. 连接词"></a><a href="https://leetcode-cn.com/problems/concatenated-words/">472. 连接词</a></h4><p>难度困难</p><p>给你一个 <strong>不含重复</strong> 单词的字符串数组 <code>words</code> ，请你找出并返回 <code>words</code> 中的所有 <strong>连接词</strong> 。</p><p><strong>连接词</strong> 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;cats&quot;</span>,<span class="hljs-string">&quot;catsdogcats&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;dogcatsdog&quot;</span>,<span class="hljs-string">&quot;hippopotamuses&quot;</span>,<span class="hljs-string">&quot;rat&quot;</span>,<span class="hljs-string">&quot;ratcatdogcat&quot;</span>]<br>输出：[<span class="hljs-string">&quot;catsdogcats&quot;</span>,<span class="hljs-string">&quot;dogcatsdog&quot;</span>,<span class="hljs-string">&quot;ratcatdogcat&quot;</span>]<br>解释：<span class="hljs-string">&quot;catsdogcats&quot;</span> 由 <span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span> 和 <span class="hljs-string">&quot;cats&quot;</span> 组成; <br>     <span class="hljs-string">&quot;dogcatsdog&quot;</span> 由 <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;cats&quot;</span> 和 <span class="hljs-string">&quot;dog&quot;</span> 组成; <br>     <span class="hljs-string">&quot;ratcatdogcat&quot;</span> 由 <span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span> 和 <span class="hljs-string">&quot;cat&quot;</span> 组成。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;catdog&quot;</span>]<br>输出：[<span class="hljs-string">&quot;catdog&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^4</code></li><li><code>0 &lt;= words[i].length &lt;= 1000</code></li><li><code>words[i]</code> 仅由小写字母组成</li><li><code>0 &lt;= sum(words[i].length) &lt;= 10^5</code></li></ul></li></ul><h2 id="方法一：字符串哈希或者字典树"><a href="#方法一：字符串哈希或者字典树" class="headerlink" title="方法一：字符串哈希或者字典树"></a>方法一：字符串哈希或者字典树</h2><p>裂开了，想到用字符串哈希但是不会实现。。字典树没学过，倒了。</p><p>放个题目链接在这里。</p><p><a href="https://leetcode-cn.com/problems/concatenated-words/">https://leetcode-cn.com/problems/concatenated-words/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">bool</span> isEnd;<br>    vector&lt;Trie *&gt; children;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;children = <span class="hljs-built_in">vector</span>&lt;Trie *&gt;(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Trie * trie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findAllConcatenatedWordsInADict</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> string &amp; a, <span class="hljs-type">const</span> string &amp; b)&#123;<br>            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>(); <br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            string word = words[i];<br>            <span class="hljs-keyword">if</span> (word.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(word, <span class="hljs-number">0</span>)) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(word);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">insert</span>(word);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; word, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (word.<span class="hljs-built_in">size</span>() == start) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        Trie * node = trie;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; word.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">char</span> ch = word[i];<br>            <span class="hljs-type">int</span> index = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            node = node-&gt;children[index];<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;isEnd) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(word, i + <span class="hljs-number">1</span>)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp; word)</span> </span>&#123;<br>        Trie * node = trie;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; word.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">char</span> ch = word[i];<br>            <span class="hljs-type">int</span> index = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (node-&gt;children[index] == <span class="hljs-literal">nullptr</span>) &#123;<br>                node-&gt;children[index] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            node = node-&gt;children[index];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Essay-03</title>
    <link href="/2021/12/27/essay-04/"/>
    <url>/2021/12/27/essay-04/</url>
    
    <content type="html"><![CDATA[<h3 id="2021年终总结"><a href="#2021年终总结" class="headerlink" title="2021年终总结"></a>2021年终总结</h3><p>2021年也是挺波折的一年了，年初考完就全身心投入放松，没考虑过之后的事情，结果2月底出成绩果然是没有进浙大的初试，那个时候的感觉印象还很深，陷入了一种绝望和迷茫之中。第二天还要去打广州站，一宿没睡着。</p><p>3月开始就投身于找工作之中了，还因为不了解特招也得按照常规流程准备公务员考试，浪费了一次机会。</p><p>面试的经历有很多啊，什么电话面，视频面，还有去网易大楼手撕代码。最高兴的就是能亲身面试一次腾讯吧，跟面试官聊了快两个小时还是没进二面，这之后让我深深感觉到自己能力还差得远，外加上身边的朋友大多都上岸了，这种无形的落差感无时无刻都在提醒我有多废物，下定决心要考研了。于是后来的那些面试和offer也当是走流程了，看看自己当时“值多少”。</p><p>跟找工作同时进行的还有毕设，当时心情说实话也没静下来，所以那段时间压力很大，也很焦虑，不过也算妥善完成，在四月底交了初稿和过完了所有面试，跟幻龙骑的朋友一起去打深圳站。那两天真的很开心，几个大男人一起出出游，一起讨论构筑，一起玩各种小游戏，嗨到凌晨三四点，虽然两次比赛都是差一点就出瑞士轮了，有遗憾但真是非常美好的时光，下次有机会再接再厉吧。</p><p>五六月因为疫情，跟舍友们的毕业旅行没去成，但是也多次吃1+1，多次在大学城周围骑车，也拍了不少照片，留下最后的大学回忆，还有跟以前的同学，大学的同学一起拍毕业照，想起来还是会心情变好的。毕业的前一天还担任了学院的助理帮同学们处理毕业的事务，跟全年级的同学朋友打了照面，把一些以前名字和脸对不起来的同学重新认识了一遍哈哈，这么一来，其实也算是圆满了吧。</p><p>七八月回家，就是继续玩玩牌，偶尔看看书，倒卖点卡，跟老同学老朋友叙叙旧，聊聊去路，感叹似乎只有自己还在原地踏步，不过也维系了我所珍视的感情，希望以后还有时间能跟大家快乐相处。</p><p>之后就是一直备战到年底了，这期间放弃了之前维系了几个月的leetcode每日一题的习惯，还有博客的更新。正如之前说过的，备考的时间正是因为有同学朋友的鼓励和支持才有了不摆烂的信念。</p><p>总的来说，今年没什么成就，但也不算过得很差，确实是仔细地思考过以后要怎么做，要怎么继续往前的问题，要变得稳重，要有担当，要敢拼搏和争取，得过且过是不行的。</p><p>带着这一年的回忆和经验，2022一定要，不负自己对自己的期望。</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Essay-03</title>
    <link href="/2021/12/27/essay-03/"/>
    <url>/2021/12/27/essay-03/</url>
    
    <content type="html"><![CDATA[<h3 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h3><p>今年的考研终于是结束了。</p><p>上年失利虽然有很多因素，但确实自己不敢说尽力了。本来以为要考，回校后又以为能保，松懈了。学校安排变化导致名额缩减了没保上，去年真正努力开始准备，也可能只能从10月开始算吧。</p><p>今年毕业回家，准备实话说比起在学校里更多的是孤独和苦闷，但感谢一直以来的好友和同学们，在我需要发泄需要鼓励的时候陪伴我，鼓励我。另外也很感恩父母开明和支持，减轻了我思想上的负担。</p><p>考前各位同学友人和我珍视的人给我的鼓励和祝福，真切地让我感觉到其实一直以来我都不是一个人，这种精神上的纽带给予了我莫大的喜悦和感动。</p><p>总归是又告一段落了，还得继续向前，希望这次能够得偿所愿了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-12-27 每日一题</title>
    <link href="/2021/12/27/2021.12.27%20daily%20problem/"/>
    <url>/2021/12/27/2021.12.27%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="825-适龄的朋友"><a href="#825-适龄的朋友" class="headerlink" title="825. 适龄的朋友"></a><a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></h4><p>难度中等</p><p>在社交媒体网站上有 <code>n</code> 个用户。给你一个整数数组 <code>ages</code> ，其中 <code>ages[i]</code> 是第 <code>i</code> 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 <code>x</code> 将不会向用户 <code>y</code>（<code>x != y</code>）发送好友请求：</p><ul><li><code>age[y] &lt;= 0.5 * age[x] + 7</code></li><li><code>age[y] &gt; age[x]</code></li><li><code>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</code></li></ul><p>否则，<code>x</code> 将会向 <code>y</code> 发送一条好友请求。</p><p>注意，如果 <code>x</code> 向 <code>y</code> 发送一条好友请求，<code>y</code> 不必也向 <code>x</code> 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：ages </span>=<span class="hljs-string"> [16,16]</span><br><span class="hljs-string">输出：2</span><br><span class="hljs-string">解释：2 人互发好友请求。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：ages = [16,17,18]<br>输出：2<br>解释：产生的好友请求为<span class="hljs-number"> 17 </span>-&gt;<span class="hljs-number"> 16 </span>，18 -&gt;<span class="hljs-number"> 17 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：ages = [20,30,100,110,120]<br>输出：3<br>解释：产生的好友请求为<span class="hljs-number"> 110 </span>-&gt;<span class="hljs-number"> 100 </span>，120 -&gt;<span class="hljs-number"> 110 </span>，120 -&gt;<span class="hljs-number"> 100 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ages.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>1 &lt;= ages[i] &lt;= 120</code></li></ul></li></ul><h2 id="方法一：排序-双下标夹逼"><a href="#方法一：排序-双下标夹逼" class="headerlink" title="方法一：排序+双下标夹逼"></a>方法一：排序+双下标夹逼</h2><p>考完研，复健第一天。</p><p>一开始当然是用最暴力的办法做n平方遍历，不出意料超时了。</p><p>想办法如何减少计算量，后来观察仔细观察题目的关系，就想这会不会是数学题。对于下面三个条件。其实可以发现条件二是包含条件三的，所以我们只需要保证条件二。</p><ul><li><code>age[y] &lt;= 0.5 * age[x] + 7</code></li><li><code>age[y] &gt; age[x]</code></li><li><code>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100</code></li></ul><p>所以只要满足，<code>0.5 * age[x] + 7 &lt; age[y] &lt;= age[x]</code>。则x就会向y发送一条信息。而要令这个区间存在，age[x]必须大于等于15 。</p><p>于是对于每个大于等于15的x，找出符合条件的left下界和right上界，中间的y即是x可以发送的对象。而x必定在区间内，所以right - left（已经是实际的区间长度-1了）就是每一轮循环的结果了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numFriendRequests</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ages)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = ages.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(ages.<span class="hljs-built_in">begin</span>(), ages.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> a:ages)&#123;<br>            <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">15</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<br>            <span class="hljs-keyword">while</span>(ages[left]&lt;=<span class="hljs-number">0.5</span>*a+<span class="hljs-number">7</span>)&#123;<br>                ++left;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(right+<span class="hljs-number">1</span>&lt;n&amp;&amp;ages[right+<span class="hljs-number">1</span>]&lt;=a)&#123;<br>                ++right;<br>            &#125;<br>            total += right - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Essay-02</title>
    <link href="/2021/10/09/essay-02/"/>
    <url>/2021/10/09/essay-02/</url>
    
    <content type="html"><![CDATA[<h3 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h3><p>博客从今天开始就断更了。</p><p>因为总要惦记着今天的题怎么做感觉还是有点分心，最后剩下的80日全力准备，希望一切顺利。</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-08 每日一题</title>
    <link href="/2021/10/08/2021.10.8%20daily%20problem/"/>
    <url>/2021/10/08/2021.10.8%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h4><p>难度中等</p><p>所有 DNA 都由一系列缩写为 <code>&#39;A&#39;</code>，<code>&#39;C&#39;</code>，<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 的核苷酸组成，例如：<code>&quot;ACGAATTCCG&quot;</code>。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 <code>s</code> 中出现次数超过一次。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br>输出：[<span class="hljs-string">&quot;AAAAACCCCC&quot;</span>,<span class="hljs-string">&quot;CCCCCAAAAA&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AAAAAAAAAAAAA&quot;</span><br>输出：[<span class="hljs-string">&quot;AAAAAAAAAA&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 10^5</code></li><li><code>s[i]</code> 为 <code>&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 或 <code>&#39;T&#39;</code></li></ul></li></ul><h2 id="方法一：哈希"><a href="#方法一：哈希" class="headerlink" title="方法一：哈希"></a>方法一：哈希</h2><p>吃早餐的时候还以为不能直接拆开遍历，怕爆内存。</p><p>中午回来一看数据量就一万个字符，抱着试试看的心态用哈希表统计所有可能的字符串出现次数；</p><p>秒了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; ma;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n<span class="hljs-number">-10</span>;i++)&#123;<br>            ma[s.<span class="hljs-built_in">substr</span>(i,<span class="hljs-number">10</span>)]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = ma.<span class="hljs-built_in">begin</span>();i!=ma.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second&gt;<span class="hljs-number">1</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(i-&gt;first);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-07 每日一题</title>
    <link href="/2021/10/07/2021.10.7%20daily%20problem/"/>
    <url>/2021/10/07/2021.10.7%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. 字符串中的单词数</a></h4><p>难度简单</p><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;Hello, my name is John&quot;</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>秒了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSegments</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">length</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;s[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            ans++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-02 每日一题</title>
    <link href="/2021/10/06/2021.10.2%20daily%20problem/"/>
    <url>/2021/10/06/2021.10.2%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h4><p>难度简单</p><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin">补码运算</a> 方法。</p><p><strong>注意:</strong></p><ol><li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li><li>给定的数确保在32位有符号整数范围内。</li><li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li></ol><p><strong>示例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>26<br><br><span class="hljs-section">输出:</span><br><span class="hljs-string">&quot;1a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>-1<br><br><span class="hljs-section">输出:</span><br><span class="hljs-string">&quot;ffffffff&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h2><p>在补码运算中，最高位表示符号位，符号位是 0 表示正整数和零，符号位是 1 表示负整数。32 位有符号整数的二进制数有 32 位，由于一位十六进制数对应四位二进制数，因此 32 位有符号整数的十六进制数有 8 位。将 num 的二进制数按照四位一组分成 8 组，依次将每一组转换为对应的十六进制数，即可得到 num 的十六进制数。</p><p>假设二进制数的 8 组从低位到高位依次是第 0 组到第 7 组，则对于第 i 组，可以通过 (nums&gt;&gt;(4×i)) &amp; 0xf 得到该组的值，其取值范围是 0 到 15（即十六进制的 f）。将每一组的值转换为十六进制数的做法如下：</p><p>对于 0 到 9，数字本身就是十六进制数；</p><p>对于 10 到 15，将其转换为 a 到 f 中的对应字母。</p><p>对于负整数，由于最高位一定不是00，因此不会出现前导零。对于零和正整数，可能出现前导零。避免前导零的做法如下：</p><p>如果 num&#x3D;0，则直接返回 0；</p><p>如果 num&gt;0，则在遍历每一组的值时，从第一个不是 0 的值开始拼接成十六进制数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        string sb;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">7</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">int</span> val = (num &gt;&gt; (<span class="hljs-number">4</span> * i)) &amp; <span class="hljs-number">0xf</span>;<br>            <span class="hljs-keyword">if</span> (sb.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span> || val &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">char</span> digit = val &lt; <span class="hljs-number">10</span> ? (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;0&#x27;</span> + val) : (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + val - <span class="hljs-number">10</span>);<br>                sb.<span class="hljs-built_in">push_back</span>(digit);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-03 每日一题</title>
    <link href="/2021/10/06/2021.10.3%20daily%20problem/"/>
    <url>/2021/10/06/2021.10.3%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166. 分数到小数"></a><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">166. 分数到小数</a></h4><p>难度中等</p><p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p><p>如果小数部分为循环小数，则将循环的部分括在括号内。</p><p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p><p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 <code>104</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numerator</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">denominator</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;0.5&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numerator</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">denominator</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numerator</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">denominator</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;0.(6)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numerator</span> = <span class="hljs-number">4</span>, <span class="hljs-attr">denominator</span> = <span class="hljs-number">333</span><br>输出：<span class="hljs-string">&quot;0.(012)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">numerator</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">denominator</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-string">&quot;0.2&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= numerator, denominator &lt;= 231 - 1</code></li><li><code>denominator != 0</code></li></ul><p>通过次数40,679</p><p>提交次数123,094</p></li></ul><h2 id="方法一：长除法"><a href="#方法一：长除法" class="headerlink" title="方法一：长除法"></a>方法一：长除法</h2><p><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">https://leetcode-cn.com/problems/fraction-to-recurring-decimal/</a></p><p>偷懒去烧烤，答案去原题看吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//小数部分如果余数出现两次就表示该小数是循环小数了</span><br>    <span class="hljs-function">string <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator, <span class="hljs-type">int</span> denominator)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(denominator==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">//边界条件，分母为0</span><br>        <span class="hljs-keyword">if</span>(numerator==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-comment">//边界条件，分子为0</span><br>        string result;<br>        <br>        <span class="hljs-comment">//转换为longlong防止溢出</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> num = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(numerator);<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> denom = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(denominator);<br>        <br>        <span class="hljs-comment">//处理正负号，一正一负取负号</span><br>        <span class="hljs-keyword">if</span>((num&gt;<span class="hljs-number">0</span>)^(denom&gt;<span class="hljs-number">0</span>))result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>        <br>        <span class="hljs-comment">//分子分母全部转换为正数</span><br>        num=<span class="hljs-built_in">llabs</span>(num);denom=<span class="hljs-built_in">llabs</span>(denom);<br>        <br>        <span class="hljs-comment">//处理整数部分</span><br>        result.<span class="hljs-built_in">append</span>(<span class="hljs-built_in">to_string</span>(num/denom));<br>        <br>        <span class="hljs-comment">//处理小数部分</span><br>        num%=denom;                         <span class="hljs-comment">//获得余数</span><br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> result;             <span class="hljs-comment">//余数为0，表示整除了，直接返回结果</span><br>        result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);              <span class="hljs-comment">//余数不为0，添加小数点</span><br>        <span class="hljs-type">int</span> index=result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;          <span class="hljs-comment">//获得小数点的下标</span><br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; record;      <span class="hljs-comment">//map用来记录出现重复数的下标，然后将&#x27;(&#x27;插入到重复数前面就好了</span><br>        <span class="hljs-keyword">while</span>(num&amp;&amp;record.<span class="hljs-built_in">count</span>(num)==<span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//小数部分：余数不为0且余数还没有出现重复数字</span><br>            record[num]=++index;<br>            num*=<span class="hljs-number">10</span>;                        <span class="hljs-comment">//余数扩大10倍，然后求商，和草稿本上运算方法是一样的</span><br>            result+=<span class="hljs-built_in">to_string</span>(num/denom);<br>            num%=denom;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(record.<span class="hljs-built_in">count</span>(num)==<span class="hljs-number">1</span>)&#123;           <span class="hljs-comment">//出现循环余数，我们直接在重复数字前面添加&#x27;(&#x27;,字符串末尾添加&#x27;)&#x27;</span><br>            result.<span class="hljs-built_in">insert</span>(record[num],<span class="hljs-string">&quot;(&quot;</span>);<br>            result.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-04 每日一题</title>
    <link href="/2021/10/06/2021.10.4%20daily%20problem/"/>
    <url>/2021/10/06/2021.10.4%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="482. 密钥格式化"></a><a href="https://leetcode-cn.com/problems/license-key-formatting/">482. 密钥格式化</a></h4><p>难度简单</p><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p><p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p><p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p><p><strong>示例 1：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">输入：<span class="hljs-variable">S</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;5F3Z-2e-9-w&quot;</span><span class="hljs-operator">,</span> <span class="hljs-built_in">K</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>输出：<span class="hljs-string">&quot;5F3Z-2E9W&quot;</span><br>解释：字符串 <span class="hljs-variable">S</span> 被分成了两个部分，每部分 <span class="hljs-number">4</span> 个字符；<br>     注意，两个额外的破折号需要删掉。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：S = &quot;2<span class="hljs-string">-5</span>g<span class="hljs-string">-3</span>-J&quot;, K = 2<br>输出：&quot;2<span class="hljs-string">-5</span>G<span class="hljs-string">-3</span>J&quot;<br>解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li>S 的长度可能很长，请按需分配大小。K 为正整数。</li><li>S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-‘</li><li>S 非空</li></ol></li></ul><h2 id="方法一：数学"><a href="#方法一：数学" class="headerlink" title="方法一：数学"></a>方法一：数学</h2><p>首先我们取出所有不为破折号的字符，题目要求对取出的字符进行重新分组，使得每个分组恰好包含 k 个字符，且必须满足第一个分组包含的字符个数必须小于等于 k，但至少要包含 1 个字符。设已经取出的字符的总数为 n，只需满足第一个分组包含的字符数目刚好等于 n mod k，剩余的分组包含的字符数目刚好等于 k。</p><p>我们可以从字符串 s 的末尾开始往前取出字符构建新的字符串 ans。每次取出字符时首先判断该字符是否为破折号，如果为破折号则跳过；否则将当前的字符计数 cnt 加 1，同时检查如果当前字符为小写字母则将其转化为大写字母，将当前字符加入到字符串 ans 的末尾。<br>对字符进行计数时，每隔 k 个字符就在字符串 ans 中添加一个破折号。特殊情况需要处理，字符串 ans 的最后一个字符为破折号则将其去掉。<br>我们对已经构建的字符串 ans 进行反转即为返回结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">licenseKeyFormatting</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">toupper</span>(s[i]));<br>                cnt++;<br>                <span class="hljs-keyword">if</span> (cnt % k == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>                &#125;  <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; ans.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            ans.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-05 每日一题</title>
    <link href="/2021/10/06/2021.10.5%20daily%20problem/"/>
    <url>/2021/10/06/2021.10.5%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="284-顶端迭代器"><a href="#284-顶端迭代器" class="headerlink" title="284. 顶端迭代器"></a><a href="https://leetcode-cn.com/problems/peeking-iterator/">284. 顶端迭代器</a></h4><p>难度中等</p><p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p><p>实现 <code>PeekingIterator</code> 类：</p><ul><li><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。</li><li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li><li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li></ul><p><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;PeekingIterator&quot;</span>, <span class="hljs-string">&quot;next&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;next&quot;</span>, <span class="hljs-string">&quot;next&quot;</span>, <span class="hljs-string">&quot;hasNext&quot;</span>]<br>[[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]], [], [], [], [], []]<br>输出：<br>[null, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, false]<br><br>解释：<br><span class="hljs-symbol">PeekingIterator</span> peekingIterator = new <span class="hljs-symbol">PeekingIterator</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); // [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>peekingIterator.next();    // 返回 <span class="hljs-number">1</span> ，指针移动到下一个元素 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>peekingIterator.peek();    // 返回 <span class="hljs-number">2</span> ，指针未发生移动 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>peekingIterator.next();    // 返回 <span class="hljs-number">2</span> ，指针移动到下一个元素 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>peekingIterator.next();    // 返回 <span class="hljs-number">3</span> ，指针移动到下一个元素 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>peekingIterator.hasNext(); // 返回 <span class="hljs-symbol">False</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li>对 <code>next</code> 和 <code>peek</code> 的调用均有效</li><li><code>next</code>、<code>hasNext</code> 和 <code>peek </code>最多调用 <code>1000</code> 次</li></ul><p><strong>进阶：</strong>你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p></li></ul><h2 id="方法一：迭代器"><a href="#方法一：迭代器" class="headerlink" title="方法一：迭代器"></a>方法一：迭代器</h2><p>放假，偷懒。</p><p>方法一：迭代器<br>最直观的做法是使用一个列表存储迭代器中的每个元素，然后按顺序遍历列表中的元素模拟迭代器，但是该做法没有利用到迭代器的性质，更好的做法是利用迭代器的性质实现顶端迭代器的操作。</p><p>顶端迭代器需要实现以下三种操作：</p><p>next：返回迭代器的下一个元素，并将指针向后移动一位；</p><p>hasNext：判断迭代器中是否还有剩余的元素；</p><p>peek：返回迭代器的下一个元素，不改变指针。</p><p>每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。</p><p>Java 的 Iterator 接口和 JavaScript 中自定义的 Iterator 接口支持 next 和 hasNext 操作，但是不支持 peek 操作。为了在顶端迭代器中支持 peek 操作，需要使用 nextElement 存储迭代器的下一个元素，各项操作的实现如下：</p><p>next：首先用 ret 存储 nextElement 表示返回值，然后将 nextElement 向后移动一位，最后返回 ret；</p><p>hasNext：由于 nextElement 为迭代器的下一个元素，因此当 nextElement 不为空时返回 true，否则返回 false；</p><p>peek：由于 peek 操作不改变指针，因此返回 nextElement。</p><p>C# 的 IEnumerator 接口包含属性 Current 和方法 MoveNext（该方法的返回值类型是 bool，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用 flag 存储迭代器是否还有剩余的元素。</p><p>next：首先用ret 存储 .iterator.Current 表示返回值，然后对 iterator 调用 MoveNext 方法使其向后移动一位并将该方法的结果赋值给 flag，最后返回 ret；</p><p>hasNext：返回 flag；</p><p>peek：由于 peek 操作不改变指针，因此返回 iterator.Current。</p><p>C++ 中 PeekingIterator 继承父类 Iterator，Iterator 已经实现方法 next 和 hasNext，在此我们在 PeekingIterator 中主要实现 peek 方法即可。我们使用 flag 标记迭代器是否还有剩余元素，使用 nextElement 存储迭代器的下一个元素。</p><p>next：首先用 ret 存储 nextElement 表示返回值，flag 保存 Iterator 调用 hasNext方法的返回结果，然后将 nextElement 向后移动一位，最后返回 ret；</p><p>hasNext：返回 flag；</p><p>peek：由于 peek 操作不改变指针，因此返回 nextElement。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=s.<span class="hljs-built_in">begin</span>();i!=s.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-type">int</span> x = *i;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(x&gt;q.<span class="hljs-built_in">top</span>())&#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">push</span>(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">int</span> max = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(max&lt;q.<span class="hljs-built_in">top</span>())&#123;<br>                    max = q.<span class="hljs-built_in">top</span>();<br>                &#125;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-06 每日一题</title>
    <link href="/2021/10/06/2021.10.6%20daily%20problem/"/>
    <url>/2021/10/06/2021.10.6%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode-cn.com/problems/third-maximum-number/">414. 第三大的数</a></h4><p>难度简单</p><p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3, 2, 1]</span><br>输出：<span class="hljs-number">1</span><br>解释：第三大的数是 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1, 2]</span><br>输出：<span class="hljs-number">2</span><br>解释：第三大的数不存在, 所以返回最大的数 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2, 2, 3, 1]<br>输出：1<br>解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。<br>此例中存在两个值为<span class="hljs-number"> 2 </span>的数，它们都排第二。在所有不同数字中排第三大的数为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能设计一个时间复杂度 <code>O(n)</code> 的解决方案吗？</p></li></ul><h2 id="方法一：优先队列"><a href="#方法一：优先队列" class="headerlink" title="方法一：优先队列"></a>方法一：优先队列</h2><p>一开始以为直接优先队列就可以了，结果看了测例才发现是要去重，那就多家一步集合去重吧，时间复杂度仍然是O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=s.<span class="hljs-built_in">begin</span>();i!=s.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-type">int</span> x = *i;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(x&gt;q.<span class="hljs-built_in">top</span>())&#123;<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    q.<span class="hljs-built_in">push</span>(x);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-type">int</span> max = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">if</span>(max&lt;q.<span class="hljs-built_in">top</span>())&#123;<br>                    max = q.<span class="hljs-built_in">top</span>();<br>                &#125;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> max;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-10-01 每日一题</title>
    <link href="/2021/10/01/2021.10.1%20daily%20problem/"/>
    <url>/2021/10/01/2021.10.1%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1436-旅行终点站"><a href="#1436-旅行终点站" class="headerlink" title="1436. 旅行终点站"></a><a href="https://leetcode-cn.com/problems/destination-city/">1436. 旅行终点站</a></h4><p>难度简单56</p><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p><p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：paths = [[<span class="hljs-string">&quot;London&quot;</span>,<span class="hljs-string">&quot;New York&quot;</span>],[<span class="hljs-string">&quot;New York&quot;</span>,<span class="hljs-string">&quot;Lima&quot;</span>],[<span class="hljs-string">&quot;Lima&quot;</span>,<span class="hljs-string">&quot;Sao Paulo&quot;</span>]]<br>输出：<span class="hljs-string">&quot;Sao Paulo&quot;</span> <br>解释：从 <span class="hljs-string">&quot;London&quot;</span> 出发，最后抵达终点站 <span class="hljs-string">&quot;Sao Paulo&quot;</span> 。本次旅行的路线是 <span class="hljs-string">&quot;London&quot;</span> -&gt; <span class="hljs-string">&quot;New York&quot;</span> -&gt; <span class="hljs-string">&quot;Lima&quot;</span> -&gt; <span class="hljs-string">&quot;Sao Paulo&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：paths = [[<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>],[<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>],[<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]]<br>输出：<span class="hljs-string">&quot;A&quot;</span><br>解释：所有可能的线路是：<br><span class="hljs-string">&quot;D&quot;</span> -&gt; <span class="hljs-string">&quot;B&quot;</span> -&gt; <span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>. <br><span class="hljs-string">&quot;B&quot;</span> -&gt; <span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>. <br><span class="hljs-string">&quot;C&quot;</span> -&gt; <span class="hljs-string">&quot;A&quot;</span>. <br><span class="hljs-string">&quot;A&quot;</span>. <br>显然，旅行终点站是 <span class="hljs-string">&quot;A&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：paths = <span class="hljs-string">[[&quot;A&quot;,&quot;Z&quot;]]</span><br>输出：<span class="hljs-string">&quot;Z&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= paths.length &lt;= 100</code></li><li><code>paths[i].length == 2</code></li><li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li><li><code>cityAi != cityBi</code></li><li>所有字符串均由大小写英文字母和空格字符组成。</li></ul></li></ul><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>因为题目给出的路线是单向的，所以做题的时候建立哈希表就只是单个方向的，标记某个城市的next城市就可以。</p><p>那么终点很明显，就是”没有next城市“的城市。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">destCity</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; paths)</span> </span>&#123;<br>        unordered_map&lt;string,string&gt; route;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p :paths)&#123;<br>            route[p[<span class="hljs-number">0</span>]] = p[<span class="hljs-number">1</span>];<br>        &#125;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:paths)&#123;<br>            <span class="hljs-keyword">if</span>(route[p[<span class="hljs-number">1</span>]]==<span class="hljs-string">&quot;&quot;</span>)&#123;<br>                ans = p[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-30 每日一题</title>
    <link href="/2021/09/30/2021.9.30%20daily%20problem/"/>
    <url>/2021/09/30/2021.9.30%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="223-矩形面积"><a href="#223-矩形面积" class="headerlink" title="223. 矩形面积"></a><a href="https://leetcode-cn.com/problems/rectangle-area/">223. 矩形面积</a></h4><p>难度中等130</p><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong> 矩形，请你计算并返回两个矩形覆盖的总面积。</p><p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p><ul><li>第一个矩形由其左下顶点 <code>(ax1, ay1)</code> 和右上顶点 <code>(ax2, ay2)</code> 定义。</li><li>第二个矩形由其左下顶点 <code>(bx1, by1)</code> 和右上顶点 <code>(bx2, by2)</code> 定义。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png" alt="Rectangle Area"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：ax1 = -<span class="hljs-number">3</span>, ay1 = <span class="hljs-number">0</span>, ax2 = <span class="hljs-number">3</span>, ay2 = <span class="hljs-number">4</span>, <span class="hljs-keyword">bx1 </span>= <span class="hljs-number">0</span>, <span class="hljs-keyword">by1 </span>= -<span class="hljs-number">1</span>, <span class="hljs-keyword">bx2 </span>= <span class="hljs-number">9</span>, <span class="hljs-keyword">by2 </span>= <span class="hljs-number">2</span><br>输出：<span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：ax1 = -<span class="hljs-number">2</span>, ay1 = -<span class="hljs-number">2</span>, ax2 = <span class="hljs-number">2</span>, ay2 = <span class="hljs-number">2</span>, <span class="hljs-keyword">bx1 </span>= -<span class="hljs-number">2</span>, <span class="hljs-keyword">by1 </span>= -<span class="hljs-number">2</span>, <span class="hljs-keyword">bx2 </span>= <span class="hljs-number">2</span>, <span class="hljs-keyword">by2 </span>= <span class="hljs-number">2</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-104 &lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 &lt;= 104</code></li></ul></li></ul><h2 id="方法一：直接法"><a href="#方法一：直接法" class="headerlink" title="方法一：直接法"></a>方法一：直接法</h2><p>9月最后一天终于有好做的题目了TAT</p><p>没什么好说的，就是按照给出的坐标算一个重合面积，然后检查两个矩形是否有重合；</p><p>如果重合就矩形面积相加减去重合部分，如果没有直接返回两个矩形面积的和。</p><p>检查重合的思路是以下公式：<br>$$<br>max(ay_1,by_1)&lt;min(ay_2,by_2) &amp; max(ax_1,bx_1)&lt;min(ax_2,bx_2)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">computeArea</span><span class="hljs-params">(<span class="hljs-type">int</span> ax1, <span class="hljs-type">int</span> ay1, <span class="hljs-type">int</span> ax2, <span class="hljs-type">int</span> ay2, <span class="hljs-type">int</span> bx1, <span class="hljs-type">int</span> by1, <span class="hljs-type">int</span> bx2, <span class="hljs-type">int</span> by2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(ax1,bx1);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">min</span>(ax2,bx2);<br>        <span class="hljs-type">int</span> top = <span class="hljs-built_in">min</span>(ay2,by2);<br>        <span class="hljs-type">int</span> bottom = <span class="hljs-built_in">max</span>(ay1,by1);<br>        <span class="hljs-type">int</span> overlay = (right-left)*(top-bottom);<br>        <span class="hljs-type">int</span> s1 = (ax2-ax1)*(ay2-ay1);<br>        <span class="hljs-type">int</span> s2 = (bx2-bx1)*(by2-by1);<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>(ay1,by1)&lt;<span class="hljs-built_in">min</span>(ay2,by2)&amp;&amp;<span class="hljs-built_in">max</span>(ax1,bx1)&lt;<span class="hljs-built_in">min</span>(ax2,bx2))&#123;<span class="hljs-comment">//检查是否重合</span><br>            <span class="hljs-keyword">return</span> s1+s2-overlay;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1+s2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-29 每日一题</title>
    <link href="/2021/09/29/2021.9.29%20daily%20problem/"/>
    <url>/2021/09/29/2021.9.29%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="517-超级洗衣机"><a href="#517-超级洗衣机" class="headerlink" title="517. 超级洗衣机"></a><a href="https://leetcode-cn.com/problems/super-washing-machines/">517. 超级洗衣机</a></h4><p>难度困难</p><p>假设有 <code>n</code> 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p><p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p><p>给定一个整数数组 <code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数</strong> 。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：machines = [1,0,5]<br>输出：3<br>解释：<br>第一步:   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 0 </span>&lt;--<span class="hljs-number"> 5 </span>   =&gt;   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>    4<br>第二步:   <span class="hljs-number"> 1 </span>&lt;--<span class="hljs-number"> 1 </span>&lt;--<span class="hljs-number"> 4 </span>   =&gt;   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 3 </span>   <br>第三步:   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 1 </span>&lt;--<span class="hljs-number"> 3 </span>   =&gt;   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 2 </span>  <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：machines = [0,3,0]<br>输出：2<br>解释：<br>第一步:   <span class="hljs-number"> 0 </span>&lt;--<span class="hljs-number"> 3 </span>   <span class="hljs-number"> 0 </span>   =&gt;   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 2 </span>   <span class="hljs-number"> 0 </span>   <br>第二步:   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 2 </span>--&gt;<span class="hljs-number"> 0 </span>   =&gt;   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>    <br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：machines </span>=<span class="hljs-string"> [0,2,0]</span><br><span class="hljs-string">输出：-1</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">不可能让所有三个洗衣机同时剩下相同数量的衣物。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == machines.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= machines[i] &lt;= 105</code></li></ul></li></ul><h2 id="方法一：贪心"><a href="#方法一：贪心" class="headerlink" title="方法一：贪心"></a>方法一：贪心</h2><p>注意在做题的时候，留意题目给出来模型的数学关系，这样才不至于往错误的方向思考。</p><p>设所有洗衣机内的衣服个数之和为 tot，要使最终所有洗衣机内的衣服个数相同，那么 }tot 必须是 n 的倍数，否则我们直接返回 −1。</p><p>$$<br>记 \textit{avg}&#x3D;\dfrac{\textit{tot}}{n}</p><p> ，定义 \textit{machines}[i]’&#x3D;\textit{machines}[i]-\textit{avg}，\<br> 若 \textit{machines}[i]’<br>  为正则说明需要移出 \textit{machines}[i]’<br>  件衣服，为负则说明需要移入 -\textit{machines}[i]’<br>  件衣服。<br>$$<br>将前 ii 台洗衣机看成一组，记作 A，其余洗衣机看成另一组，记作 B。<br>$$<br>设 \textit{sum}[i]&#x3D;\sum_{j&#x3D;0}^i \textit{machines}[j]’\<br> ，若 \textit{sum}[i] 为正则说明需要从 A 向 B 移入 \textit{sum}[i] 件衣服，为负则说明需要从 B 向 A 移入 -\textit{sum}[i] 件衣服。<br>$$<br>我们分两种情况来考虑操作步数：</p><p>A 与 B 两组之间的衣服，最多需要<br>$$<br>\max_{i&#x3D;0}^{n-1}|\textit{sum}[i]|<br>$$<br> 次衣服移动；<br>组内的某一台洗衣机内的衣服数量过多，需要向左右两侧移出衣服，这最多需要<br>$$<br>\max_{i&#x3D;0}^{n-1}\textit{machines}[i]’<br>$$<br>  次衣服移动。<br>取两者的最大值即为答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;machines)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-built_in">accumulate</span>(machines.<span class="hljs-built_in">begin</span>(), machines.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> n = machines.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (tot % n) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> avg = tot / n;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: machines) &#123;<br>            num -= avg;<br>            sum += num;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(sum), num));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-27 每日一题</title>
    <link href="/2021/09/28/2021.9.27%20daily%20problem/"/>
    <url>/2021/09/28/2021.9.27%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="639-解码方法-II"><a href="#639-解码方法-II" class="headerlink" title="639. 解码方法 II"></a><a href="https://leetcode-cn.com/problems/decode-ways-ii/">639. 解码方法 II</a></h4><p>难度困难</p><p>一条包含字母 <code>A-Z</code> 的消息通过以下的方式进行了编码：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">2</span><br>...<br><span class="hljs-string">&#x27;Z&#x27;</span> -&gt; <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>要 <strong>解码</strong> 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> 对应分组 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> 对应分组 <code>(11 10 6)</code></li></ul><p>注意，像 <code>(1 11 06)</code> 这样的分组是无效的，因为 <code>&quot;06&quot;</code> 不可以映射为 <code>&#39;F&#39;</code> ，因为 <code>&quot;6&quot;</code> 与 <code>&quot;06&quot;</code> 不同。</p><p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含 <code>&#39;*&#39;</code> 字符，可以表示从 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 的任一数字（不包括 <code>&#39;0&#39;</code>）。例如，编码字符串 <code>&quot;1*&quot;</code> 可以表示 <code>&quot;11&quot;</code>、<code>&quot;12&quot;</code>、<code>&quot;13&quot;</code>、<code>&quot;14&quot;</code>、<code>&quot;15&quot;</code>、<code>&quot;16&quot;</code>、<code>&quot;17&quot;</code>、<code>&quot;18&quot;</code> 或 <code>&quot;19&quot;</code> 中的任意一条消息。对 <code>&quot;1*&quot;</code> 进行解码，相当于解码该字符串可以表示的任何编码消息。</p><p>给你一个字符串 <code>s</code> ，由数字和 <code>&#39;*&#39;</code> 字符组成，返回 <strong>解码</strong> 该字符串的方法 <strong>数目</strong> 。</p><p>由于答案数目可能非常大，返回对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;*&quot;</span><br>输出：<span class="hljs-number">9</span><br>解释：这一条编码消息可以表示 <span class="hljs-string">&quot;1&quot;</span>、<span class="hljs-string">&quot;2&quot;</span>、<span class="hljs-string">&quot;3&quot;</span>、<span class="hljs-string">&quot;4&quot;</span>、<span class="hljs-string">&quot;5&quot;</span>、<span class="hljs-string">&quot;6&quot;</span>、<span class="hljs-string">&quot;7&quot;</span>、<span class="hljs-string">&quot;8&quot;</span> 或 <span class="hljs-string">&quot;9&quot;</span> 中的任意一条。<br>可以分别解码成字符串 <span class="hljs-string">&quot;A&quot;</span>、<span class="hljs-string">&quot;B&quot;</span>、<span class="hljs-string">&quot;C&quot;</span>、<span class="hljs-string">&quot;D&quot;</span>、<span class="hljs-string">&quot;E&quot;</span>、<span class="hljs-string">&quot;F&quot;</span>、<span class="hljs-string">&quot;G&quot;</span>、<span class="hljs-string">&quot;H&quot;</span> 和 <span class="hljs-string">&quot;I&quot;</span> 。<br>因此，<span class="hljs-string">&quot;*&quot;</span> 总共有 <span class="hljs-number">9</span> 种解码方法。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1*&quot;</span><br>输出：<span class="hljs-number">18</span><br>解释：这一条编码消息可以表示 <span class="hljs-string">&quot;11&quot;</span>、<span class="hljs-string">&quot;12&quot;</span>、<span class="hljs-string">&quot;13&quot;</span>、<span class="hljs-string">&quot;14&quot;</span>、<span class="hljs-string">&quot;15&quot;</span>、<span class="hljs-string">&quot;16&quot;</span>、<span class="hljs-string">&quot;17&quot;</span>、<span class="hljs-string">&quot;18&quot;</span> 或 <span class="hljs-string">&quot;19&quot;</span> 中的任意一条。<br>每种消息都可以由 <span class="hljs-number">2</span> 种方法解码（例如，<span class="hljs-string">&quot;11&quot;</span> 可以解码成 <span class="hljs-string">&quot;AA&quot;</span> 或 <span class="hljs-string">&quot;K&quot;</span>）。<br>因此，<span class="hljs-string">&quot;1*&quot;</span> 共有 <span class="hljs-number">9</span> * <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span> 种解码方法。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;2*&quot;</span><br>输出：<span class="hljs-number">15</span><br>解释：这一条编码消息可以表示 <span class="hljs-string">&quot;21&quot;</span>、<span class="hljs-string">&quot;22&quot;</span>、<span class="hljs-string">&quot;23&quot;</span>、<span class="hljs-string">&quot;24&quot;</span>、<span class="hljs-string">&quot;25&quot;</span>、<span class="hljs-string">&quot;26&quot;</span>、<span class="hljs-string">&quot;27&quot;</span>、<span class="hljs-string">&quot;28&quot;</span> 或 <span class="hljs-string">&quot;29&quot;</span> 中的任意一条。<br><span class="hljs-string">&quot;21&quot;</span>、<span class="hljs-string">&quot;22&quot;</span>、<span class="hljs-string">&quot;23&quot;</span>、<span class="hljs-string">&quot;24&quot;</span>、<span class="hljs-string">&quot;25&quot;</span> 和 <span class="hljs-string">&quot;26&quot;</span> 由 <span class="hljs-number">2</span> 种解码方法，但 <span class="hljs-string">&quot;27&quot;</span>、<span class="hljs-string">&quot;28&quot;</span> 和 <span class="hljs-string">&quot;29&quot;</span> 仅有 <span class="hljs-number">1</span> 种解码方法。<br>因此，<span class="hljs-string">&quot;2*&quot;</span> 共有 <span class="hljs-comment">(6 * 2)</span> + <span class="hljs-comment">(3 * 1)</span> = <span class="hljs-number">12</span> + <span class="hljs-number">3</span> = <span class="hljs-number">15</span> 种解码方法。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 是 <code>0 - 9</code> 中的一位数字或字符 <code>&#39;*&#39;</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>困难，摸了。</p><p>对于给定的字符串 s，设它的长度为 n，其中的字符从左到右依次为 s[1],s[2],⋯,s[n]。我们可以使用动态规划的方法计算出字符串 s 的解码方法数。</p><p>具体地，设<br>$$<br>f_i<br>$$<br>  表示字符串 s 的前 i 个字符 s[1..i] 的解码方法数。在进行状态转移时，我们可以考虑最后一次解码使用了 s 中的哪些字符，那么会有下面的两种情况：</p><p>第一种情况是我们使用了一个字符，即 s[i] 进行解码，那么：</p><p>如果 s[i] 为 ∗，那么它对应着 [1, 9][1,9] 中的任意一种编码，有 9 种方案。因此状态转移方程为：<br>$$<br>f_i &#x3D; 9 \times f_{i-1}<br>$$</p><p>如果 s[i] 为 0，那么它无法被解码。因此状态转移方程为：<br>$$<br>f_i &#x3D; 0<br>$$</p><p>对于其它的情况，s[i]∈[1,9]，分别对应一种编码。因此状态转移方程为：<br>$$<br>f_i &#x3D; f_{i-1}<br>$$<br>第二种情况是我们使用了两个字符，即 s[i−1] 和 s[i] 进行编码。与第一种情况类似，我们需要进行分类讨论：</p><p>如果 s[i−1] 和 s[i] 均为 ∗，那么它们对应着 [11,19][11,19] 以及 [21, 26][21,26] 中的任意一种编码，有 15 种方案。因此状态转移方程为：<br>$$<br>f_i &#x3D; 15 \times f_{i-2}<br>$$</p><p>如果仅有 s[i−1] 为 ∗，那么当 s[i]∈[0,6] 时，s[i−1] 可以选择 1 和 2；当s[i]∈[7,9] 时，s[i−1] 只能选择 1。因此状态转移方程为：<br>$$<br>f_i &#x3D; \begin{cases} 2 \times f_{i-2}, &amp; \quad s[i-1] \in [1, 6] \ f_{i-2}, &amp; \quad s[i-1] \in [7, 9] \end{cases}<br>$$</p><p>如果仅有 s[i] 为 ∗，那么当 s[i-1] 为 1 时，s[i] 可以在 [1, 9][1,9] 中进行选择；当 s[i−1] 为 2 时，s[i]s[i] 可以在 [1, 6][1,6] 中进行选择；对于其余情况，它们无法被解码。因此状态转移方程为：<br>$$<br>f_i &#x3D; \begin{cases} 9 \times f_{i-2}, &amp; \quad s[i] &#x3D; 1 \ 6 \times f_{i-2}, &amp; \quad s[i] &#x3D; 2 \ 0, &amp; \quad \text{otherwise} \end{cases}<br>$$</p><p>如果 s[i−1] 和 s[i] 均不为 ∗，那么只有 s[i−1] 不为 0 并且 s[i−1] 和 s[i] 组成的数字小于等于 26 时，它们才能被解码。因此状态转移方程为：<br>$$<br>f_i &#x3D; \begin{cases} f_{i-2}, &amp; \quad s[i-1] \neq 0 \wedge \overline{s[i-1]s[i]} \leq 26 \ 0, &amp; \quad \text{otherwise} \end{cases}<br>$$</p><p>将上面的两种状态转移方程在对应的条件满足时进行累加，即可得到<br>$$<br>f_i<br>$$<br>  的值。在动态规划完成后，最终的答案即为<br>$$<br>f_n<br>$$<br> 。</p><p>细节</p><p>动态规划的边界条件为：</p><p>$$<br>f_0 &#x3D; 1<br>$$<br>即空字符串可以有 1 种解码方法，解码出一个空字符串。</p><p>同时，由于在大部分语言中，字符串的下标是从 0 而不是 1 开始的，因此在代码的编写过程中，我们需要将所有字符串的下标减去 1，与使用的语言保持一致。</p><p>最终的状态转移方程可以写成：</p><p>$$<br>f_i &#x3D; \alpha \times f_{i-1} + \beta \times f_{i-2}<br>f<br>i</p><p>$$<br>的形式。为了使得代码更加易读，我们可以使用两个辅助函数，给定对应的一个或两个字符，分别计算出 α 和 β 的值。</p><p>$$<br>注意到在状态转移方程中，f_if</p><p>  的值仅与 f_{i-1}</p><p>  和 f_{i-2}<br>$$<br>  有关，因此我们可以使用三个变量进行状态转移，省去数组的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000000007</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> check1digit = [](<span class="hljs-type">char</span> ch) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ch == <span class="hljs-string">&#x27;*&#x27;</span> ? <span class="hljs-number">9</span> : <span class="hljs-number">1</span>;<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> check2digits = [](<span class="hljs-type">char</span> c0, <span class="hljs-type">char</span> c1) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (c0 == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; c1 == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">15</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c0 == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> c1 &lt;= <span class="hljs-string">&#x27;6&#x27;</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c1 == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (c0 == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (c0 == <span class="hljs-string">&#x27;2&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> c0 != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; (c0 - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (c1 - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// a = f[i-2], b = f[i-1], c = f[i]</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)b * <span class="hljs-built_in">check1digit</span>(s[i - <span class="hljs-number">1</span>]) % mod;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>                c = (c + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)a * <span class="hljs-built_in">check2digits</span>(s[i - <span class="hljs-number">2</span>], s[i - <span class="hljs-number">1</span>])) % mod;<br>            &#125;<br>            a = b;<br>            b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-28 每日一题</title>
    <link href="/2021/09/28/2021.9.28%20daily%20problem/"/>
    <url>/2021/09/28/2021.9.28%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h4><p>难度中等</p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">8</span><br>输出：<span class="hljs-number">3</span><br>解释：和等于 <span class="hljs-number">8</span> 的路径有 <span class="hljs-number">3</span> 条，如图所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">targetSum</span> = <span class="hljs-number">22</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,1000]</code></li><li><code>-109 &lt;= Node.val &lt;= 109</code> </li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul></li></ul><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>看到树，摸了。</p><p>我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p><p>我们首先定义 rootSum(p,val) 表示以节点 p 为起点向下且满足路径总和为 val 的路径数目。我们对二叉树上每个节点 p 求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。</p><p>我们对节点 p 求 rootSum(p,targetSum) 时，以当前节点 p 为目标路径的起点递归向下进行搜索。假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 pl  求出 rootSum(pl ,targetSum−val)，以及对右孩子节点 pr  求出 rootSum(pr ,targetSum−val)。节点 p 的 rootSum(p,targetSum) 即等于 rootSum(pl ,targetSum−val) 与 rootSum(pr ,targetSum−val) 之和，同时我们还需要判断一下当前节点 pp 的值是否刚好等于 targetSum。</p><p>我们采用递归遍历二叉树的每个节点 p，对节点 p求 rootSum(p,val)，然后将每个节点所有求的值进行相加求和返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rootSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == targetSum) &#123;<br>            ret++;<br>        &#125; <br><br>        ret += <span class="hljs-built_in">rootSum</span>(root-&gt;left, targetSum - root-&gt;val);<br>        ret += <span class="hljs-built_in">rootSum</span>(root-&gt;right, targetSum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">rootSum</span>(root, targetSum);<br>        ret += <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum);<br>        ret += <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-26 每日一题</title>
    <link href="/2021/09/26/2021.9.26%20daily%20problem/"/>
    <url>/2021/09/26/2021.9.26%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a></h4><p>难度中等</p><p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用</strong> 运算符 <code>+</code> 和 <code>-</code> ，计算并返回两整数之和。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">a</span> = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-1000 &lt;= a, b &lt;= 1000</code></li></ul></li></ul><h2 id="方法一：补码位运算"><a href="#方法一：补码位运算" class="headerlink" title="方法一：补码位运算"></a>方法一：补码位运算</h2><p>我以为是利用数据结构巧妙解决，没想到最后真的是补码运算。。。。</p><p>可以发现，对于整数 a 和 b：</p><p>在不考虑进位的情况下，其无进位加法结果为 a⊕b。</p><p>而所有需要进位的位为 a &amp; b，进位后的进位结果为 (a &amp; b) &lt;&lt; 1。</p><p>于是，我们可以将整数 a 和 b 的和，拆分为 a 和 b 的无进位加法结果与进位结果的和。因为每一次拆分都可以让需要进位的最低位至少左移一位，又因为 a 和 b 可以取到负数，所以我们最多需要log(max_int) 次拆分即可完成运算。</p><p>因为有符号整数用补码来表示，所以以上算法也可以推广到 0 和负数。</p><p>在 C++ 的实现中，当我们赋给带符号类型一个超出它表示范围的值时，结果是 undefined；而当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模的余数。因此，我们可以使用无符号类型来防止溢出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> carry = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<span class="hljs-comment">//用unsigned防溢出</span><br>            a = a ^ b;<br>            b = carry;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-25 每日一题</title>
    <link href="/2021/09/25/2021.9.25%20daily%20problem/"/>
    <url>/2021/09/25/2021.9.25%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p>难度中等682</p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abcde&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;ace&quot;</span> <br>输出：<span class="hljs-number">3</span>  <br>解释：最长公共子序列是 <span class="hljs-string">&quot;ace&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：最长公共子序列是 <span class="hljs-string">&quot;abc&quot;</span> ，它的长度为 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">text1</span> = <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">text2</span> = <span class="hljs-string">&quot;def&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：两个字符串没有公共子序列，返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></li></ul><h2 id="方法一：最长公共子序列"><a href="#方法一：最长公共子序列" class="headerlink" title="方法一：最长公共子序列"></a>方法一：最长公共子序列</h2><p>读完题目之后立马就想到了最长公共子序列（<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">典型的二维DP</a>）</p><p>问多少次修改次数，就是求出最长公共子序列后，用原长度与最长公共子序列的长度作差。</p><p>算出的即是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = text1.<span class="hljs-built_in">length</span>(), n = text2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>            <span class="hljs-type">char</span> c1 = text1.<span class="hljs-built_in">at</span>(i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-type">char</span> c2 = text2.<span class="hljs-built_in">at</span>(j - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-24 每日一题</title>
    <link href="/2021/09/24/2021.9.24%20daily%20problem/"/>
    <url>/2021/09/24/2021.9.24%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="430-扁平化多级双向链表"><a href="#430-扁平化多级双向链表" class="headerlink" title="430. 扁平化多级双向链表"></a><a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/">430. 扁平化多级双向链表</a></h4><p>难度中等</p><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p><p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nix"><br><br>扁平化后的链表如下图：<br><br>输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：<br><br></code></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png"></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png"></p><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>解释：<br><br>输入的多级列表如下图所示：<br><br>  <span class="hljs-number">1</span>---<span class="hljs-number">2</span>---<span class="hljs-literal">NULL</span><br>  <span class="hljs-string">|</span><br>  <span class="hljs-number">3</span>---<span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>如何表示测试用例中的多级链表？</strong></p><p>以 <strong>示例 1</strong> 为例：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">1</span><span class="hljs-literal">---</span><span class="hljs-comment">2</span><span class="hljs-literal">---</span><span class="hljs-comment">3</span><span class="hljs-literal">---</span><span class="hljs-comment">4</span><span class="hljs-literal">---</span><span class="hljs-comment">5</span><span class="hljs-literal">---</span><span class="hljs-comment">6</span><span class="hljs-literal">--</span><span class="hljs-comment">NULL</span><br>        <span class="hljs-comment">|</span><br>        <span class="hljs-comment">7</span><span class="hljs-literal">---</span><span class="hljs-comment">8</span><span class="hljs-literal">---</span><span class="hljs-comment">9</span><span class="hljs-literal">---</span><span class="hljs-comment">10</span><span class="hljs-literal">--</span><span class="hljs-comment">NULL</span><br>            <span class="hljs-comment">|</span><br>            <span class="hljs-comment">11</span><span class="hljs-literal">--</span><span class="hljs-comment">12</span><span class="hljs-literal">--</span><span class="hljs-comment">NULL</span><br></code></pre></td></tr></table></figure><p>序列化其中的每一级之后：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>]<br>[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>]<br>[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>]<br></code></pre></td></tr></table></figure><p>为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>]<br>[<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>]<br>[<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>]<br></code></pre></td></tr></table></figure><p>合并所有序列化结果，并去除末尾的 null 。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>节点数目不超过 1000</li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li></ul></li></ul><h2 id="方法一：试除"><a href="#方法一：试除" class="headerlink" title="方法一：试除"></a>方法一：试除</h2><p>鸽了，有一点复杂，思考的时候能想出来是深度优先搜索，但是传进来的链表存在连续的null，一时间又不知道该怎么把脑子里的东西用代码写出来了。。。。</p><p>当我们遍历到某个节点 node 时，如果它的 child 成员不为空，那么我们需要将 child 指向的链表结构进行扁平化，并且插入 node 与 node 的下一个节点之间。</p><p>因此，我们在遇到 child 成员不为空的节点时，就要先去处理 child 指向的链表结构，这就是一个「深度优先搜索」的过程。当我们完成了对 child 指向的链表结构的扁平化之后，就可以「回溯」到 node 节点。</p><p>为了能够将扁平化的链表插入 node 与 node 的下一个节点之间，我们需要知道扁平化的链表的最后一个节点 last，随后进行如下的三步操作：</p><p>将 node 与 node 的下一个节点 next 断开：</p><p>将 node 与 child 相连；</p><p>将 last 与 next 相连。</p><p>这样一来，我们就可以将扁平化的链表成功地插入。</p><p><img src="https://assets.leetcode-cn.com/solution-static/430/1.png"></p><p>在深度优先搜索完成后，我们返回给定的首节点即可。</p><p>细节</p><p>需要注意的是，node 可能没有下一个节点，即next 为空。此时，我们只需进行第二步操作。</p><p>此外，在插入扁平化的链表后，我们需要将 node 的 child 成员置为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* prev;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* child;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        function&lt;Node*(Node*)&gt; dfs = [&amp;](Node* node) &#123;<br>            Node* cur = node;<br>            <span class="hljs-comment">// 记录链表的最后一个节点</span><br>            Node* last = <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                Node* next = cur-&gt;next;<br>                <span class="hljs-comment">//  如果有子节点，那么首先处理子节点</span><br>                <span class="hljs-keyword">if</span> (cur-&gt;child) &#123;<br>                    Node* child_last = <span class="hljs-built_in">dfs</span>(cur-&gt;child);<br><br>                    next = cur-&gt;next;<br>                    <span class="hljs-comment">//  将 node 与 child 相连</span><br>                    cur-&gt;next = cur-&gt;child;<br>                    cur-&gt;child-&gt;prev = cur;<br><br>                    <span class="hljs-comment">//  如果 next 不为空，就将 last 与 next 相连</span><br>                    <span class="hljs-keyword">if</span> (next) &#123;<br>                        child_last-&gt;next = next;<br>                        next-&gt;prev = child_last;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 将 child 置为空</span><br>                    cur-&gt;child = <span class="hljs-literal">nullptr</span>;<br>                    last = child_last;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    last = cur;<br>                &#125;<br>                cur = next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> last;<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-23 每日一题</title>
    <link href="/2021/09/23/2021.9.23%20daily%20problem/"/>
    <url>/2021/09/23/2021.9.23%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a></h4><p>难度简单193</p><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3x</code></p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">27</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">9</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">45</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= n &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能不使用循环或者递归来完成本题吗？</li></ul></li></ul><h2 id="方法一：试除"><a href="#方法一：试除" class="headerlink" title="方法一：试除"></a>方法一：试除</h2><p>当n不是0的时候，一直除以3，如果n是3的幂，除到最后一定是1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)&#123;<br>            n = n/<span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：取巧"><a href="#方法二：取巧" class="headerlink" title="方法二：取巧"></a>方法二：取巧</h2><p>题目说的不使用循环或者递归，我就只想到了预先把2^31内所有3的幂先算出来，但算的时候也得用上循环？然后去看答案了。</p><p>在题目给定的 32 位有符号整数的范围内，最大的 33 的幂为 3^{19} &#x3D; 1162261467。我们只需要判断 n 是否是 3^{19}  的约数即可。</p><p>与方法一不同的是，这里需要特殊判断 n 是负数或 0 的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span> % n == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-22 每日一题</title>
    <link href="/2021/09/22/2021.9.22%20daily%20problem/"/>
    <url>/2021/09/22/2021.9.22%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h4><p>难度中等</p><p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p><p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p><p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p><p>返回一个由上述 <code>k</code> 部分组成的数组。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg" alt="img"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：head = <span class="hljs-selector-attr">[1,2,3]</span>, k = <span class="hljs-number">5</span><br>输出：<span class="hljs-selector-attr">[[1]</span>,<span class="hljs-selector-attr">[2]</span>,<span class="hljs-selector-attr">[3]</span>,<span class="hljs-selector-attr">[]</span>,<span class="hljs-selector-attr">[]</span>]<br>解释：<br>第一个元素 output<span class="hljs-selector-attr">[0]</span> 为 output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.val</span> = <span class="hljs-number">1</span> ，output<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.next</span> = null 。<br>最后一个元素 output<span class="hljs-selector-attr">[4]</span> 为 null ，但它作为 ListNode 的字符串表示是 <span class="hljs-selector-attr">[]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,4,5,6,7,8,9,10]</span>, k = 3<br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[5,6,7]</span>,<span class="hljs-comment">[8,9,10]</span>]</span><br>解释：<br>输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 1000]</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 50</code></li></ul></li></ul><h2 id="方法一：直接拆开"><a href="#方法一：直接拆开" class="headerlink" title="方法一：直接拆开"></a>方法一：直接拆开</h2><p>题目要求将给定的链表分隔成 k 个连续的部分。由于分隔成的每个部分的长度和原始链表的长度有关，因此需要首先遍历链表，得到链表的长度 n。</p><p>得到链表的长度 n 之后，记 quotient&#x3D;⌊ k&#x2F;n ⌋，remainder&#x3D;n mod k，则在分隔成的 k 个部分中，前 remainder 个部分的长度各为 quotient+1，其余每个部分的长度各为 quotient。</p><p>分隔链表时，从链表的头结点开始遍历，记当前结点为 curr，对于每个部分，进行如下操作：</p><p>将 curr 作为当前部分的头结点；</p><p>计算当前部分的长度 partSize；</p><p>将 curr 向后移动 partSize 步，则 curr 为当前部分的尾结点；</p><p>当 curr 到达当前部分的尾结点时，需要拆分 curr 和后面一个结点之间的连接关系，在拆分之前需要存储 curr 的后一个结点 next；</p><p>令 curr 的 next 指针指向 null，完成 curr 和 next 的拆分；</p><p>将 next 赋值给 curr。</p><p>完成上述操作之后，即得到分隔链表后的一个部分。重复上述操作，直到分隔出 k 个部分，或者链表遍历结束，即 curr 指向 null。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>        ListNode *temp = head;<br>        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>            n++;<br>            temp = temp-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> quotient = n / k, remainder = n % k;<br><br>        <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">parts</span><span class="hljs-params">(k,<span class="hljs-literal">nullptr</span>)</span></span>;<br>        ListNode *curr = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; curr != <span class="hljs-literal">nullptr</span>; i++) &#123;<br>            parts[i] = curr;<br>            <span class="hljs-type">int</span> partSize = quotient + (i &lt; remainder ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; partSize; j++) &#123;<br>                curr = curr-&gt;next;<br>            &#125;<br>            ListNode *next = curr-&gt;next;<br>            curr-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            curr = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parts;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-21 每日一题</title>
    <link href="/2021/09/21/2021.9.21%20daily%20problem/"/>
    <url>/2021/09/21/2021.9.21%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   fly me   to   the moon  &quot;</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;luffy is still joyboy&quot;</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>连续3天动态规划了。但是今天的比较简单。</p><p>与其说找最后的单词长度，我直接把所有单词的长度算在这个单词末尾下标的位置。</p><p>之后直接一直遍历到最后，最后有值的下标便是结尾单词的长度。</p><p>dp关系方程为：</p><p>如果当前位置是字母：<br>$$<br>dp[i] &#x3D; dp[i-1]+1;<br>$$<br>如果当前位置不是字母：<br>$$<br>dp[i] &#x3D; 0;<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                dp[i] = dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[i]!=<span class="hljs-number">0</span>)&#123;<br>                ans = dp[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-19 每日一题</title>
    <link href="/2021/09/21/2021.9.19%20daily%20problem/"/>
    <url>/2021/09/21/2021.9.19%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="650-只有两个键的键盘"><a href="#650-只有两个键的键盘" class="headerlink" title="650. 只有两个键的键盘"></a><a href="https://leetcode-cn.com/problems/2-keys-keyboard/">650. 只有两个键的键盘</a></h4><p>难度中等402</p><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code> 。你每次可以对这个记事本进行两种操作：</p><ul><li><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li><li><code>Paste</code>（粘贴）：粘贴 <strong>上一次</strong> 复制的字符。</li></ul><p>给你一个数字 <code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong> <code>n</code> 个 <code>&#39;A&#39;</code> 。返回能够打印出 <code>n</code> 个 <code>&#39;A&#39;</code> 的最少操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">输入：<span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>最初, 只有一个字符 <span class="hljs-string">&#x27;A&#x27;</span>。<br>第 <span class="hljs-number">1</span> 步, 使用 <span class="hljs-keyword">Copy</span> <span class="hljs-keyword">All</span> 操作。<br>第 <span class="hljs-number">2</span> 步, 使用 Paste 操作来获得 <span class="hljs-string">&#x27;AA&#x27;</span>。<br>第 <span class="hljs-number">3</span> 步, 使用 Paste 操作来获得 <span class="hljs-string">&#x27;AAA&#x27;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul></li></ul><h2 id="方法一：动态规划-归纳"><a href="#方法一：动态规划-归纳" class="headerlink" title="方法一：动态规划+归纳"></a>方法一：动态规划+归纳</h2><p>因为每次只能全部复制或者黏贴，所以每个数的构成次数必跟他的因子有关系。</p><p>假设j是i的因子，用f来代表构成i的最少次数，可以有：<br>$$<br>f[i] &#x3D; f[j] + \frac{i}{j}<br>$$<br>而构成i的因子有很多个，遍历i的因子然后找出最小的一个。</p><p>进一步其实我们可以发现，因子的因子可以再拆分，到最后构成的只有多个i&#x2F;j了，而这些的元素的意义就是，i的所有质因数的和，（质数不能再拆了）。证明懒得写上来了，但是这么个道理。</p><p>最后如果i是质数的话，因数只有1跟本身，只能一直复制1，所以次数就是i的本身。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                n /= i;<br>                ans += i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>            ans += n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-20 每日一题</title>
    <link href="/2021/09/21/2021.9.20%20daily%20problem/"/>
    <url>/2021/09/21/2021.9.20%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></h4><p>难度中等</p><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[1,3,5,4,7]</span><br>输出: <span class="hljs-number">2</span><br>解释: 有两个最长递增子序列，分别是 <span class="hljs-string">[1, 3, 4, 7]</span> 和<span class="hljs-string">[1, 3, 5, 7]</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,2,2,2]</span><br><span class="hljs-section">输出: 5</span><br><span class="hljs-section">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p><p>通过次数44,156</p><p>提交次数102,146</p></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>这道题的重点是，记录。DP法找出最长的子序列的长度不难，但是这道题最大的区别就是，要知道从开始到下标以 j 结尾的元素这个子串，有多少种组合能构成最长的以 j 下标元素结尾的最长子序列。</p><p>可以使用两个数组，一个是记录当前位置结尾的最长子序列，另一个是包含到这个位置的最长子序列的个数。</p><p>如果<br>$$<br>i&gt;j\space &amp; \space dp[i]&lt;dp[j] + 1<br>$$<br>说明最长的子序列长度更新了，而构成方法的数量就是cnt[j]的组合数；</p><p>如果<br>$$<br>i&gt;j\space &amp; \space dp[i]&#x3D;dp[j] + 1<br>$$<br>说明在i位置之前也有构成跟以i结尾的最长长度相同的子序列且结尾元素比i下标元素要小，那么就说明，字符串在i的位置构成最长长度的子序列个数就是cnt[i]+cnt[j]。</p><p>算完之后找出最大值，返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNumberOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n =nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            dp[i] = <span class="hljs-number">1</span>,cnt[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])&#123;<br>                    <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span>&gt;dp[i])&#123;<br>                        dp[i] = dp[j] + <span class="hljs-number">1</span>;<br>                        cnt[i] = cnt[j];<span class="hljs-comment">//it means that the quantative of arr ends as i;</span><br>                        <span class="hljs-comment">//because in every step cnt[j] be calculated;</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]+<span class="hljs-number">1</span>==dp[i])&#123;<br>                        cnt[i] += cnt[j];<span class="hljs-comment">//accumulate</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i]&gt;max)&#123;<br>                ans = cnt[i];<br>                max= dp[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[i]==max)&#123;<br>                ans += cnt[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-18 每日一题</title>
    <link href="/2021/09/18/2021.9.18%20daily%20problem/"/>
    <url>/2021/09/18/2021.9.18%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a href="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏</a></h4><p>难度简单462</p><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105">Nim 游戏</a>：</p><ul><li>桌子上有一堆石头。</li><li>你们轮流进行自己的回合，你作为先手。</li><li>每一回合，轮到的人拿掉 1 - 3 块石头。</li><li>拿掉最后一块石头的人就是获胜者。</li></ul><p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：false <br>解释：如果堆中有<span class="hljs-number"> 4 </span>块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走<span class="hljs-number"> 1 </span>块、2 块 还是<span class="hljs-number"> 3 </span>块石头，最后一块石头总是会被你的朋友拿走。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 231 - 1</code></li></ul></li></ul><h2 id="方法一：遍历"><a href="#方法一：遍历" class="headerlink" title="方法一：遍历"></a>方法一：遍历</h2><p>这是一道脑筋急转弯题目。</p><p>之前做过一道每次拿1-2，但自己不能是最后拿的题目；思路类似。</p><p>一开始的思考方向肯定是往归纳那边思考：</p><p>首先，自己是先手的；</p><p>那么1，2，3必然是true；</p><p>而在4的时候，因为无论我们拿1个，2个还是3个，剩下的个数都小于3，必定输；</p><p>然后我们知道4是一定输的，所以5，6，7我们都可以通过巧妙的控制数量，使得我们取完后，剩下4，那么对手就一定输。</p><p>然后到8，同样，我们发现只要自己取了石头，那么剩下的可能性分别是5，6，7；而上述分析5，6，7对当前玩家是必赢的数…………</p><p>我们可以开始总结了：</p><p>关键之处是发现，每个人只能取1~3个，所以当n是4的倍数时，无论我们怎么取，对方都可以通过计算使得对面取完后仍是4的倍数，相当于问题没有规约——直至到n变成4，这样是必败的局面。反过来，当n模4等于1，2，3的时候，我们可以取1，2，3使得当前问题变成4的倍数，从而达成lock局面妨碍对手的胜利。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canWinNim</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-17 每日一题</title>
    <link href="/2021/09/17/2021.9.17%20daily%20problem/"/>
    <url>/2021/09/17/2021.9.17%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></h4><p>难度中等611</p><p>请你判断一个 <code>9x9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p><ol><li>数字 <code>1-9</code> 在每一行只能出现一次。</li><li>数字 <code>1-9</code> 在每一列只能出现一次。</li><li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li></ol><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = <br>[[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：true<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = <br>[[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>,[<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>,[<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>,[<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]]<br>输出：false<br>解释：除了第一行的第一个数字从 <span class="hljs-number">5</span> 改为 <span class="hljs-number">8</span> 以外，空格内其他数字均与 示例<span class="hljs-number">1</span> 相同。 但由于位于左上角的 <span class="hljs-number">3</span>x3 宫内有两个 <span class="hljs-number">8</span> 存在, 因此这个数独是无效的。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>board.length == 9</code></li><li><code>board[i].length == 9</code></li><li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li></ul></li></ul><h2 id="方法一：遍历"><a href="#方法一：遍历" class="headerlink" title="方法一：遍历"></a>方法一：遍历</h2><p>是一道之前数据结构练习做过的题，只要选取好结构，其实就很好解决。</p><p>下手的方向是寻找重复出现的数字，只要那个数字重复出现了，那么就可以返回false。</p><p>最直观的做法就是横向遍历一次，再竖向遍历一次，最后再以九格为单位全图遍历。</p><p>不过可以把这三次遍历压缩成一次。</p><p>我们建立三个表结构，分别代表上述的三次遍历，使用unordered_map，每次出现一个数之后，在对应的表位置的值增一，因为初始的时候是0，所以超过1就是重复了。</p><p>特别的，对于九格的遍历，我们可以用一个式子将其唯一化，【i&#x2F;3*3+j&#x2F;3】就可以把一个区间里的所有下标都压缩成唯一的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; col[<span class="hljs-number">9</span>],row[<span class="hljs-number">9</span>],mat[<span class="hljs-number">9</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;board.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                    col[j][board[i][j]]++;<br>                    row[i][board[i][j]]++;<br>                    mat[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>][board[i][j]]++;<br>                    <span class="hljs-keyword">if</span>(col[j][board[i][j]]&gt;<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(row[i][board[i][j]]&gt;<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(mat[i/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j/<span class="hljs-number">3</span>][board[i][j]]&gt;<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-16 每日一题</title>
    <link href="/2021/09/16/2021.9.16%20daily%20problem/"/>
    <url>/2021/09/16/2021.9.16%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></h4><p>难度困难</p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个单词（字符串）列表 <code>words</code>，找出所有同时在二维网格和字典中出现的单词。</p><p>单词必须按照字母顺序，通过 <strong>相邻的单元格</strong> 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search1.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;n&quot;</span>],[<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;h&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>],[<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;v&quot;</span>]], words = [<span class="hljs-string">&quot;oath&quot;</span>,<span class="hljs-string">&quot;pea&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;rain&quot;</span>]<br>输出：[<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;oath&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/07/search2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]], words = [<span class="hljs-string">&quot;abcb&quot;</span>]<br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 12</code></li><li><code>board[i][j]</code> 是一个小写英文字母</li><li><code>1 &lt;= words.length &lt;= 3 * 104</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li><li><code>words</code> 中的所有字符串互不相同</li></ul></li></ul><h2 id="方法一：爬坡二分"><a href="#方法一：爬坡二分" class="headerlink" title="方法一：爬坡二分"></a>方法一：爬坡二分</h2><p>远超出个人能力的题目，不花时间死磕。</p><p>预备知识</p><p>前缀树（字典树）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。前缀树可以用 O(|S|)的时间复杂度完成如下操作，其中 |S|是插入字符串或查询前缀的长度：</p><p>向前缀树中插入字符串 word；</p><p>查询前缀串 prefix 是否为已经插入到前缀树中的任意一个字符串 word 的前缀；</p><p>前缀树的实现可以参考「208. 实现 Trie (前缀树) 的官方题解」。</p><p>思路和算法</p><p>根据题意，我们需要逐个遍历二维网格中的每一个单元格；然后搜索从该单元格出发的所有路径，找到其中对应 words 中的单词的路径。因为这是一个回溯的过程，所以我们有如下算法：</p><p>遍历二维网格中的所有单元格。</p><p>深度优先搜索所有从当前正在遍历的单元格出发的、由相邻且不重复的单元格组成的路径。因为题目要求同一个单元格内的字母在一个单词中不能被重复使用；所以我们在深度优先搜索的过程中，每经过一个单元格，都将该单元格的字母临时修改为特殊字符（例如 #），以避免再次经过该单元格。</p><p>如果当前路径是 words 中的单词，则将其添加到结果集中。如果当前路径是 words 中任意一个单词的前缀，则继续搜索；反之，如果当前路径不是 words 中任意一个单词的前缀，则剪枝。我们可以将 words 中的所有字符串先添加到前缀树中，而后用 O(|S|) 的时间复杂度查询当前路径是否为 words 中任意一个单词的前缀。</p><p>在具体实现中，我们需要注意如下情况：</p><p>因为同一个单词可能在多个不同的路径中出现，所以我们需要使用哈希集合对结果集去重。</p><p>在回溯的过程中，我们不需要每一步都判断完整的当前路径是否是 words 中任意一个单词的前缀；而是可以记录下路径中每个单元格所对应的前缀树结点，每次只需要判断新增单元格的字母是否是上一个单元格对应前缀树结点的子结点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    string word;<br>    unordered_map&lt;<span class="hljs-type">char</span>,TrieNode *&gt; children;<br>    <span class="hljs-built_in">TrieNode</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;word = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;   <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertTrie</span><span class="hljs-params">(TrieNode * root,<span class="hljs-type">const</span> string &amp; word)</span> </span>&#123;<br>    TrieNode * node = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word)&#123;<br>        <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) &#123;<br>            node-&gt;children[c] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        &#125;<br>        node = node-&gt;children[c];<br>    &#125;<br>    node-&gt;word = word;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> dirs[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = board[x][y];        <br>        <span class="hljs-keyword">if</span> (!root-&gt;children.<span class="hljs-built_in">count</span>(ch)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        root = root-&gt;children[ch];<br>        <span class="hljs-keyword">if</span> (root-&gt;word.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">insert</span>(root-&gt;word);<br>        &#125;<br><br>        board[x][y] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> nx = x + dirs[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ny = y + dirs[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (board[nx][ny] != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(board, nx, ny, root,res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        board[x][y] = ch;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findWords</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp; board, vector&lt;string&gt; &amp; words)</span> </span>&#123;<br>        TrieNode * root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        set&lt;string&gt; res;<br>        vector&lt;string&gt; ans;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; word: words)&#123;<br>            <span class="hljs-built_in">insertTrie</span>(root,word);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; board.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-built_in">dfs</span>(board, i, j, root, res);<br>            &#125;<br>        &#125;        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; word: res) &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(word);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;        <br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-15 每日一题</title>
    <link href="/2021/09/15/2021.9.15%20daily%20problem/"/>
    <url>/2021/09/15/2021.9.15%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a></h4><p>难度中等</p><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,1</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<span class="hljs-number">3</span> 是峰值元素，你的函数应该返回其索引 <span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,1,3,5,6,4]</span><br>输出：<span class="hljs-number">1</span> 或 <span class="hljs-number">5</span> <br>解释：你的函数可以返回索引 <span class="hljs-number">1</span>，其峰值元素为 <span class="hljs-number">2</span>；<br>     或者返回索引 <span class="hljs-number">5</span>， 其峰值元素为 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul></li></ul><h2 id="方法一：爬坡二分"><a href="#方法一：爬坡二分" class="headerlink" title="方法一：爬坡二分"></a>方法一：爬坡二分</h2><p>规定了对数级时间复杂度，方法指向2分，但是没想到如何决定算法的前进方向，没做出来。</p><p>俗话说「人往高处走，水往低处流」。如果我们从一个位置开始，不断地向高处走，那么最终一定可以到达一个峰值位置。</p><p>因此，我们首先在 [0, n) 的范围内随机一个初始位置 i，随后根据<br>$$<br>\textit{nums}[i-1], \textit{nums}[i], \textit{nums}[i+1]<br>$$<br>三者的关系决定向哪个方向走：</p><p>如果<br>$$<br>\textit{nums}[i-1] &lt; \textit{nums}[i] &gt; \textit{nums}[i+1]<br>$$<br>，那么位置 ii 就是峰值位置，我们可以直接返回 ii 作为答案；</p><p>如果<br>$$<br>\textit{nums}[i-1] &lt; \textit{nums}[i] &lt; \textit{nums}[i+1]<br>$$<br>，那么位置 i 处于上坡，我们需要往右走，即<br>$$<br>i \leftarrow i+1<br>$$<br>如果<br>$$<br>\textit{nums}[i-1] &gt; \textit{nums}[i] &gt; \textit{nums}[i+1]<br>$$<br>，那么位置 ii 处于下坡，我们需要往左走，即<br>$$<br>i \leftarrow i-1<br>$$<br>；</p><p>如果<br>$$<br>\textit{nums}[i-1] &gt; \textit{nums}[i] &lt; \textit{nums}[i+1]<br>$$<br>，那么位置 i 位于山谷，两侧都是上坡，我们可以朝任意方向走。</p><p>如果我们规定对于最后一种情况往右走，那么当位置 i 不是峰值位置时：如果 </p><p>$$<br>\textit{nums}[i] &lt; \textit{nums}[i+1]<br>$$<br>那么我们往右走；如果<br>$$<br>\textit{nums}[i] &gt; \textit{nums}[i+1]<br>$$<br>，那么我们往左走。</p><p>在上述算法中，如果我们固定选取 i 为 [l,r] 的中点，那么每次可行的下标范围会减少一半，成为一个类似二分查找的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-comment">// 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])</span><br>        <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>        <span class="hljs-keyword">auto</span> get = [&amp;](<span class="hljs-type">int</span> i) -&gt; pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">-1</span> || i == n) &#123;<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            &#125;<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, nums[i]&#125;;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>, ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(mid - <span class="hljs-number">1</span>) &lt; <span class="hljs-built_in">get</span>(mid) &amp;&amp; <span class="hljs-built_in">get</span>(mid) &gt; <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>)) &#123;<br>                ans = mid;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(mid) &lt; <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>)) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-14 每日一题</title>
    <link href="/2021/09/14/2021.9.14%20daily%20problem/"/>
    <url>/2021/09/14/2021.9.14%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a></h4><p>难度中等169</p><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p><p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：s = <span class="hljs-string">&quot;abpcplea&quot;</span>, <span class="hljs-built_in">dictionary</span> = [<span class="hljs-string">&quot;ale&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;monkey&quot;</span>,<span class="hljs-string">&quot;plea&quot;</span>]<br>输出：<span class="hljs-string">&quot;apple&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：s = <span class="hljs-string">&quot;abpcplea&quot;</span>, <span class="hljs-built_in">dictionary</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>输出：<span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>1 &lt;= dictionary.length &lt;= 1000</code></li><li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li><li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li></ul></li></ul><h2 id="方法一：双指针-排序"><a href="#方法一：双指针-排序" class="headerlink" title="方法一：双指针+排序"></a>方法一：双指针+排序</h2><p>要做的工作有两个。</p><p>第一个是写一个判断s2是否是s1子序列的函数。</p><p>第二个是把待验证序列按照长度从高到低排序。</p><p>排序的目的是，只要成功验证s2是s1的子序列，就可以马上return，不需要做多余的工作</p><p>题目还要求首先输出小字典序，所以排序的时候要注意多加一个判断。</p><p>今天真是犯迷糊了，一个双指针比较最长子序列的for循环逻辑捣浆糊来来去去写一个小时我真的是吐了。。。无语死，这就是时间蒸发术是吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string s1,string s2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">length</span>()==s2.<span class="hljs-built_in">length</span>())&#123;<span class="hljs-comment">//保证字典序</span><br>            <span class="hljs-keyword">return</span> s1&lt;s2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s1.<span class="hljs-built_in">length</span>()&gt;s2.<span class="hljs-built_in">length</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string s1,string s2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s2.<span class="hljs-built_in">length</span>()&gt;s1.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">length</span>();i++)&#123;<span class="hljs-comment">//从长的那串开始，每次找到相等就把短串下标增一，这样就算s2非子序列，也不会下标溢出或者多层逻辑判断下标是否合法。因为i遍历完了一定是可以知道s2是否s1的子序列。</span><br>            <span class="hljs-keyword">if</span>(s1[i]==s2[j])&#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j==s2.<span class="hljs-built_in">length</span>())&#123;<span class="hljs-comment">//提前判断完了直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(),dictionary.<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;dictionary.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s,dictionary[i]))&#123;<br>                <span class="hljs-keyword">return</span> dictionary[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-13 每日一题</title>
    <link href="/2021/09/13/2021.9.13%20daily%20problem/"/>
    <url>/2021/09/13/2021.9.13%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="447-回旋镖的数量"><a href="#447-回旋镖的数量" class="headerlink" title="447. 回旋镖的数量"></a><a href="https://leetcode-cn.com/problems/number-of-boomerangs/">447. 回旋镖的数量</a></h4><p>难度中等</p><p>给定平面上 <code>n</code> 对 <strong>互不相同</strong> 的点 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 。<strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p><p>返回平面上所有回旋镖的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[0,0],[1,0],[2,0]]</span><br>输出：<span class="hljs-number">2</span><br>解释：两个回旋镖为 <span class="hljs-string">[[1,0],[0,0],[2,0]]</span> 和 <span class="hljs-string">[[1,0],[2,0],[0,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,1],[2,2],[3,3]]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：points = <span class="hljs-string">[[1,1]]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == points.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>points[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li>所有点都 <strong>互不相同</strong></li></ul></li></ul><h2 id="方法一：哈希枚举"><a href="#方法一：哈希枚举" class="headerlink" title="方法一：哈希枚举"></a>方法一：哈希枚举</h2><p>思来想去没有巧妙的办法，只能试试枚举能不能过了，没想到就是这么简单哈哈。</p><p>首先我们选定回旋镖的中点，然后找出能以这个点构成回旋镖的两个点，</p><p>距离计算是根号下x平方+y平方，但因为每一个距离都要开方，我们可以把开方省去了（众生平等）。</p><p>然后在每一次的循环中，只需要看距离d[i]的出现次数，因为如果u，t距中点的距离相同，他们一定能构成回旋镖，对于每一个d[i]来说，只要大于1，我们就可以从距离中点的值是d[i]的点里任取两个构成回旋镖。</p><p>使用一个哈希表记录d[i]；因为不知道d[i]的个数并且d[i]的值不连续，使用unordered_map来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; d;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            d.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//注意每轮清空，因为每一次计算的回旋中点是不一样的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> dis = (points[j][<span class="hljs-number">0</span>] - points[i][<span class="hljs-number">0</span>])*(points[j][<span class="hljs-number">0</span>] - points[i][<span class="hljs-number">0</span>]) + (points[j][<span class="hljs-number">1</span>] - points[i][<span class="hljs-number">1</span>])*(points[j][<span class="hljs-number">1</span>] - points[i][<span class="hljs-number">1</span>]);<br>                d[dis]++;<span class="hljs-comment">//直接计算距离x的出现次数</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it:d)&#123;<span class="hljs-comment">//遍历距离，如果这个距离出现的次数大于1，说明可以构成回旋镖</span><br>                <span class="hljs-type">int</span> temp = it.second;<br>                <span class="hljs-keyword">if</span>(temp&gt;<span class="hljs-number">1</span>)&#123;<br>                    ans += temp*(temp<span class="hljs-number">-1</span>);<span class="hljs-comment">//这里其实就是C(n,2)（n个里任选2个）；因为题目说可以交换位置，所以C22的分母2就省略了</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-12 每日一题</title>
    <link href="/2021/09/12/2021.9.12%20daily%20problem/"/>
    <url>/2021/09/12/2021.9.12%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="678-有效的括号字符串"><a href="#678-有效的括号字符串" class="headerlink" title="678. 有效的括号字符串"></a><a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">678. 有效的括号字符串</a></h4><p>难度中等292</p><p>给定一个只包含三种字符的字符串：<code>（ </code>，<code>）</code> 和 <code>*</code>，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p><ol><li>任何左括号 <code>(</code> 必须有相应的右括号 <code>)</code>。</li><li>任何右括号 <code>)</code> 必须有相应的左括号 <code>(</code> 。</li><li>左括号 <code>(</code> 必须在对应的右括号之前 <code>)</code>。</li><li><code>*</code> 可以被视为单个右括号 <code>)</code> ，或单个左括号 <code>(</code> ，或一个空字符串。</li><li>一个空字符串也被视为有效字符串。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*)&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">输入: <span class="hljs-string">&quot;(*))&quot;</span><br>输出: <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>字符串大小将在 [1，100] 范围内。</li></ol></li></ul><h2 id="方法一：栈模拟"><a href="#方法一：栈模拟" class="headerlink" title="方法一：栈模拟"></a>方法一：栈模拟</h2><p>这道题跟基础的括号匹配很类似，容易先入为主，这道题的难点是要知道什么时候让星号当左括号，什么时候让星号当右括号。想了几种无效思路就不展开了，就谈解题用的方法：</p><p>首先呢，需要做两个栈，一个是左括号栈和星号栈。</p><p>右括号肯定是最好处理的，只要他前面有左括号或者星号都能清除。而我们从左往右遍历的时候，只要一碰到右括号就检验是不用考虑距离右括号最近的是左括号还是星号，优先弹出左括号（因为星号也能当空字符串。就算类似是示例3的那种，也能看作是先弹出左括号后弹出星号，只是逻辑上顺序反了但结果一样），如果左括号栈空，就在星号栈弹出。</p><p>这样处理完之后左括号栈不一定是空栈，我们还要对这部分就行匹配。这个时候的星号只会当成空字符串或者右括号，而右括号一定要在左括号的后面才能匹配，所以需要对左括号和星号进行下标检验，如果栈顶星号的下标比栈顶左括号小，那就return false。</p><p>只要最后左括号栈是空的，就return true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkValidString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; sleft;<span class="hljs-comment">//使用int进栈是为了标记符号下标，在后续处理需要检验左括号和星号的前后位置</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; star;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                sleft.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                star.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(!sleft.<span class="hljs-built_in">empty</span>())&#123;<br>                    sleft.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!star.<span class="hljs-built_in">empty</span>())&#123;<br>                    star.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!sleft.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">if</span>(star.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> a = sleft.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-type">int</span> b = star.<span class="hljs-built_in">top</span>();<br>                star.<span class="hljs-built_in">pop</span>();<br>                sleft.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(a&gt;b)&#123;<span class="hljs-comment">//如果匹配的星号在左括号前面说明是不能把当前左括号消掉的</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-11 每日一题</title>
    <link href="/2021/09/11/2021.9.11%20daily%20problem/"/>
    <url>/2021/09/11/2021.9.11%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1894-找到需要补充粉笔的学生编号"><a href="#1894-找到需要补充粉笔的学生编号" class="headerlink" title="1894. 找到需要补充粉笔的学生编号"></a><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></h4><p>难度中等</p><p>一个班级里有 <code>n</code> 个学生，编号为 <code>0</code> 到 <code>n - 1</code> 。每个学生会依次回答问题，编号为 <code>0</code> 的学生先回答，然后是编号为 <code>1</code> 的学生，以此类推，直到编号为 <code>n - 1</code> 的学生，然后老师会重复这个过程，重新从编号为 <code>0</code> 的学生开始回答问题。</p><p>给你一个长度为 <code>n</code> 且下标从 <code>0</code> 开始的整数数组 <code>chalk</code> 和一个整数 <code>k</code> 。一开始粉笔盒里总共有 <code>k</code> 支粉笔。当编号为 <code>i</code> 的学生回答问题时，他会消耗 <code>chalk[i]</code> 支粉笔。如果剩余粉笔数量 <strong>严格小于</strong> <code>chalk[i]</code> ，那么学生 <code>i</code> 需要 <strong>补充</strong> 粉笔。</p><p>请你返回需要 <strong>补充</strong> 粉笔的学生 <strong>编号</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：chalk = [5,1,5], k = 22<br>输出：0<br>解释：学生消耗粉笔情况如下：<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 17 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 16 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 11 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 6 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 5 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 0 </span>。<br>编号为<span class="hljs-number"> 0 </span>的学生没有足够的粉笔，所以他需要补充粉笔。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：chalk = [3,4,1,2], k = 25<br>输出：1<br>解释：学生消耗粉笔情况如下：<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 22 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 4 </span>支粉笔，然后 k =<span class="hljs-number"> 18 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 17 </span>。<br>- 编号为<span class="hljs-number"> 3 </span>的学生使用<span class="hljs-number"> 2 </span>支粉笔，然后 k =<span class="hljs-number"> 15 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 12 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 4 </span>支粉笔，然后 k =<span class="hljs-number"> 8 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 7 </span>。<br>- 编号为<span class="hljs-number"> 3 </span>的学生使用<span class="hljs-number"> 2 </span>支粉笔，然后 k =<span class="hljs-number"> 5 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 2 </span>。<br>编号为<span class="hljs-number"> 1 </span>的学生没有足够的粉笔，所以他需要补充粉笔。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>chalk.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= chalk[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>又是10的9次方，这次学乖了一开始先不动手想好再码；</p><p>使用了投机的方法看结果是否跟质数的性质有关，但测例告诉我显然是不可以这样做的。</p><p>然后观察了一下想着是不是可以用动态规划，因为0，1二进制表示的话之前是学过类似哈夫曼编码那种唯一01树，但是要我写DP就有点犯难了，不知道这种属不属于树型DP，搞不定，先mark一下。</p><p>因为正整数 n 可以取到 10^9 ，所以显然是不可能通过暴力遍历从 1 到 n 的所有正整数来计算答案的。直观上，我们也可以感觉到，在暴力遍历的过程中，有非常多的计算是重复的。因此，我们考虑通过优化暴力遍历来解决这个问题。</p><p>为了形象地将重复计算的部分找出来，我们不妨将小于等于 n 的非负整数用 01 字典树的形式表示，其中的每一条从根结点到叶结点的路径都是一个小于等于 n 的非负整数（包含前导 0）。</p><p>于是，题目可以转化为：在由所有小于等于 n 的非负整数构成的 01 字典树中，找出不包含连续 1 的从根结点到叶结点的路径数量。</p><p>以<br>$$<br>n &#x3D; 6 &#x3D; (110)_2<br>$$<br>  为例，我们可以发现：</p><p>对于 0101 字典树中的两个节点 n1 和 n2 ，如果它们的高度相同，节点的值也相同，并且以它们为根结点的两棵子树都是满二叉树，那么它们包含的无连续 11 的从根结点到叶结点的路径个数是相同的。<br>对于 0101 字典树中的两个结点 n1 和 n2，如果 n2是 n1的子结点，并且它们的值都是 1，那么所有经过n1和 n2 的从根结点到叶结点的路径都一定包含连续的 1。<br>注意到由小于等于 n 的非负整数构成的 01 字典树是完全二叉树。于是有：如果某个结点包含两个子结点，那么其左子结点为根结点是 0 的满二叉树，其右子结点为根结点是 1 的完全二叉树；如果某个结点只有一个子结点，那么其左子结点为根结点是 0 的完全二叉树。</p><p>我们在计算不包含连续 1 的从根结点到叶结点的路径数量时，可以不断地将字典树拆分为根结点为 0 的满二叉树和根结点不定的完全二叉树。</p><p>于是，题目被拆分为以下两个子问题：</p><p>问题 1：如何计算根结点为 0 的满二叉树中，不包含连续 1 的从根结点到叶结点的路径数量。<br>问题 2：如何将将字典树拆分为根结点为 0 的满二叉树和根结点不定的完全二叉树。</p><p>算法</p><p>首先解决第 1 个问题。</p><p>我们发现，在高度为 t、根结点为 0 的满二叉树中：其左子结点是高度为 t−1、根结点为 0 的满二叉树。其右子结点是高度为 t-1、根结点为 1 的满二叉树；但是因为路径中不能有连续 1，所以右子结点下只有其左子结点包含的从根结点到叶结点的路径才符合要求，而其左子结点是高度为 t-2、根结点为 0 的满二叉树。</p><p>于是，高度为 t、根结点为 0 的满二叉树中不包含连续 1 的从根结点到叶结点的路径数量，等于高度为 t-1、根结点为 0 的满二叉树中的路径数量与高度为 t-2，根结点为 0 的满二叉树中的路径数量之和。因此，这个问题可以通过动态规划解决：</p><p>状态：dp[t]。dp[t] 表示高度为 t+1、根结点为 0 的满二叉树中，不包含连续 1 的从根结点到叶结点的路径数量。</p><p>状态转移方程：</p><p>$$<br>dp[t] &#x3D; \begin{cases} dp[t-1] + dp[t-2], \quad t \ge 2 \ 1, \quad t &lt; 2 \end{cases}<br>$$</p><p>接着解决第 2 个问题。</p><p>考虑到 01 字典树作为完全二叉树所具有的性质，我们可以从根结点开始处理。如果当前结点包含两个子结点，则用问题 1 的解决方法计算其左子结点中不包含连续 1 的从根结点到叶结点的路径数量，并继续处理其右子结点；如果当前结点只包含一个左子结点，那么继续处理其左子结点。</p><p>在实现中，需要注意如果已经出现连续 1 则不用继续处理；另外，叶结点没有子结点，需要作为特殊情况单独处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chalkReplacer</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; chalk, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalcost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;chalk.<span class="hljs-built_in">size</span>();i++)&#123;<br>            totalcost += chalk[i];<br>            <span class="hljs-keyword">if</span>(totalcost&gt;k)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        k = k%totalcost;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;chalk.<span class="hljs-built_in">size</span>();i++)&#123;<br>            k -= chalk[i];<br>            <span class="hljs-keyword">if</span>(k&lt;<span class="hljs-number">0</span>)&#123;<br>                ans = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-10 每日一题</title>
    <link href="/2021/09/10/2021.9.10%20daily%20problem/"/>
    <url>/2021/09/10/2021.9.10%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1894-找到需要补充粉笔的学生编号"><a href="#1894-找到需要补充粉笔的学生编号" class="headerlink" title="1894. 找到需要补充粉笔的学生编号"></a><a href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/">1894. 找到需要补充粉笔的学生编号</a></h4><p>难度中等</p><p>一个班级里有 <code>n</code> 个学生，编号为 <code>0</code> 到 <code>n - 1</code> 。每个学生会依次回答问题，编号为 <code>0</code> 的学生先回答，然后是编号为 <code>1</code> 的学生，以此类推，直到编号为 <code>n - 1</code> 的学生，然后老师会重复这个过程，重新从编号为 <code>0</code> 的学生开始回答问题。</p><p>给你一个长度为 <code>n</code> 且下标从 <code>0</code> 开始的整数数组 <code>chalk</code> 和一个整数 <code>k</code> 。一开始粉笔盒里总共有 <code>k</code> 支粉笔。当编号为 <code>i</code> 的学生回答问题时，他会消耗 <code>chalk[i]</code> 支粉笔。如果剩余粉笔数量 <strong>严格小于</strong> <code>chalk[i]</code> ，那么学生 <code>i</code> 需要 <strong>补充</strong> 粉笔。</p><p>请你返回需要 <strong>补充</strong> 粉笔的学生 <strong>编号</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：chalk = [5,1,5], k = 22<br>输出：0<br>解释：学生消耗粉笔情况如下：<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 17 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 16 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 11 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 6 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 5 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 5 </span>支粉笔，然后 k =<span class="hljs-number"> 0 </span>。<br>编号为<span class="hljs-number"> 0 </span>的学生没有足够的粉笔，所以他需要补充粉笔。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：chalk = [3,4,1,2], k = 25<br>输出：1<br>解释：学生消耗粉笔情况如下：<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 22 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 4 </span>支粉笔，然后 k =<span class="hljs-number"> 18 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 17 </span>。<br>- 编号为<span class="hljs-number"> 3 </span>的学生使用<span class="hljs-number"> 2 </span>支粉笔，然后 k =<span class="hljs-number"> 15 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 12 </span>。<br>- 编号为<span class="hljs-number"> 1 </span>的学生使用<span class="hljs-number"> 4 </span>支粉笔，然后 k =<span class="hljs-number"> 8 </span>。<br>- 编号为<span class="hljs-number"> 2 </span>的学生使用<span class="hljs-number"> 1 </span>支粉笔，然后 k =<span class="hljs-number"> 7 </span>。<br>- 编号为<span class="hljs-number"> 3 </span>的学生使用<span class="hljs-number"> 2 </span>支粉笔，然后 k =<span class="hljs-number"> 5 </span>。<br>- 编号为<span class="hljs-number"> 0 </span>的学生使用<span class="hljs-number"> 3 </span>支粉笔，然后 k =<span class="hljs-number"> 2 </span>。<br>编号为<span class="hljs-number"> 1 </span>的学生没有足够的粉笔，所以他需要补充粉笔。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>chalk.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= chalk[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul></li></ul><h2 id="方法一：周期模拟"><a href="#方法一：周期模拟" class="headerlink" title="方法一：周期模拟"></a>方法一：周期模拟</h2><p>因为数据量很大，显然是需要想办法减少运算量的。</p><p>思路雏形：因为学生序列是循环的，我们可以先计算一个周期共需要小号多少支粉笔，然后用粉笔总数除以掉这个值取余，最后对一个周期进行模拟。</p><p>但是因为chalk[i]的总和可能导致爆int，仔细思考之后我们可以发现，只要当计算总和的中途发现总和已经超过了k，那么我们没必要往下算了，因为无论下面的值是多少，因为超过了k，所以k只能支持一个周期。</p><p>最后就是，老老实实做一次单向遍历模拟。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chalkReplacer</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; chalk, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalcost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;chalk.<span class="hljs-built_in">size</span>();i++)&#123;<br>            totalcost += chalk[i];<br>            <span class="hljs-keyword">if</span>(totalcost&gt;k)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        k = k%totalcost;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;chalk.<span class="hljs-built_in">size</span>();i++)&#123;<br>            k -= chalk[i];<br>            <span class="hljs-keyword">if</span>(k&lt;<span class="hljs-number">0</span>)&#123;<br>                ans = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-09 每日一题</title>
    <link href="/2021/09/09/2021.9.9%20daily%20problem/"/>
    <url>/2021/09/09/2021.9.9%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/">68. 文本左右对齐</a></h4><p>难度困难</p><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p><p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>&#39; &#39;</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p><p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p><p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p><p><strong>说明:</strong></p><ul><li>单词是指由非空格字符组成的字符序列。</li><li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li><li>输入单词数组 <code>words</code> 至少包含一个单词。</li></ul><p><strong>示例:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;This&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;example&quot;</span>, <span class="hljs-string">&quot;of&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;justification.&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>   <span class="hljs-string">&quot;This    is    an&quot;</span>,<br>   <span class="hljs-string">&quot;example  of text&quot;</span>,<br>   <span class="hljs-string">&quot;justification.  &quot;</span><br>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;What&quot;</span>,<span class="hljs-string">&quot;must&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>,<span class="hljs-string">&quot;acknowledgment&quot;</span>,<span class="hljs-string">&quot;shall&quot;</span>,<span class="hljs-string">&quot;be&quot;</span>]<br>maxWidth = 16<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;What   must   be&quot;</span>,<br>  <span class="hljs-string">&quot;acknowledgment  &quot;</span>,<br>  <span class="hljs-string">&quot;shall be        &quot;</span><br>]<br><span class="hljs-section">解释: 注意最后一行的格式应为 &quot;shall be    &quot; 而不是 &quot;shall     be&quot;,</span><br>     因为最后一行应为左对齐，而不是左右两端对齐。       <br>     第二行同样为左对齐，这是因为这行只包含一个单词。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入:</span><br>words = [<span class="hljs-string">&quot;Science&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;what&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;understand&quot;</span>,<span class="hljs-string">&quot;well&quot;</span>,<span class="hljs-string">&quot;enough&quot;</span>,<span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;explain&quot;</span>,<br>         <span class="hljs-string">&quot;to&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;computer.&quot;</span>,<span class="hljs-string">&quot;Art&quot;</span>,<span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;everything&quot;</span>,<span class="hljs-string">&quot;else&quot;</span>,<span class="hljs-string">&quot;we&quot;</span>,<span class="hljs-string">&quot;do&quot;</span>]<br>maxWidth = 20<br><span class="hljs-section">输出:</span><br>[<br>  <span class="hljs-string">&quot;Science  is  what we&quot;</span>,<br>  <span class="hljs-string">&quot;understand      well&quot;</span>,<br>  <span class="hljs-string">&quot;enough to explain to&quot;</span>,<br>  <span class="hljs-string">&quot;a  computer.  Art is&quot;</span>,<br>  <span class="hljs-string">&quot;everything  else  we&quot;</span>,<br>  <span class="hljs-string">&quot;do                  &quot;</span><br>]<br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>自己写得又长又臭，因为现在正式备考，不花太多时间琢磨了，抄答案。</p><p>根据题干描述的贪心算法，对于每一行，我们首先确定最多可以放置多少单词，这样可以得到该行的空格个数，从而确定该行单词之间的空格个数。</p><p>根据题目中填充空格的细节，我们分以下三种情况讨论：</p><p>当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格；<br>当前行不是最后一行，且只有一个单词：该单词左对齐，在行末填充空格；<br>当前行不是最后一行，且不只一个单词：设当前行单词数为 <em>numWords</em>，空格数为 <em>numSpaces</em>，我们需要将空格均匀分配在单词之间，则单词之间应至少有个空格。<br>$$<br>\textit{avgSpaces}&#x3D;\Big\lfloor\dfrac{\textit{numSpaces}}{\textit{numWords}-1}\Big\rfloor<br>$$<br>对于多出来的<br>$$<br>\textit{extraSpaces}&#x3D;\textit{numSpaces}\bmod(\textit{numWords}-1)<br>$$<br>个空格，应填在前 <em>extraSpaces</em> 个单词之间。因此，前 <em>extraSpaces</em> 个单词之间填充 <em>avgSpaces</em>+1 个空格，其余单词之间填充 <em>avgSpaces</em> 个空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// blank 返回长度为 n 的由空格组成的字符串</span><br>    <span class="hljs-function">string <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27; &#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串</span><br>    <span class="hljs-function">string <span class="hljs-title">join</span><span class="hljs-params">(vector&lt;string&gt; &amp;words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, string sep)</span> </span>&#123;<br>        string s = words[left];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = left + <span class="hljs-number">1</span>; i &lt; right; ++i) &#123;<br>            s += sep + words[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">fullJustify</span><span class="hljs-params">(vector&lt;string&gt; &amp;words, <span class="hljs-type">int</span> maxWidth)</span> </span>&#123;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>, n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> left = right; <span class="hljs-comment">// 当前行的第一个单词在 words 的位置</span><br>            <span class="hljs-type">int</span> sumLen = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计这一行单词长度之和</span><br>            <span class="hljs-comment">// 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格</span><br>            <span class="hljs-keyword">while</span> (right &lt; n &amp;&amp; sumLen + words[right].<span class="hljs-built_in">length</span>() + right - left &lt;= maxWidth) &#123;<br>                sumLen += words[right++].<span class="hljs-built_in">length</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格</span><br>            <span class="hljs-keyword">if</span> (right == n) &#123;<br>                string s = <span class="hljs-built_in">join</span>(words, left, n, <span class="hljs-string">&quot; &quot;</span>);<br>                ans.<span class="hljs-built_in">emplace_back</span>(s + <span class="hljs-built_in">blank</span>(maxWidth - s.<span class="hljs-built_in">length</span>()));<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br><br>            <span class="hljs-type">int</span> numWords = right - left;<br>            <span class="hljs-type">int</span> numSpaces = maxWidth - sumLen;<br><br>            <span class="hljs-comment">// 当前行只有一个单词：该单词左对齐，在行末填充剩余空格</span><br>            <span class="hljs-keyword">if</span> (numWords == <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">emplace_back</span>(words[left] + <span class="hljs-built_in">blank</span>(numSpaces));<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 当前行不只一个单词</span><br>            <span class="hljs-type">int</span> avgSpaces = numSpaces / (numWords - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> extraSpaces = numSpaces % (numWords - <span class="hljs-number">1</span>);<br>            string s1 = <span class="hljs-built_in">join</span>(words, left, left + extraSpaces + <span class="hljs-number">1</span>, <span class="hljs-built_in">blank</span>(avgSpaces + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 拼接额外加一个空格的单词</span><br>            string s2 = <span class="hljs-built_in">join</span>(words, left + extraSpaces + <span class="hljs-number">1</span>, right, <span class="hljs-built_in">blank</span>(avgSpaces)); <span class="hljs-comment">// 拼接其余单词</span><br>            ans.<span class="hljs-built_in">emplace_back</span>(s1 + <span class="hljs-built_in">blank</span>(avgSpaces) + s2);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-08 每日一题</title>
    <link href="/2021/09/08/2021.9.8%20daily%20problem/"/>
    <url>/2021/09/08/2021.9.8%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="502-IPO"><a href="#502-IPO" class="headerlink" title="502. IPO"></a><a href="https://leetcode-cn.com/problems/ipo/">502. IPO</a></h4><p>难度困难97</p><p>假设 力扣（LeetCode）即将开始 <strong>IPO</strong> 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 <code>k</code> 个不同的项目。帮助 力扣 设计完成最多 <code>k</code> 个不同项目后得到最大总资本的方式。</p><p>给你 <code>n</code> 个项目。对于每个项目 <code>i</code> ，它都有一个纯利润 <code>profits[i]</code> ，和启动该项目需要的最小资本 <code>capital[i]</code> 。</p><p>最初，你的资本为 <code>w</code> 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p><p>总而言之，从给定项目中选择 <strong>最多</strong> <code>k</code> 个不同项目的列表，以 <strong>最大化最终资本</strong> ，并输出最终可获得的最多资本。</p><p>答案保证在 32 位有符号整数范围内。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]<br>输出：4<br>解释：<br>由于你的初始资本为 0，你仅可以从<span class="hljs-number"> 0 </span>号项目开始。<br>在完成后，你将获得<span class="hljs-number"> 1 </span>的利润，你的总资本将变为 1。<br>此时你可以选择开始<span class="hljs-number"> 1 </span>号或<span class="hljs-number"> 2 </span>号项目。<br>由于你最多可以选择两个项目，所以你需要完成<span class="hljs-number"> 2 </span>号项目以获得最大的资本。<br>因此，输出最后最大化的资本，为<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 4。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：k = 3, w = 0, profits = <span class="hljs-comment">[1,2,3]</span>, capital = <span class="hljs-comment">[0,1,2]</span><br>输出：6<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= 105</code></li><li><code>0 &lt;= w &lt;= 109</code></li><li><code>n == profits.length</code></li><li><code>n == capital.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= profits[i] &lt;= 104</code></li><li><code>0 &lt;= capital[i] &lt;= 109</code></li></ul></li></ul><h2 id="方法一：大顶堆"><a href="#方法一：大顶堆" class="headerlink" title="方法一：大顶堆"></a>方法一：大顶堆</h2><p>虽说题目标成困难，但其实不算很难。</p><p>先理解题意，因为我们只能进行k次操作，所以直观来说，就是取出k次最赚的投资。</p><p>可是我们还有成本限制——于是我们可以：</p><p>每次把所有小于等于成本的操作进入堆，之后取出堆中最大的利润，把这个利润加入到成本里。（重复k次）</p><p>同样使用priority_queue实现最大堆。</p><p>PS：每次使用pair都会以为用箭头去访问first和second，但其实只需要一个’.’……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> w, vector&lt;<span class="hljs-type">int</span>&gt;&amp; profits, vector&lt;<span class="hljs-type">int</span>&gt;&amp; capital)</span> </span>&#123;<br>        priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt;&gt; dadingdui;<span class="hljs-comment">//大顶堆</span><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; cap_and_profit;<span class="hljs-comment">//把成本和收益捆绑起来</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;profits.<span class="hljs-built_in">size</span>();i++)&#123;<br>            cap_and_profit.<span class="hljs-built_in">push_back</span>(&#123;capital[i],profits[i]&#125;);<br>        &#125;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//一个单项遍历的辅助下标（因为后面排了序所以只需要前进）</span><br>        <span class="hljs-built_in">sort</span>(cap_and_profit.<span class="hljs-built_in">begin</span>(),cap_and_profit.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//按成本排序，以便后面的操作每次都能把所有小于等于w的成本放入堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-keyword">while</span>(cnt&lt;profits.<span class="hljs-built_in">size</span>()&amp;&amp;cap_and_profit[cnt].first&lt;=w)&#123;<br>                dadingdui.<span class="hljs-built_in">push</span>(cap_and_profit[cnt].second);<span class="hljs-comment">//把符合条件的操作压入</span><br>                cnt++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!dadingdui.<span class="hljs-built_in">empty</span>())&#123;<br>                w+=dadingdui.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取最大利润</span><br>                dadingdui.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//利润pop</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-07 每日一题</title>
    <link href="/2021/09/07/2021.9.7%20daily%20problem/"/>
    <url>/2021/09/07/2021.9.7%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1221-分割平衡字符串"><a href="#1221-分割平衡字符串" class="headerlink" title="1221. 分割平衡字符串"></a><a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/">1221. 分割平衡字符串</a></h4><p>难度简单111</p><p>在一个 <strong>平衡字符串</strong> 中，<code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 字符的数量是相同的。</p><p>给你一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p><p><strong>注意：</strong>分割得到的每个字符串都必须是平衡字符串。</p><p>返回可以通过分割得到的平衡字符串的 <strong>最大数量</strong> <strong>。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;RLRRLLRLRL&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：s 可以分割为 <span class="hljs-string">&quot;RL&quot;</span>、<span class="hljs-string">&quot;RRLL&quot;</span>、<span class="hljs-string">&quot;RL&quot;</span>、<span class="hljs-string">&quot;RL&quot;</span> ，每个子字符串中都包含相同数量的 &#x27;L&#x27; 和 &#x27;R&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;RLLLLRRRLR&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：s 可以分割为 <span class="hljs-string">&quot;RL&quot;</span>、<span class="hljs-string">&quot;LLLRRR&quot;</span>、<span class="hljs-string">&quot;LR&quot;</span> ，每个子字符串中都包含相同数量的 &#x27;L&#x27; 和 &#x27;R&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLLLRRRR&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：s 只能保持原样 <span class="hljs-string">&quot;LLLLRRRR&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;RLRRRLLRLL&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：s 可以分割为 <span class="hljs-string">&quot;RL&quot;</span>、<span class="hljs-string">&quot;RRRLLRLL&quot;</span> ，每个子字符串中都包含相同数量的 &#x27;L&#x27; 和 &#x27;R&#x27; 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i] = &#39;L&#39; 或 &#39;R&#39;</code></li><li><code>s</code> 是一个 <strong>平衡</strong> 字符串</li></ul></li></ul><h2 id="方法一：直接模拟"><a href="#方法一：直接模拟" class="headerlink" title="方法一：直接模拟"></a>方法一：直接模拟</h2><p>其实题目已经减轻了思考量，因为给出的字符串是平衡的，所以我们不需要考虑l，r出现次数不等的情况。</p><p>然后题目要求字符串分割，也就不是指子序列，就有点像括号匹配了。</p><p>最后要求切割的字符串尽可能多，那么就简单了。</p><p>准备三个计数器，L,R,ANS；</p><p>开始遍历：</p><p>如果L,R都空，那么就把当下字符对应的计数器增1；</p><p>如果L,R不空，把当下字符对应的计数器增1后如果两者相等，就给ANS增1，L,R置零。（因为要求最多，所以字串发生LR第一次相等的时候就是一个可切割的字串了）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">balancedStringSplit</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(l==<span class="hljs-number">0</span>&amp;&amp;r==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>                    r++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    l++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;R&#x27;</span>)&#123;<br>                    r++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(l==r)&#123;<br>                    ans++;<br>                    l=<span class="hljs-number">0</span>;<br>                    r=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-06 每日一题</title>
    <link href="/2021/09/06/2021.9.6%20daily%20problem/"/>
    <url>/2021/09/06/2021.9.6%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><p>难度简单</p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol></li></ul><h2 id="方法一：二分法"><a href="#方法一：二分法" class="headerlink" title="方法一：二分法"></a>方法一：二分法</h2><p>不写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> L = <span class="hljs-number">0</span>,R = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(L&lt;=R)&#123;<br>            <span class="hljs-keyword">if</span>(nums[(L+R)/<span class="hljs-number">2</span>]==target)&#123;<br>                ans = (L+R)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[(L+R)/<span class="hljs-number">2</span>]&gt;target)&#123;<br>                R = (L+R)/<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                L = (L+R)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-05 每日一题</title>
    <link href="/2021/09/05/2021.9.5%20daily%20problem/"/>
    <url>/2021/09/05/2021.9.5%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h4><p>难度中等</p><p>已有方法 <code>rand7</code> 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 1 到 10 范围内的均匀随机整数。</p><p>不要使用系统的 <code>Math.random()</code> 方法。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 1</span><br><span class="hljs-section">输出: [7]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 2</span><br><span class="hljs-section">输出: [8,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: 3</span><br><span class="hljs-section">输出: [8,1,10]</span><br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ol><li><code>rand7</code> 已定义。</li><li>传入参数: <code>n</code> 表示 <code>rand10</code> 的调用次数。</li></ol><p><strong>进阶:</strong></p><ol><li><code>rand7()</code>调用次数的 <a href="https://en.wikipedia.org/wiki/Expected_value">期望值</a> 是多少 ?</li><li>你能否尽量少调用 <code>rand7()</code> ?</li></ol></li></ul><h2 id="方法一：拒绝采样"><a href="#方法一：拒绝采样" class="headerlink" title="方法一：拒绝采样"></a>方法一：拒绝采样</h2><p>非常有趣的题目，思考的重点是使得1-10每个数出现的概率均等。</p><p>一开始想过直接两个rand7相加然后拒绝比10大的结果，但显然这个方法既取不到1，2-10每个数出现的概率也不相同。</p><p>于是考虑相乘取出现概率相等的10个数来表示1-10，理论上可行但是有点嫌麻烦（其实49以内就可以找到10个概率均等的乘积）。</p><p>但是最后考虑了像是掷骰子的情况，2个骰子6面组合一共有36个结果假设不考虑骰子点数大小，只根据出现情况构造36格子的方阵，这样把超过30的情况去掉，把每轮实验数字模10+1就可以返回结果了，同样在这道题里构造49格的方阵把超过40的拒绝掉，1-40出现的概率均等从而构造出来的1-10的出现概率也均等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// The rand7() API is already defined for you.</span><br><span class="hljs-comment">// int rand7();</span><br><span class="hljs-comment">// @return a random integer in the range 1 to 7</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> r, c, ans;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//这种方法才是正确的打表方法，直接两个相乘是构造不了49格的</span><br>        <span class="hljs-keyword">while</span>(flag==<span class="hljs-number">0</span>)&#123;<br>            r = <span class="hljs-number">7</span>*(<span class="hljs-built_in">rand7</span>()<span class="hljs-number">-1</span>);<span class="hljs-comment">//这里要-1，否则万一取到了7，c+r就会大于49且取不到1-7</span><br>            c = <span class="hljs-built_in">rand7</span>();<br>            <span class="hljs-type">int</span> temp = r+c;<br>            <span class="hljs-keyword">if</span>(temp&lt;=<span class="hljs-number">40</span>)&#123;<br>                ans = temp%<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-04 每日一题</title>
    <link href="/2021/09/04/2021.9.4%20daily%20problem/"/>
    <url>/2021/09/04/2021.9.4%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></h4><p>难度简单</p><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span> = <span class="hljs-number">0</span>,   <span class="hljs-built_in">F</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">F</span><span class="hljs-params">(N)</span></span> = <span class="hljs-built_in">F</span>(N - <span class="hljs-number">1</span>) + <span class="hljs-built_in">F</span>(N - <span class="hljs-number">2</span>), 其中 N &gt; <span class="hljs-number">1</span>.<br></code></pre></td></tr></table></figure><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>不写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            arr[i] = (arr[i<span class="hljs-number">-1</span>] + arr[i<span class="hljs-number">-2</span>])%<span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-03 每日一题</title>
    <link href="/2021/09/03/2021.9.3%20daily%20problem/"/>
    <url>/2021/09/03/2021.9.3%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="面试题-17-14-最小K个数"><a href="#面试题-17-14-最小K个数" class="headerlink" title="面试题 17.14. 最小K个数"></a><a href="https://leetcode-cn.com/problems/smallest-k-lcci/">面试题 17.14. 最小K个数</a></h4><p>难度中等83</p><p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p><p><strong>示例：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入： arr = [<span class="hljs-number">1,3,5,7</span>,<span class="hljs-number">2,4,6,8</span>], k = <span class="hljs-number">4</span><br>输出： [<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= len(arr) &lt;= 100000</code></li><li><code>0 &lt;= k &lt;= min(100000, len(arr))</code></li></ul></li></ul><h2 id="方法一：大顶堆"><a href="#方法一：大顶堆" class="headerlink" title="方法一：大顶堆"></a>方法一：大顶堆</h2><p>今年找工作的时候看到过这样的题目，相当于是已经学过了。</p><p>就是维护一个堆，里面存着最小的k个数，然后我们也不需要管堆的排列，只需要知道堆中目前最大的元素是什么。</p><p>遍历的时候比较数组的数与堆中最大数孰大熟小，如果比堆中最大数要小，那就把堆中最大数拿出来，当前的数放进去，重新维护一个最大堆。</p><p>很明显，优先队列的数据结构是符合我们要求的，每次访问优先队列的头元素就是最小k个数里的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">smallestK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-comment">//less代表降序，greater代表升序</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            q.<span class="hljs-built_in">push</span>(arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">top</span>()&gt;arr[i])&#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>                q.<span class="hljs-built_in">push</span>(arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//注释部分我感觉跟前面是一样的但是不知道哪里有问题，有测例过不去</span><br>        <span class="hljs-comment">/*for(auto &amp;a:arr)&#123;</span><br><span class="hljs-comment">            if(q.size()&lt;k)&#123;</span><br><span class="hljs-comment">                q.push(a);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            if(q.size()==k)&#123;</span><br><span class="hljs-comment">                if(q.top()&gt;a)&#123;</span><br><span class="hljs-comment">                    q.pop();</span><br><span class="hljs-comment">                    q.push(a);</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;*/</span><br>        <span class="hljs-comment">//问题找到了，在第k个元素压进去之后刚好满足了size=k的判断，有可能导致多压进去一次</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-02 每日一题</title>
    <link href="/2021/09/02/2021.9.2%20daily%20problem/"/>
    <url>/2021/09/02/2021.9.2%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">剑指 Offer 22. 链表中倒数第k个节点</a></h4><p>难度简单</p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p><p><strong>示例：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 k = <span class="hljs-number">2.</span><br><br>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>指针p先走k步，然后p和q一起走，直至p到尾，返回q。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *p,*q;<br>        q = head,p = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k ; i++)&#123;<br>            p = p -&gt; next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-09-01 每日一题</title>
    <link href="/2021/09/01/2021.9.1%20daily%20problem/"/>
    <url>/2021/09/01/2021.9.1%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/">165. 比较版本号</a></h4><p>难度中等</p><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 <code>1</code> 和修订号 <code>001</code> <strong>相等</strong> 。如果版本号没有指定某个下标处的修订号，则该修订号视为 <code>0</code> 。例如，版本 <code>1.0</code> 小于版本 <code>1.1</code> ，因为它们下标为 <code>0</code> 的修订号相同，而下标为 <code>1</code> 的修订号分别为 <code>0</code> 和 <code>1</code> ，<code>0 &lt; 1</code> 。</p><p>返回规则如下：</p><ul><li>如果 <code>*version1* &gt; *version2*</code> 返回 <code>1</code>，</li><li>如果 <code>*version1* &lt; *version2*</code> 返回 <code>-1</code>，</li><li>除此之外返回 <code>0</code>。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.01&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.001&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：忽略前导零，<span class="hljs-string">&quot;01&quot;</span> 和 <span class="hljs-string">&quot;001&quot;</span> 都表示相同的整数 <span class="hljs-string">&quot;1&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.0.0&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：versio<span class="hljs-symbol">n1</span> 没有指定下标为 <span class="hljs-number">2</span> 的修订号，即视为 <span class="hljs-string">&quot;0&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1.1&quot;</span><br>输出：<span class="hljs-number">-1</span><br>解释：versio<span class="hljs-symbol">n1</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;0&quot;</span>，versio<span class="hljs-symbol">n2</span> 中下标为 <span class="hljs-number">0</span> 的修订号是 <span class="hljs-string">&quot;1&quot;</span> 。<span class="hljs-number">0</span> &lt; <span class="hljs-number">1</span>，所以 versio<span class="hljs-symbol">n1</span> &lt; versio<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;1.0.1&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：versio<span class="hljs-symbol">n1</span> = <span class="hljs-string">&quot;7.5.2.4&quot;</span>, versio<span class="hljs-symbol">n2</span> = <span class="hljs-string">&quot;7.5.3&quot;</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= version1.length, version2.length &lt;= 500</code></li><li><code>version1</code> 和 <code>version2</code> 仅包含数字和 <code>&#39;.&#39;</code></li><li><code>version1</code> 和 <code>version2</code> 都是 <strong>有效版本号</strong></li><li><code>version1</code> 和 <code>version2</code> 的所有修订号都可以存储在 <strong>32 位整数</strong> 中</li></ul></li></ul><h2 id="方法一：分割数组"><a href="#方法一：分割数组" class="headerlink" title="方法一：分割数组"></a>方法一：分割数组</h2><p>一开始的方法是把每个隔间的数逐个求和，但例如“0.51”和“0.15”是不一样的，所以隔间内5+1和1+5相等但前者比后面大，人生蒸发了10分钟……</p><p>于是就把每个隔间的数转成int类型吧！就有了下面的代码，因为比较累赘所以在代码做了不少注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(string version1, string version2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">max</span>(version1.<span class="hljs-built_in">size</span>(),version2.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-comment">//这个n用于记录比较数组的长度，为了放置越界，两个记录数组都使用较长版本号的长度</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t1</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t2</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//初始化</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<span class="hljs-comment">//left，代表子数组的最左侧，0是初始位置</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录数组的下标，用这个方法把隔间隔开</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;version1.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(version1[i]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<span class="hljs-comment">//每次遍历到&#x27;.&#x27;时就代表一个隔间</span><br>                string a = version1.<span class="hljs-built_in">substr</span>(l,i-l);<span class="hljs-comment">//取出该隔间的子字符串，注意substr的参数</span><br>                <span class="hljs-type">int</span> temp = <span class="hljs-built_in">stoi</span>(a);<span class="hljs-comment">//转整数</span><br>                t1[j] = temp;<br>                j++;<span class="hljs-comment">//下标递增</span><br>                l = i+<span class="hljs-number">1</span>;<span class="hljs-comment">//将l修改成下一个隔间的初始位</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(i==version1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>                <span class="hljs-comment">//这里的处理是相同的，只是因为字符串最后是没有&#x27;.&#x27;的，所以要特别处理</span><br>                <span class="hljs-comment">//当然其实也可以直接在版本号后面压入一个&#x27;.&#x27;来把这个特殊情况去掉</span><br>                string a = version1.<span class="hljs-built_in">substr</span>(l,i+<span class="hljs-number">1</span>-l);<br>                <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>                temp = <span class="hljs-built_in">stoi</span>(a);<br>                t1[j] = temp;<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//下面是对版本号2相同的处理</span><br>        l=<span class="hljs-number">0</span>;<br>        j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;version2.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(version2[i]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>                string a = version2.<span class="hljs-built_in">substr</span>(l,i-l);<br>                <span class="hljs-type">int</span> temp = <span class="hljs-built_in">stoi</span>(a);<br>                t2[j] = temp;<br>                j++;<br>                l = i+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i==version2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>                string a = version2.<span class="hljs-built_in">substr</span>(l,i+<span class="hljs-number">1</span>-l);<br>                <span class="hljs-type">int</span> temp = <span class="hljs-built_in">stoi</span>(a);<br>                t2[j] = temp;<br>                j++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//比较大小，比较每一个隔间的数孰大孰小，在第一次能比较出大小就要返回了</span><br>            <span class="hljs-keyword">if</span>(t1[i]&gt;t2[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t1[i]&lt;t2[i])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-31 每日一题</title>
    <link href="/2021/08/31/2021.8.31%20daily%20problem/"/>
    <url>/2021/08/31/2021.8.31%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h4><p>难度中等</p><p>这里有 <code>n</code> 个航班，它们分别从 <code>1</code> 到 <code>n</code> 进行编号。</p><p>有一份航班预订表 <code>bookings</code> ，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [firsti, lasti, seatsi]</code> 意味着在从 <code>firsti</code> 到 <code>lasti</code> （<strong>包含</strong> <code>firsti</code> 和 <code>lasti</code> ）的 <strong>每个航班</strong> 上预订了 <code>seatsi</code> 个座位。</p><p>请你返回一个长度为 <code>n</code> 的数组 <code>answer</code>，其中 <code>answer[i]</code> 是航班 <code>i</code> 上预订的座位总数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5<br>输出：[10,55,45,25,25]<br>解释：<br>航班编号       <span class="hljs-number"> 1 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span>  5<br>预订记录<span class="hljs-number"> 1 </span>：  <span class="hljs-number"> 10 </span> 10<br>预订记录<span class="hljs-number"> 2 </span>：      <span class="hljs-number"> 20 </span> 20<br>预订记录<span class="hljs-number"> 3 </span>：      <span class="hljs-number"> 25 </span><span class="hljs-number"> 25 </span><span class="hljs-number"> 25 </span> 25<br>总座位数：     <span class="hljs-number"> 10 </span><span class="hljs-number"> 55 </span><span class="hljs-number"> 45 </span><span class="hljs-number"> 25 </span> 25<br>因此，answer = [10,55,45,25,25]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：bookings = <span class="hljs-comment">[<span class="hljs-comment">[1,2,10]</span>,<span class="hljs-comment">[2,2,15]</span>]</span>, n = 2<br>输出：<span class="hljs-comment">[10,25]</span><br>解释：<br>航班编号        1   2<br>预订记录 1 ：   10  10<br>预订记录 2 ：       15<br>总座位数：      10  25<br>因此，answer = <span class="hljs-comment">[10,25]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>1 &lt;= bookings.length &lt;= 2 * 104</code></li><li><code>bookings[i].length == 3</code></li><li><code>1 &lt;= firsti &lt;= lasti &lt;= n</code></li><li><code>1 &lt;= seatsi &lt;= 104</code></li></ul></li></ul><h2 id="方法一：差分数组"><a href="#方法一：差分数组" class="headerlink" title="方法一：差分数组"></a>方法一：差分数组</h2><p>看到题目第一时间就是暴力双重循环，没有思考里面的规律，双重循环运算1亿次必然超时。</p><p>这次学到了新的技能，差分数组，用一个数组记录每个元素跟前一个元素的增量，最后对差分数组进行前缀和求和处理就是目的数组。</p><p>例子：对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2]。</p><p>于是在这道题里面，对每一次预定进行连续航班的座位添加，而我们可以发现在这个连续范围内相邻元素的增量是0，所以我们只需要处理开头的元素和结尾的元素。特别的，题目中航班从1开始，所以在订单的范围[l,r]中，我们对total[l-1]进行“增加预定席位的数目”，而对total[r]进行“减少预定席位的数目”。这里不是取r-1的原因是，l-1到r-1就是本该想着预定的航班，但是前缀和求和的时候前面的和会影响后面的元素，所以要在下标r的位置把上一轮的影响减去。</p><p>而很明显，这种只对两个位置的修改是可以叠加的，所以我们只需要每轮都做这样的工作就可以。</p><p>特别的，我们不能取到下标n，要多加一个判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">corpFlightBookings</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; bookings, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">total</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;bookings.<span class="hljs-built_in">size</span>();i++)&#123;<br>            total[bookings[i][<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>] += bookings[i][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(bookings[i][<span class="hljs-number">1</span>]&lt;n)&#123;<span class="hljs-comment">//因为如果数组在下标n就会越界，只需要到n-1</span><br>                total[bookings[i][<span class="hljs-number">1</span>]] -= bookings[i][<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            total[i] = total[i<span class="hljs-number">-1</span>]+total[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-29 每日一题</title>
    <link href="/2021/08/29/2021.8.29%20daily%20problem/"/>
    <url>/2021/08/29/2021.8.29%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1588-所有奇数长度子数组的和"><a href="#1588-所有奇数长度子数组的和" class="headerlink" title="1588. 所有奇数长度子数组的和"></a><a href="https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/">1588. 所有奇数长度子数组的和</a></h4><p>难度简单</p><p>给你一个正整数数组 <code>arr</code> ，请你计算所有可能的奇数长度子数组的和。</p><p><strong>子数组</strong> 定义为原数组中的一个连续子序列。</p><p>请你返回 <code>arr</code> 中 <strong>所有奇数长度子数组的和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[1,4,2,5,3]</span><br>输出：58<br>解释：所有奇数长度子数组和它们的和为：<br><span class="hljs-comment">[1]</span> = 1<br><span class="hljs-comment">[4]</span> = 4<br><span class="hljs-comment">[2]</span> = 2<br><span class="hljs-comment">[5]</span> = 5<br><span class="hljs-comment">[3]</span> = 3<br><span class="hljs-comment">[1,4,2]</span> = 7<br><span class="hljs-comment">[4,2,5]</span> = 11<br><span class="hljs-comment">[2,5,3]</span> = 10<br><span class="hljs-comment">[1,4,2,5,3]</span> = 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[1,2]</span><br>输出：3<br>解释：总共只有 2 个长度为奇数的子数组，<span class="hljs-comment">[1]</span> 和 <span class="hljs-comment">[2]</span>。它们的和为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：arr </span>=<span class="hljs-string"> [10,11,12]</span><br><span class="hljs-string">输出：66</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>按照1，3，5，……这种奇数长度分别模拟求和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOddLengthSubarrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans =<span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//按奇数长度分组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=n-i;k++)&#123;<span class="hljs-comment">//每次分组后每个子数列的起始位置（防止越界）</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<span class="hljs-comment">//子数组的长度</span><br>                    ans += arr[j+k];<br>                &#125;<br>            &#125;<br>            i++;<span class="hljs-comment">//把长度分成两次加，就不会导致越界</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-29 每日一题</title>
    <link href="/2021/08/29/2021.8.30%20daily%20problem/"/>
    <url>/2021/08/29/2021.8.30%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="528-按权重随机选择"><a href="#528-按权重随机选择" class="headerlink" title="528. 按权重随机选择"></a><a href="https://leetcode-cn.com/problems/random-pick-with-weight/">528. 按权重随机选择</a></h4><p>难度中等</p><p>给定一个正整数数组 <code>w</code> ，其中 <code>w[i]</code> 代表下标 <code>i</code> 的权重（下标从 <code>0</code> 开始），请写一个函数 <code>pickIndex</code> ，它可以随机地获取下标 <code>i</code>，选取下标 <code>i</code> 的概率与 <code>w[i]</code> 成正比。</p><p>例如，对于 <code>w = [1, 3]</code>，挑选下标 <code>0</code> 的概率为 <code>1 / (1 + 3) = 0.25</code> （即，25%），而选取下标 <code>1</code> 的概率为 <code>3 / (1 + 3) = 0.75</code>（即，75%）。</p><p>也就是说，选取下标 <code>i</code> 的概率为 <code>w[i] / sum(w)</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;Solution&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>]<br>[[[<span class="hljs-number">1</span>]],[]]<br>输出：<br>[null,<span class="hljs-number">0</span>]<br>解释：<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>]);<br>solution.pickIndex(); // 返回 <span class="hljs-number">0</span>，因为数组中只有一个元素，所以唯一的选择是返回下标 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;Solution&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>,<span class="hljs-string">&quot;pickIndex&quot;</span>]<br>[[[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]],[],[],[],[],[]]<br>输出：<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>解释：<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]);<br>solution.pickIndex(); // 返回 <span class="hljs-number">1</span>，返回下标 <span class="hljs-number">1</span>，返回该下标概率为 <span class="hljs-number">3</span>/<span class="hljs-number">4</span> 。<br>solution.pickIndex(); // 返回 <span class="hljs-number">1</span><br>solution.pickIndex(); // 返回 <span class="hljs-number">1</span><br>solution.pickIndex(); // 返回 <span class="hljs-number">1</span><br>solution.pickIndex(); // 返回 <span class="hljs-number">0</span>，返回下标 <span class="hljs-number">0</span>，返回该下标概率为 <span class="hljs-number">1</span>/<span class="hljs-number">4</span> 。<br><br>由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>[null,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>......<br>诸若此类。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= w.length &lt;= 10000</code></li><li><code>1 &lt;= w[i] &lt;= 10^5</code></li><li><code>pickIndex</code> 将被调用不超过 <code>10000</code> 次</li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>老实说一大早看到这种题有点懵，不过还是看懂了，但C++里有些函数之前没用过，用繁琐啰嗦的方式写了几遍都有问题，看答案去了。。。</p><p>求出前缀和表。paritial_sum()就是求前缀和，w[0] &#x3D; W[0], w[1] &#x3D; W[0] + W[1]…如此推算<br>求出前缀和表后最后一位数所包含的就是所有数字的和。用以上的例子 w.back() 最终会包含 1 + 2 + 3 + 4 &#x3D; 10<br>求出一个随机数，rand() % w.back(); 假设 w.back() &#x3D; 10, 那么这里产生的数字是 0-9。如果我们继续用以上的例子的话那么其每个数字所对应取到的index便为：<br>0 ：代表取到 index 0<br>1，2: 代表取到 index 1<br>3，4，5: 代表取到 index 2<br>6，7, 8, 9: 代表取到 index 3<br>用以上的例子产生的前缀和表 [1, 3, 6, 10], 可以发现我们用得到的数字调用 upper_bound() 会刚好使其指向我们的 index 位置。<br>0 的 upper_bound 会指向 index 0, 因为第一个比 0 大的数是 w[0] &#x3D; 1;<br>1, 2 的 upper_bound 会指向 index 1, 因为第一个比 1 或者 2 大的数是 w[1] &#x3D; 3;<br>3，4，5 的 upper_bound 会指向 index 2, 因为第一个比 {3, 4, 5} 大的数是 w[2] &#x3D; 6;<br>6，7, 8, 9 的 upper_bound 会指向 index 3, 因为第一个比 {6，7, 8, 9} 大的数是 w[3] &#x3D; 10;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    mt19937 gen;<br>    uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; dis;<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; w): <span class="hljs-built_in">gen</span>(random_device&#123;&#125;()), <span class="hljs-built_in">dis</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">accumulate</span>(w.<span class="hljs-built_in">begin</span>(), w.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-built_in">partial_sum</span>(w.<span class="hljs-built_in">begin</span>(), w.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(pre));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">dis</span>(gen);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">lower_bound</span>(pre.<span class="hljs-built_in">begin</span>(), pre.<span class="hljs-built_in">end</span>(), x) - pre.<span class="hljs-built_in">begin</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-28 每日一题</title>
    <link href="/2021/08/28/2021.8.28%20daily%20problem/"/>
    <url>/2021/08/28/2021.8.28%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/">1480. 一维数组的动态和</a></h4><p>难度简单</p><p>给你一个数组 <code>nums</code> 。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code> 。</p><p>请返回 <code>nums</code> 的动态和。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,2,3,4]<br>输出：[1,3,6,10]<br>解释：动态和计算过程为 [1, 1<span class="hljs-string">+2</span>, 1<span class="hljs-string">+2</span><span class="hljs-string">+3</span>, 1<span class="hljs-string">+2</span><span class="hljs-string">+3</span><span class="hljs-string">+4</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,1,1,1,1]<br>输出：[1,2,3,4,5]<br>解释：动态和计算过程为 [1, 1<span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span>, 1<span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span><span class="hljs-string">+1</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,2,10,1]</span><br>输出：<span class="hljs-string">[3,4,6,16,17]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul></li></ul><h2 id="方法一：前缀和"><a href="#方法一：前缀和" class="headerlink" title="方法一：前缀和"></a>方法一：前缀和</h2><p>每次把前面的和累积起来。</p><p>可以新开ans数组保存答案，不过反正原数组也没用所以直接原地修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">runningSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            nums[i] = nums[i<span class="hljs-number">-1</span>]+nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-27 每日一题</title>
    <link href="/2021/08/27/2021.8.27%20daily%20problem/"/>
    <url>/2021/08/27/2021.8.27%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h4><p>难度困难468</p><p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">1.5</span><br><span class="hljs-function"><span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span> <br><span class="hljs-function"><span class="hljs-title">findMedian</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ol><li>如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？</li><li>如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</li></ol></li></ul><h2 id="方法一：双堆"><a href="#方法一：双堆" class="headerlink" title="方法一：双堆"></a>方法一：双堆</h2><p>建立两个堆，一个比中位数小，另一个比中位数大，小堆按从大到小排列，大堆按从小到大排列。那么在元素个数是偶数的时候，只要取出两个堆的头部元素除以二就可以；元素个数在奇数的时候，取出更长的堆的头部即可。</p><p>双堆维护要点如下：</p><p>用优先队列实现压入侧排序；</p><p>当堆为空的时候，压入小堆；</p><p>当当前元素比大堆最小元素要小的时候，压入小堆；否则压入大堆。</p><p>当每轮处理完，两堆长度差值不能超过2；所以在逻辑上要这样处理：当处理完后大堆更长，pop一个元素到小堆；当处理完后小堆比大堆长2，pop一个元素到大堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//priority_queue&lt;Type, Container, Functional&gt;优先队列定义，太久没用都忘记了</span><br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; queMin;<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; queMax;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">empty</span>() || num &lt;= queMin.<span class="hljs-built_in">top</span>()) &#123;<br>            queMin.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> &lt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMax.<span class="hljs-built_in">push</span>(queMin.<span class="hljs-built_in">top</span>());<br>                queMin.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queMax.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() &gt; queMin.<span class="hljs-built_in">size</span>()) &#123;<br>                queMin.<span class="hljs-built_in">push</span>(queMax.<span class="hljs-built_in">top</span>());<br>                queMax.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">size</span>() &gt; queMax.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> queMin.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (queMin.<span class="hljs-built_in">top</span>() + queMax.<span class="hljs-built_in">top</span>()) *<span class="hljs-number">0.5</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>进阶解法贴一下官方的：</p><h3 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶 1"></a>进阶 1</h3><p>如果数据流中所有整数都在 0 到 100 范围内，那么我们可以利用计数排序统计每一类数的数量，并使用双指针维护中位数。</p><h3 id="进阶-2"><a href="#进阶-2" class="headerlink" title="进阶 2"></a>进阶 2</h3><p>如果数据流中 99% 的整数都在 0 到 100 范围内，那么我们依然利用计数排序统计每一类数的数量，并使用双指针维护中位数。对于超出范围的数，我们可以单独进行处理，建立两个数组，分别记录小于 0 的部分的数的数量和大于 100 的部分的数的数量即可。当小部分时间，中位数不落在区间 [0,100] 中时，我们在对应的数组中暴力检查即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-26 每日一题</title>
    <link href="/2021/08/26/2021.8.26%20daily%20problem/"/>
    <url>/2021/08/26/2021.8.26%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="881-救生艇"><a href="#881-救生艇" class="headerlink" title="881. 救生艇"></a><a href="https://leetcode-cn.com/problems/boats-to-save-people/">881. 救生艇</a></h4><p>难度中等151</p><p>第 <code>i</code> 个人的体重为 <code>people[i]</code>，每艘船可以承载的最大重量为 <code>limit</code>。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 <code>limit</code>。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例 1：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：people = [1,2], <span class="hljs-built_in">limit</span> = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], limit = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 艘船分别载 <span class="hljs-comment">(1, 2)</span>, <span class="hljs-comment">(2)</span> 和 <span class="hljs-comment">(3)</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：people = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], limit = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">4</span><br>解释：<span class="hljs-number">4</span> 艘船分别载 <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(3)</span>, <span class="hljs-comment">(4)</span>, <span class="hljs-comment">(5)</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= people.length &lt;= 50000</code></li><li><code>1 &lt;= people[i] &lt;= limit &lt;= 30000</code></li></ul></li></ul><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>一开始的想法是按照高斯求和法把数组对折起来相加，然后每一组和如果超过limit就配两艘，但是显然不可行，因为可能会有一艘船只坐了很轻的一个人。所以稍微优化一下，先考虑最重的人要能上船，如果最轻的+最重的不超过limit，那他们显然是合适的。但如果超过了limit，也不代表最轻的不能跟其他人配对。</p><p>于是解法就是，以体重为标准排序，然后前面的指针每round都指向最轻的，后面的指针每round都指向最重的，直至所有人都上船（因为可能每次问题规模缩小都有可能导致剩下的人数是奇数个，所以while条件是小于等于）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRescueBoats</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; people, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> thin = <span class="hljs-number">0</span>,heavy = people.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(thin&lt;=heavy)&#123;<br>            <span class="hljs-keyword">if</span>(people[thin]+people[heavy]&gt;limit)&#123;<br>                ans++;<br>                heavy--;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans++;<br>                heavy--;<br>                thin++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：排队模拟（超时）"><a href="#方法二：排队模拟（超时）" class="headerlink" title="方法二：排队模拟（超时）"></a>方法二：排队模拟（超时）</h2><p>这个方法是一开始没有留意数据的规模，看到题目就直接上手但超时的。。。稍微记录一下。</p><p>也是从最重的开始上船，但是每一轮上船的时候从头开始检测每艘船的剩余重量是否能使当前轮的人坐上去，就是双重循环，时间复杂度O(n^2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRescueBoats</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; people, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; boat;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; valid;<br>        <span class="hljs-built_in">reverse</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;people.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(boat.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>                boat.<span class="hljs-built_in">push_back</span>(people[i]);<br>                valid.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;boat.<span class="hljs-built_in">size</span>();j++)&#123;<br>                    <span class="hljs-keyword">if</span>(limit-boat[j]&gt;=people[i]&amp;&amp;valid[j]==<span class="hljs-number">1</span>)&#123;<br>                        valid[j]++;<br>                        flag=<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>                    boat.<span class="hljs-built_in">push_back</span>(people[i]);<br>                    valid.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> boat.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-25 每日一题</title>
    <link href="/2021/08/25/2021.8.25%20daily%20problem/"/>
    <url>/2021/08/25/2021.8.25%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h4><p>难度中等162</p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p><p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1,2],[3],[3],[]]</span><br>输出：<span class="hljs-string">[[0,1,3],[0,2,3]]</span><br>解释：有两条路径 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">1</span> -&gt; <span class="hljs-number">3</span> 和 <span class="hljs-number">0</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[4,3,1]</span>,<span class="hljs-comment">[3,2,4]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[4]</span>,<span class="hljs-comment">[]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[0,3,4]</span>,<span class="hljs-comment">[0,1,3,4]</span>,<span class="hljs-comment">[0,1,2,3,4]</span>,<span class="hljs-comment">[0,1,4]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1],[]]</span><br>输出：<span class="hljs-string">[[0,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1,2,3],[2],[3],[]]</span><br>输出：<span class="hljs-string">[[0,1,2,3],[0,2,3],[0,3]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：graph = <span class="hljs-string">[[1,3],[2],[3],[]]</span><br>输出：<span class="hljs-string">[[0,1,2,3],[0,3]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即，不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul></li></ul><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><p>首先选用DFS不用标记是因为题目告知了保证输入是有向无环图并且graph[i]中所有元素都不相同。</p><p>然后问的是从0点出发找到n-1点，跟一般的全遍历稍微不一样，所以每次我们从0点出发做深搜，搜到n-1就停。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; s;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g,<span class="hljs-type">int</span> src,<span class="hljs-type">int</span> dst)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(src == dst)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;f:g[src])&#123;<span class="hljs-comment">//遍历每一个当前点可以访问的点</span><br>            s.<span class="hljs-built_in">push_back</span>(f);<span class="hljs-comment">//直接push（f）是因为规定了从0点开始，而主函数一开始就把0压入数组了</span><br>            <span class="hljs-built_in">dfs</span>(g,f,dst);<br>            s.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//用vector直接popback就可以直接把每一轮的结果直接压入ans，不需要做结构转换</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph) &#123;<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(graph,<span class="hljs-number">0</span>,graph.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-24 每日一题</title>
    <link href="/2021/08/24/2021.8.24%20daily%20problem/"/>
    <url>/2021/08/24/2021.8.24%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="787-K-站中转内最便宜的航班"><a href="#787-K-站中转内最便宜的航班" class="headerlink" title="787. K 站中转内最便宜的航班"></a><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班</a></h4><p>难度中等</p><p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组 <code>flights</code> ，其中 <code>flights[i] = [fromi, toi, pricei]</code> ，表示该航班都从城市 <code>fromi</code> 开始，以价格 <code>pricei</code> 抵达 <code>toi</code>。</p><p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code> 站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <br>n = <span class="hljs-number">3</span>, edges = <span class="hljs-string">[[0,1,100],[1,2,100],[0,2,500]]</span><br>src = <span class="hljs-number">0</span>, dst = <span class="hljs-number">2</span>, k = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">200</span><br>解释: <br>城市航班图如下<br><br><br>从城市 <span class="hljs-number">0</span> 到城市 <span class="hljs-number">2</span> 在 <span class="hljs-number">1</span> 站中转以内的最便宜价格是 <span class="hljs-number">200</span>，如图中红色所示。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: <br>n = <span class="hljs-number">3</span>, edges = <span class="hljs-string">[[0,1,100],[1,2,100],[0,2,500]]</span><br>src = <span class="hljs-number">0</span>, dst = <span class="hljs-number">2</span>, k = <span class="hljs-number">0</span><br>输出: <span class="hljs-number">500</span><br>解释: <br>城市航班图如下<br><br><br>从城市 <span class="hljs-number">0</span> 到城市 <span class="hljs-number">2</span> 在 <span class="hljs-number">0</span> 站中转以内的最便宜价格是 <span class="hljs-number">500</span>，如图中蓝色所示。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li><li><code>flights[i].length == 3</code></li><li><code>0 &lt;= fromi, toi &lt; n</code></li><li><code>fromi != toi</code></li><li><code>1 &lt;= pricei &lt;= 104</code></li><li>航班没有重复，且不存在自环</li><li><code>0 &lt;= src, dst, k &lt; n</code></li><li><code>src != dst</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>这次的动态规划有点绕，他的状态是cost[i][j]。代表中转i次到达j处。然后以次数做循环，算出到不同点所需要的次数，最后遍历次数内到达目标的向量组找出最小值返回就行。主要是找到动态规划的状态转移式，以及循环上限是小于等于k+1 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">10000</span> * <span class="hljs-number">101</span> + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">cost</span>(k+<span class="hljs-number">2</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,INF));<br>        cost[<span class="hljs-number">0</span>][src] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=k+<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;j : flights)&#123;<br>                <span class="hljs-type">int</span> beg = j[<span class="hljs-number">0</span>],des = j[<span class="hljs-number">1</span>],f_cost = j[<span class="hljs-number">2</span>]; <br>                cost[i][des] = <span class="hljs-built_in">min</span>(cost[i<span class="hljs-number">-1</span>][beg]+f_cost,cost[i][des]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=k+<span class="hljs-number">1</span>;i++)&#123;<br>            ans = <span class="hljs-built_in">min</span>(ans,cost[i][dst]);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(ans==INF)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-23 每日一题</title>
    <link href="/2021/08/23/2021.8.23%20daily%20problem/"/>
    <url>/2021/08/23/2021.8.23%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1646-获取生成数组中的最大值"><a href="#1646-获取生成数组中的最大值" class="headerlink" title="1646. 获取生成数组中的最大值"></a><a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/">1646. 获取生成数组中的最大值</a></h4><p>难度简单17</p><p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p><ul><li><code>nums[0] = 0</code></li><li><code>nums[1] = 1</code></li><li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li><li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li></ul><p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 7<br>输出：3<br>解释：根据规则：<br>  nums<span class="hljs-comment">[0]</span> = 0<br>  nums<span class="hljs-comment">[1]</span> = 1<br>  nums<span class="hljs-comment">[(1 * 2) = 2]</span> = nums<span class="hljs-comment">[1]</span> = 1<br>  nums<span class="hljs-comment">[(1 * 2) + 1 = 3]</span> = nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = 1 + 1 = 2<br>  nums<span class="hljs-comment">[(2 * 2) = 4]</span> = nums<span class="hljs-comment">[2]</span> = 1<br>  nums<span class="hljs-comment">[(2 * 2) + 1 = 5]</span> = nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[3]</span> = 1 + 2 = 3<br>  nums<span class="hljs-comment">[(3 * 2) = 6]</span> = nums<span class="hljs-comment">[3]</span> = 2<br>  nums<span class="hljs-comment">[(3 * 2) + 1 = 7]</span> = nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = 2 + 1 = 3<br>因此，nums = <span class="hljs-comment">[0,1,1,2,1,3,2,3]</span>，最大值 3<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 2<br>输出：1<br>解释：根据规则，nums<span class="hljs-comment">[0]</span>、nums<span class="hljs-comment">[1]</span> 和 nums<span class="hljs-comment">[2]</span> 之中的最大值是 1<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 3<br>输出：2<br>解释：根据规则，nums<span class="hljs-comment">[0]</span>、nums<span class="hljs-comment">[1]</span>、nums<span class="hljs-comment">[2]</span> 和 nums<span class="hljs-comment">[3]</span> 之中的最大值是 2<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 100</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>直接按照题目给出的要求给数组的奇偶项赋值，最后返回最大值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMaximumGenerated</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//因为下面代码从2开始，所以把两个特例直接返回</span><br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        nums[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        nums[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                nums[i] = nums[i/<span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                nums[i] = nums[i/<span class="hljs-number">2</span>] + nums[i/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-22 每日一题</title>
    <link href="/2021/08/22/2021.8.22%20daily%20problem/"/>
    <url>/2021/08/22/2021.8.22%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="789-逃脱阻碍者"><a href="#789-逃脱阻碍者" class="headerlink" title="789. 逃脱阻碍者"></a><a href="https://leetcode-cn.com/problems/escape-the-ghosts/">789. 逃脱阻碍者</a></h4><p>难度中等52</p><p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是 <code>target = [xtarget, ytarget]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从 <code>ghosts[i] = [xi, yi]</code> 出发。所有输入均为 <strong>整数坐标</strong> 。</p><p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p><p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。</p><p>只有在你有可能成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：ghosts = <span class="hljs-string">[[1,0],[0,3]]</span>, target = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br>解释：你可以直接一步到达目的地 (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) ，在 (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) 或者 (<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) 位置的阻碍者都不可能抓住你。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：ghosts = <span class="hljs-string">[[1,0]]</span>, target = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：你需要走到位于 (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>) 的目的地，但是在 (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) 的阻碍者位于你和目的地之间。 <br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：ghosts = <span class="hljs-string">[[2,0]]</span>, target = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：阻碍者可以和你同时达到目的地。 <br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：ghosts = <span class="hljs-comment">[<span class="hljs-comment">[5,0]</span>,<span class="hljs-comment">[-10,-2]</span>,<span class="hljs-comment">[0,-5]</span>,<span class="hljs-comment">[-2,-2]</span>,<span class="hljs-comment">[-7,1]</span>]</span>, target = <span class="hljs-comment">[7,7]</span><br>输出：false<br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：ghosts = <span class="hljs-comment">[<span class="hljs-comment">[-1,0]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[-1,0]</span>,<span class="hljs-comment">[0,1]</span>,<span class="hljs-comment">[-1,0]</span>]</span>, target = <span class="hljs-comment">[0,0]</span><br>输出：true<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ghosts.length &lt;= 100</code></li><li><code>ghosts[i].length == 2</code></li><li><code>-104 &lt;= xi, yi &lt;= 104</code></li><li>同一位置可能有 <strong>多个阻碍者</strong> 。</li><li><code>target.length == 2</code></li><li><code>-104 &lt;= xtarget, ytarget &lt;= 104</code></li></ul></li></ul><h2 id="方法一：曼哈顿距离"><a href="#方法一：曼哈顿距离" class="headerlink" title="方法一：曼哈顿距离"></a>方法一：曼哈顿距离</h2><p>为了逃脱阻碍者，玩家应按照最短路径向目的地移动。阻碍者为了抓住玩家，也会按照最短路径向目的地移动。由于每次移动为向四个方向之一移动一个单位，因此对于玩家和阻碍者而言，到达目的地的最短路径的距离为当前所在位置和目的地的曼哈顿距离。</p><p>用 \text{dist}(A, B)dist(A,B) 表示 AA 点和 BB 点的曼哈顿距离，曼哈顿距离的计算方法如下：</p><p>\text{dist}(A, B) &#x3D; \big| x_A - x_B \big| + \big| y_A - y_B \big|<br>dist(A,B)&#x3D;<br>∣<br>∣<br>∣</p><p> x<br>A</p><p> −x<br>B</p><p>∣<br>∣<br>∣</p><p> +<br>∣<br>∣<br>∣</p><p> y<br>A</p><p> −y<br>B</p><p>∣<br>∣<br>∣</p><p>如果有一个阻碍者和目的地的曼哈顿距离小于玩家和目的地的曼哈顿距离，则该阻碍者可以在玩家之前到达目的地，然后停在目的地，玩家无法逃脱。</p><p>如果有一个阻碍者和目的地的曼哈顿距离等于玩家和目的地的曼哈顿距离，则该阻碍者可以和玩家同时到达目的地，玩家也无法逃脱。</p><p>如果所有的阻碍者和目的地的曼哈顿距离都大于玩家和目的地的曼哈顿距离，则玩家可以在阻碍者之前到达目的地。</p><p>如果玩家可以在阻碍者之前到达目的地，是否可能出现阻碍者在玩家前往目的地的中途拦截？答案是否定的，证明如下。</p><blockquote><p>假设目的地是 TT，初始时玩家位于 SS，阻碍者位于 GG，阻碍者在 XX 点拦截玩家。</p><p>由于阻碍者和目的地的曼哈顿距离大于玩家和目的地的曼哈顿距离，因此 \text{dist}(G, T) &gt; \text{dist}(S, T)dist(G,T)&gt;dist(S,T)。</p><p>由于玩家会按照最短路径向目的地移动，因此如果阻碍者在 XX 点拦截玩家，则 XX 点一定在玩家前往目的地的最短路径上，满足 \text{dist}(S, X) + \text{dist}(X, T) &#x3D; \text{dist}(S, T)dist(S,X)+dist(X,T)&#x3D;dist(S,T)。</p><p>由于 XX 点是拦截点，因此阻碍者到达 XX 点的时间早于或等于玩家到达 XX 点的时间，即 \text{dist}(G, X) \le \text{dist}(S, X)dist(G,X)≤dist(S,X)。</p><p>因此有：</p><p>\begin{aligned} \text{dist}(G, X) &amp;\le \text{dist}(S, X) \ \text{dist}(G, X) + \text{dist}(X, T) &amp;\le \text{dist}(S, X) + \text{dist}(X, T) \ \text{dist}(G, X) + \text{dist}(X, T) &amp;\le \text{dist}(S, T) \end{aligned}<br>dist(G,X)<br>dist(G,X)+dist(X,T)<br>dist(G,X)+dist(X,T)</p><p>≤dist(S,X)<br>≤dist(S,X)+dist(X,T)<br>≤dist(S,T)</p><p>由于阻碍者到目的地的最短路径长度是 \text{dist}(G, T)dist(G,T)，因此有</p><p>\text{dist}(G, T) \le \text{dist}(G, X) + \text{dist}(X, T) \le \text{dist}(S, T)<br>dist(G,T)≤dist(G,X)+dist(X,T)≤dist(S,T)</p><p>和条件 \text{dist}(G, T) &gt; \text{dist}(S, T)dist(G,T)&gt;dist(S,T) 矛盾。</p><p>因此当 \text{dist}(G, T) &gt; \text{dist}(S, T)dist(G,T)&gt;dist(S,T) 时，阻碍者不可能在玩家前往目的地的中途拦截，玩家可以成功逃脱。</p><p>基于上述分析，问题简化为计算玩家和目的地的曼哈顿距离以及每个阻碍者和目的地的曼哈顿距离，判断玩家是否可以在阻碍者之前到达目的地。</p><p>如果存在至少一个阻碍者和目的地的曼哈顿距离小于或等于玩家和目的地的曼哈顿距离，返回 \text{false}false；</p><p>如果所有阻碍者和目的地的曼哈顿距离都大于玩家和目的地的曼哈顿距离，返回 \text{true}true。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">manhattanDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; point1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; point2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(point1[<span class="hljs-number">0</span>] - point2[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">abs</span>(point1[<span class="hljs-number">1</span>] - point2[<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">escapeGhosts</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ghosts, vector&lt;<span class="hljs-type">int</span>&gt;&amp; target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">source</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-type">int</span> distance = <span class="hljs-built_in">manhattanDistance</span>(source, target);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ghost : ghosts) &#123;<br>            <span class="hljs-type">int</span> ghostDistance = <span class="hljs-built_in">manhattanDistance</span>(ghost, target);<br>            <span class="hljs-keyword">if</span> (ghostDistance &lt;= distance) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-21 每日一题</title>
    <link href="/2021/08/21/2021.8.21%20daily%20problem/"/>
    <url>/2021/08/21/2021.8.21%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a href="https://leetcode-cn.com/problems/string-compression/">443. 压缩字符串</a></h4><p>难度中等</p><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p><p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p><ul><li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li><li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li></ul><p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p><p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p><p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：chars = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>输出：返回 <span class="hljs-number">6</span> ，输入数组的前 <span class="hljs-number">6</span> 个字符应该是：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>解释：<br><span class="hljs-string">&quot;aa&quot;</span> 被 <span class="hljs-string">&quot;a2&quot;</span> 替代。<span class="hljs-string">&quot;bb&quot;</span> 被 <span class="hljs-string">&quot;b2&quot;</span> 替代。<span class="hljs-string">&quot;ccc&quot;</span> 被 <span class="hljs-string">&quot;c3&quot;</span> 替代。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：chars = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出：返回 <span class="hljs-number">1</span> ，输入数组的前 <span class="hljs-number">1</span> 个字符应该是：[<span class="hljs-string">&quot;a&quot;</span>]<br>解释：<br>没有任何字符串被替代。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：chars = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]<br>输出：返回 <span class="hljs-number">4</span> ，输入数组的前 <span class="hljs-number">4</span> 个字符应该是：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>]。<br>解释：<br>由于字符 <span class="hljs-string">&quot;a&quot;</span> 不重复，所以不会被压缩。<span class="hljs-string">&quot;bbbbbbbbbbbb&quot;</span> 被 “b12” 替代。<br>注意每个数字在数组中都有它自己的位置。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= chars.length &lt;= 2000</code></li><li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li></ul></li></ul><h2 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h2><p>双指针，本来计算是很好算的，但是仔细一看题目说是要对原字符串进行修改，那就头大了，我对数组移位有天生的抗拒，忍不住去看答案了。</p><blockquote><p>为了实现原地压缩，我们可以使用双指针分别标志我们在字符串中读和写的位置。每次当读指针 \textit{read}read 移动到某一段连续相同子串的最右侧，我们就在写指针 \textit{write}write 处依次写入该子串对应的字符和子串长度即可。</p><p>在实际代码中，当读指针 \textit{read}read 位于字符串的末尾，或读指针 \textit{read}read 指向的字符不同于下一个字符时，我们就认为读指针 \textit{read}read 位于某一段连续相同子串的最右侧。该子串对应的字符即为读指针 \textit{read}read 指向的字符串。我们使用变量 \textit{left}left 记录该子串的最左侧的位置，这样子串长度即为 \textit{read} - \textit{left} + 1read−left+1。</p><p>特别地，为了达到 O(1)O(1) 空间复杂度，我们需要自行实现将数字转化为字符串写入到原字符串的功能。这里我们采用短除法将子串长度倒序写入原字符串中，然后再将其反转即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compress</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; chars)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = chars.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> write = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> read = <span class="hljs-number">0</span>; read &lt; n; read++) &#123;<br>            <span class="hljs-keyword">if</span> (read == n - <span class="hljs-number">1</span> || chars[read] != chars[read + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">//这里还是很巧妙的，不用移位的原因是假如要插入压缩，重复字母的长度一定比插入的数字长，因为就算只有连续两个重复，插入一个2，跟原长度相等，不会把非相同字母覆盖掉。</span><br>                <span class="hljs-comment">//然后用一个指针读前进，一个指针写前进即可。</span><br>                chars[write++] = chars[read];<br>                <span class="hljs-type">int</span> num = read - left + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> anchor = write;<br>                    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>                        chars[write++] = num % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>                        num /= <span class="hljs-number">10</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">reverse</span>(&amp;chars[anchor], &amp;chars[write]);<br>                &#125;<br>                left = read + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> write;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-19 每日一题</title>
    <link href="/2021/08/20/2021.8.19%20daily%20problem/"/>
    <url>/2021/08/20/2021.8.19%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code> ，仅反转字符串中的所有元音字母，并返回结果字符串。</p><p>元音字母包括 <code>&#39;a&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;o&#39;</code>、<code>&#39;u&#39;</code>，且可能以大小写两种形式出现。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span><br>输出：<span class="hljs-string">&quot;holle&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;leotcede&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由 <strong>可打印的 ASCII</strong> 字符组成</li></ul></li></ul><h2 id="方法一：遍历校验"><a href="#方法一：遍历校验" class="headerlink" title="方法一：遍历校验"></a>方法一：遍历校验</h2><p>使用栈的先进后出的特性，先往前遍历一遍元音字母压入栈。</p><p>然后再从头开始遍历一次取栈顶即可。注意大写字母也是要考虑别的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; zhan;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;a&#x27;</span>||s[i]==<span class="hljs-string">&#x27;e&#x27;</span>||s[i]==<span class="hljs-string">&#x27;i&#x27;</span>||s[i]==<span class="hljs-string">&#x27;o&#x27;</span>||s[i]==<span class="hljs-string">&#x27;u&#x27;</span>||s[i]==<span class="hljs-string">&#x27;A&#x27;</span>||s[i]==<span class="hljs-string">&#x27;E&#x27;</span>||s[i]==<span class="hljs-string">&#x27;I&#x27;</span>||s[i]==<span class="hljs-string">&#x27;O&#x27;</span>||s[i]==<span class="hljs-string">&#x27;U&#x27;</span>)&#123;<br>                zhan.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;a&#x27;</span>||s[i]==<span class="hljs-string">&#x27;e&#x27;</span>||s[i]==<span class="hljs-string">&#x27;i&#x27;</span>||s[i]==<span class="hljs-string">&#x27;o&#x27;</span>||s[i]==<span class="hljs-string">&#x27;u&#x27;</span>||s[i]==<span class="hljs-string">&#x27;A&#x27;</span>||s[i]==<span class="hljs-string">&#x27;E&#x27;</span>||s[i]==<span class="hljs-string">&#x27;I&#x27;</span>||s[i]==<span class="hljs-string">&#x27;O&#x27;</span>||s[i]==<span class="hljs-string">&#x27;U&#x27;</span>)&#123;<br>                s[i] = zhan.<span class="hljs-built_in">top</span>();<br>                zhan.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：双指针遍历"><a href="#方法二：双指针遍历" class="headerlink" title="方法二：双指针遍历"></a>方法二：双指针遍历</h2><p>就是前后都取一个下标，分别记为A,B指针。A往前走直到找到下一个元音字母，然后B再往后走直到找到下一个元音字母。当A&gt;&#x3D;B时结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-20 每日一题</title>
    <link href="/2021/08/20/2021.8.20%20daily%20problem/"/>
    <url>/2021/08/20/2021.8.20%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>难度简单159</p><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每 <code>2k</code> 个字符反转前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcdefg&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;bacdfeg&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abcd&quot;</span>, <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;bacd&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul></li></ul><h2 id="方法一：模拟遍历"><a href="#方法一：模拟遍历" class="headerlink" title="方法一：模拟遍历"></a>方法一：模拟遍历</h2><p>依题意，只要每次走以2k为区间处理就行，每次往前反转k个位置，处理完之后给标记点加2k代表前进2k步。当最后剩下的长度小于k的时候分类讨论，特殊处理将那部分全部反转即可。</p><p>然后使用栈先进后出的特性来反转子序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; re;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n&lt;=s.<span class="hljs-built_in">length</span>())&#123;<br>            <span class="hljs-keyword">if</span>(n+k&gt;s.<span class="hljs-built_in">length</span>())&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>                    re.<span class="hljs-built_in">push</span>(s[i]);<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;s.<span class="hljs-built_in">length</span>();i++)&#123;<br>                    s[i] = re.<span class="hljs-built_in">top</span>();<br>                    re.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;n+k;i++)&#123;<br>                    re.<span class="hljs-built_in">push</span>(s[i]);<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;n+k;i++)&#123;<br>                    s[i] = re.<span class="hljs-built_in">top</span>();<br>                    re.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>            n+=<span class="hljs-number">2</span>*k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-18 每日一题</title>
    <link href="/2021/08/18/2021.8.18%20daily%20problem/"/>
    <url>/2021/08/18/2021.8.18%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="552-学生出勤记录-II"><a href="#552-学生出勤记录-II" class="headerlink" title="552. 学生出勤记录 II"></a><a href="https://leetcode-cn.com/problems/student-attendance-record-ii/">552. 学生出勤记录 II</a></h4><p>难度困难</p><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p><ul><li><code>&#39;A&#39;</code>：Absent，缺勤</li><li><code>&#39;L&#39;</code>：Late，迟到</li><li><code>&#39;P&#39;</code>：Present，到场</li></ul><p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p><ul><li>按 <strong>总出勤</strong> 计，学生缺勤（<code>&#39;A&#39;</code>）<strong>严格</strong> 少于两天。</li><li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 3 天以上的迟到（<code>&#39;L&#39;</code>）记录。</li></ul><p>给你一个整数 <code>n</code> ，表示出勤记录的长度（次数）。请你返回记录长度为 <code>n</code> 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">8</span><br>解释：<br>有 <span class="hljs-number">8</span> 种长度为 <span class="hljs-number">2</span> 的记录将被视为可奖励：<br><span class="hljs-string">&quot;PP&quot;</span> , <span class="hljs-string">&quot;AP&quot;</span>, <span class="hljs-string">&quot;PA&quot;</span>, <span class="hljs-string">&quot;LP&quot;</span>, <span class="hljs-string">&quot;PL&quot;</span>, <span class="hljs-string">&quot;AL&quot;</span>, <span class="hljs-string">&quot;LA&quot;</span>, <span class="hljs-string">&quot;LL&quot;</span> <br>只有<span class="hljs-string">&quot;AA&quot;</span>不会被视为可奖励，因为缺勤次数为 <span class="hljs-number">2</span> 次（需要少于 <span class="hljs-number">2</span> 次）。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">10101</span><br>输出：<span class="hljs-number">183236316</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 105</code></li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>顶不住，为什么每次我完全没有思路官答都是给动态规划，我动态规划有没有这么菜。。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>)));  <span class="hljs-comment">// 长度，A 的数量，结尾连续 L 的数量</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 以 P 结尾的数量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">2</span>; k++) &#123;<br>                    dp[i][j][<span class="hljs-number">0</span>] = (dp[i][j][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][j][k]) % MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 以 A 结尾的数量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">2</span>; k++) &#123;<br>                dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = (dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>][k]) % MOD;<br>            &#125;<br>            <span class="hljs-comment">// 以 L 结尾的数量</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">2</span>; k++) &#123;<br>                    dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="hljs-number">1</span>][j][k - <span class="hljs-number">1</span>]) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">2</span>; k++) &#123;<br>                sum = (sum + dp[n][j][k]) % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>可以使用动态规划计算可奖励的出勤记录的数量。</p><p>由于可奖励的出勤记录要求缺勤次数少于 22 和连续迟到次数少于 33，因此动态规划的状态由总天数、缺勤次数和结尾连续迟到次数决定（由于不会记录连续迟到次数等于或多于 33 的情况，因此非结尾的连续迟到次数一定少于 33，只需要记录结尾连续迟到次数即可）。</p><p>定义 \textit{dp}[i][j][k]dp[i][j][k] 表示前 ii 天有 jj 个 \text{<code>A&#39;&#125;‘A’ 且结尾有连续 kk 个 \text&#123;</code>L’}‘L’ 的可奖励的出勤记录的数量，其中 0 \le i \le n0≤i≤n，0 \le j \le 10≤j≤1，0 \le k \le 20≤k≤2。</p><p>当 i&#x3D;0i&#x3D;0 时，没有任何出勤记录，此时 \text{<code>A&#39;&#125;‘A’ 的数量和结尾连续 \text&#123;</code>L’}‘L’ 的数量一定是 00，因此动态规划的边界情况是 \textit{dp}[0][0][0] &#x3D; 1dp[0][0][0]&#x3D;1。</p><p>当 1 \le i \le n1≤i≤n 时，\textit{dp}[i][][]dp[i][][] 的值从 \textit{dp}[i-1][][]dp[i−1][][] 的值转移得到，计算每个状态的值需要考虑第 ii 天的出勤记录：</p><p>如果第 ii 天的出勤记录是 \text{<code>P&#39;&#125;‘P’，则前 ii 天和前 i-1i−1 天的出勤记录相比，\text&#123;</code>A’}‘A’ 的数量不变，结尾连续 \text{&#96;L’}‘L’ 的数量清零，因此对 0 \le j \le 10≤j≤1，有<br>\textit{dp}[i][j][0] :&#x3D; \textit{dp}[i][j][0] + \sum_{k&#x3D;0}^2 \textit{dp}[i-1][j][k]<br>dp[i][j][0]:&#x3D;dp[i][j][0]+<br>k&#x3D;0<br>∑<br>2</p><p> dp[i−1][j][k]</p><p>如果第 ii 天的出勤记录是 \text{<code>A&#39;&#125;‘A’，则前 ii 天和前 i-1i−1 天的出勤记录相比，\text&#123;</code>A’}‘A’ 的数量加 11，结尾连续 \text{<code>L&#39;&#125;‘L’ 的数量清零，此时要求前 i-1i−1 天的出勤记录记录中的 \text&#123;</code>A’}‘A’ 的数量必须为 00，否则前 ii 天的出勤记录至少有 22 个 \text{&#96;A’}‘A’，不满足可奖励的条件，因此有<br>\textit{dp}[i][1][0] :&#x3D; \textit{dp}[i][1][0] + \sum_{k&#x3D;0}^2 \textit{dp}[i-1][0][k]<br>dp[i][1][0]:&#x3D;dp[i][1][0]+<br>k&#x3D;0<br>∑<br>2</p><p> dp[i−1][0][k]</p><p>如果第 ii 天的出勤记录是 \text{<code>L&#39;&#125;‘L’，则前 ii 天和前 i-1i−1 天的出勤记录相比，\text&#123;</code>A’}‘A’ 的数量不变，结尾连续 \text{<code>L&#39;&#125;‘L’ 的数量加 11，此时要求前 i-1i−1 天的出勤记录记录中的结尾连续 \text&#123;</code>L’}‘L’ 的数量不超过 22，否则前 ii 天的出勤记录的结尾至少有 33 个 \text{&#96;L’}‘L’，不满足可奖励的条件，因此对 0 \le j \le 10≤j≤1 和 1 \le k \le 21≤k≤2，有<br>\textit{dp}[i][j][k] :&#x3D; \textit{dp}[i][j][k] + \textit{dp}[i-1][j][k-1]<br>dp[i][j][k]:&#x3D;dp[i][j][k]+dp[i−1][j][k−1]</p><p>上述状态转移方程对于 i&#x3D;1i&#x3D;1 也适用。</p><p>计算长度为 nn 的所有可奖励的出勤记录的数量，即为计算 \textit{dp}[n][][]dp[n][][] 的所有元素之和。计算过程中需要将结果对 10^9+7取模。</p><p>根据上述思路，可以得到时间复杂度和空间复杂度都是 O(n)O(n) 的实现。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-17 每日一题</title>
    <link href="/2021/08/17/2021.8.17%20daily%20problem/"/>
    <url>/2021/08/17/2021.8.17%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="551-学生出勤记录-I"><a href="#551-学生出勤记录-I" class="headerlink" title="551. 学生出勤记录 I"></a><a href="https://leetcode-cn.com/problems/student-attendance-record-i/">551. 学生出勤记录 I</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p><ul><li><code>&#39;A&#39;</code>：Absent，缺勤</li><li><code>&#39;L&#39;</code>：Late，迟到</li><li><code>&#39;P&#39;</code>：Present，到场</li></ul><p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p><ul><li>按 <strong>总出勤</strong> 计，学生缺勤（<code>&#39;A&#39;</code>）<strong>严格</strong> 少于两天。</li><li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 3 天以上的迟到（<code>&#39;L&#39;</code>）记录。</li></ul><p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;PPALLP&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：学生缺勤次数少于 <span class="hljs-number">2</span> 次，且不存在 <span class="hljs-number">3</span> 天或以上的连续迟到记录。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;PPALLL&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：学生最后三天连续迟到，所以不满足出勤奖励的条件。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 为 <code>&#39;A&#39;</code>、<code>&#39;L&#39;</code> 或 <code>&#39;P&#39;</code></li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>过于简单，不说了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkRecord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> queqin = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> chidao = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                queqin++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-2</span>]==<span class="hljs-string">&#x27;L&#x27;</span>)&#123;<br>                            chidao = <span class="hljs-number">0</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(queqin&gt;=<span class="hljs-number">2</span>||chidao==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-16 每日一题</title>
    <link href="/2021/08/16/2021.8.16%20daily%20problem/"/>
    <url>/2021/08/16/2021.8.16%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a><a href="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列</a></h4><p>难度中等</p><p>假设有从 1 到 N 的 <strong>N</strong> 个整数，如果从这 <strong>N</strong> 个数字中成功构造出一个数组，使得数组的第 <strong>i</strong> 位 (1 &lt;&#x3D; i &lt;&#x3D; N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p><ol><li>第 <strong>i</strong> 位的数字能被 <strong>i</strong> 整除</li><li><strong>i</strong> 能被第 <strong>i</strong> 位上的数字整除</li></ol><p>现在给定一个整数 N，请问可以构造多少个优美的排列？</p><p><strong>示例1:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入: 2<br>输出: 2<br>解释: <br><br>第 1 个优美的排列是 [1, 2]:<br>  第 1 个位置（<span class="hljs-attribute">i</span>=1）上的数字是1，1能被 i（<span class="hljs-attribute">i</span>=1）整除<br>  第 2 个位置（<span class="hljs-attribute">i</span>=2）上的数字是2，2能被 i（<span class="hljs-attribute">i</span>=2）整除<br><br>第 2 个优美的排列是 [2, 1]:<br>  第 1 个位置（<span class="hljs-attribute">i</span>=1）上的数字是2，2能被 i（<span class="hljs-attribute">i</span>=1）整除<br>  第 2 个位置（<span class="hljs-attribute">i</span>=2）上的数字是1，i（i=2）能被 1 整除<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><strong>N</strong> 是一个正整数，并且不会超过15。</li></ol></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>反向思考，从边界出发往里算，最后到出发点结束，dp[k][i][j]表示k次到(i,j)的路径数，按k遍历，上下左右次数一加就是当前格次数。（通过把当前格子的上一步的状态来表示四个方向移动到这个格子的次数，就不用考虑往回走了，好思路）</p><p>k &#x3D; 1 时只有边界有值，因为上下左右加了，所以不需要考虑3*1格子的特殊情况，次数会正常算。由于只有从边界经过的格子会有值，一圈一圈往里更新，上下左右计算可以考虑到所有情况。且多余的步数会继续更新方法数，逻辑完备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-comment">// 用 mask 的二进制表示选取状态，n 个数字用 n 位表示，第 i 位为 1 代表数字 i+1 已被选取（i从0开始），n 中 1 的个数 m 代表前 m 位已放置</span><br>   <span class="hljs-comment">// 例如：二进制 100110 共三个1，代表排列的前三位已放置数字，三个1分别在二进制第 1、2、5位置上(从右侧开始，从0开始计数）, 所以 2、3、6三个数字被选取，综合起来就是表示：2 3 6 这三个数字被放到了排列的前三位，三个数字完美排列方式未知，通过枚举 mask 进行计算</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 用来存储中间结果，f[6] = f[000110] = 数字2、3在前两位时的完美排列数量</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 通过 mask 进行枚举，最终目的是为了得到二进制 mask = (11..11)n 时，总的完美排列数 </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mask = <span class="hljs-number">1</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); mask++) &#123;<br>            <span class="hljs-type">int</span> num = __builtin_popcount(mask);<br>            <span class="hljs-comment">// 遍历 mask 的每一位，仍以 mask = 100110 为例，此 mask 代表 2 3 6三个数字在排列的前三位</span><br>                 <span class="hljs-comment">// 求三个数字 2 3 6 的完美排列方式，则先确定2 3 6哪些数字能放到第三位，然后累加另外两个数字的完美排列数量来获得</span><br>                 <span class="hljs-comment">// 2 3 6，第三位可以为 6，则 f[100110] += f[000110] (2、3在前两位时的完美排列数量)</span><br>                 <span class="hljs-comment">// 2 3 6，第三位可以为 3，则 f[100110] += f[100010] (2、6在前两位时的完美排列数量)</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-comment">// mask &amp; (1&lt;&lt;i) 用来判断 mask 第 i 位是否为 1，如果为 1，说明第 i+1 个数字被选取</span><br>                     <span class="hljs-comment">// ((num % (i + 1)) == 0 || (i + 1) % num == 0) 判断被选取的数字 i+1 能否放到位置 num 上，</span><br>                     <span class="hljs-comment">// 即：先从被选取的数字中找到能放到最高位 num 的数字，然后将剩余 num-1 个数字的完美排列方式累加到f[mask]中</span><br>                <span class="hljs-keyword">if</span> (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i) &amp;&amp; (num % (i + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> || (i + <span class="hljs-number">1</span>) % num == <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-comment">// mask ^ (1 &lt;&lt; i) 将 mask 第 i 位设置为 0</span><br>                    f[mask] += f[mask ^ (<span class="hljs-number">1</span> &lt;&lt; i)];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="方法二：回溯"><a href="#方法二：回溯" class="headerlink" title="方法二：回溯"></a>方法二：回溯</h2><p>从左向右依次向目标排列中放入数即可。</p><p>具体地，我们定义函数 \textit{backtrack}(\textit{index}, n)backtrack(index,n)，表示尝试向位置 \textit{index}index 放入数。其中 nn 表示排列的长度。在当前函数中，我们首先找到一个符合条件的未被使用过的数，然后递归地执行 \textit{backtrack}(\textit{index}+1, n)backtrack(index+1,n)，当该函数执行完毕，回溯到当前层，我们再尝试下一个符合条件的未被使用过的数即可。</p><p>回溯过程中，我们可以用 \textit{vis}vis 数组标记哪些数被使用过，每次我们选中一个数 xx，我们就将 \textit{vis}[x]vis[x] 标记为 \texttt{true}true，回溯完成后，我们再将其置为 \texttt{false}false。</p><p>特别地，为了优化回溯效率，我们可以预处理每个位置的符合条件的数有哪些，用二维数组 \textit{match}match 保存。当我们尝试向位置 \textit{index}index 放入数时，我们只需要遍历 \textit{match}[\textit{index}]match[index] 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; match;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vis;<br>    <span class="hljs-type">int</span> num;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == n + <span class="hljs-number">1</span>) &#123;<br>            num++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;x : match[index]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[x]) &#123;<br>                vis[x] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">backtrack</span>(index + <span class="hljs-number">1</span>, n);<br>                vis[x] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vis.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>        match.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span> || j % i == <span class="hljs-number">0</span>) &#123;<br>                    match[i].<span class="hljs-built_in">push_back</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">backtrack</span>(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-15 每日一题</title>
    <link href="/2021/08/15/2021.8.15%20daily%20problem/"/>
    <url>/2021/08/15/2021.8.15%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1583-统计不开心的朋友"><a href="#1583-统计不开心的朋友" class="headerlink" title="1583. 统计不开心的朋友"></a><a href="https://leetcode-cn.com/problems/count-unhappy-friends/">1583. 统计不开心的朋友</a></h4><p>难度中等19</p><p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p><p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高****到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p><p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [xi, yi]</code> 表示 <code>xi</code> 与 <code>yi</code> 配对，且 <code>yi</code> 与 <code>xi</code> 配对。</p><p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p><ul><li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li><li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li></ul><p>返回 <strong>不开心的朋友的数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]<br>输出：2<br>解释：<br>朋友<span class="hljs-number"> 1 </span>不开心，因为：<br>-<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>配对，但<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 3 </span>的亲近程度比<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>高，且<br>-<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 1 </span>的亲近程度比<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>高。<br>朋友<span class="hljs-number"> 3 </span>不开心，因为：<br>-<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>配对，但<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 1 </span>的亲近程度比<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>高，且<br>-<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 3 </span>的亲近程度比<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>高。<br>朋友<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>都是开心的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, preferences = <span class="hljs-string">[[1], [0]]</span>, <span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1, 0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：朋友 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 都开心。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, preferences = <span class="hljs-string">[[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]</span>, <span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1, 3], [0, 2]]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 500</code></li><li><code>n</code> 是偶数</li><li><code>preferences.length == n</code></li><li><code>preferences[i].length == n - 1</code></li><li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li><li><code>preferences[i]</code> 不包含 <code>i</code></li><li><code>preferences[i]</code> 中的所有值都是独一无二的</li><li><code>pairs.length == n/2</code></li><li><code>pairs[i].length == 2</code></li><li><code>xi != yi</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>反向思考，从边界出发往里算，最后到出发点结束，dp[k][i][j]表示k次到(i,j)的路径数，按k遍历，上下左右次数一加就是当前格次数。（通过把当前格子的上一步的状态来表示四个方向移动到这个格子的次数，就不用考虑往回走了，好思路）</p><p>k &#x3D; 1 时只有边界有值，因为上下左右加了，所以不需要考虑3*1格子的特殊情况，次数会正常算。由于只有从边界经过的格子会有值，一圈一圈往里更新，上下左右计算可以考虑到所有情况。且多余的步数会继续更新方法数，逻辑完备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// DP2: AC (think reverse, the problem is equivalent to starting from outside, in k steps</span><br><span class="hljs-comment">// how many ways to arrive at postion (r, c))</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> K, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">long</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(K + <span class="hljs-number">1</span>, vector&lt;vector&lt;<span class="hljs-type">long</span>&gt;&gt;(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">long</span>&gt;(n, <span class="hljs-number">0</span>)));<br>        <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= K; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-type">long</span> up = (i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[k - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>][j]);<br>                    <span class="hljs-type">long</span> down = (i == m - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : dp[k - <span class="hljs-number">1</span>][i + <span class="hljs-number">1</span>][j]);<br>                    <span class="hljs-type">long</span> left = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : dp[k - <span class="hljs-number">1</span>][i][j - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-type">long</span> right = (j == n - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : dp[k - <span class="hljs-number">1</span>][i][j + <span class="hljs-number">1</span>]);<br>                    dp[k][i][j] = (up + down + left + right) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>            <span class="hljs-keyword">return</span> dp[K][r][c]; <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一届鹏思杯战报</title>
    <link href="/2021/08/14/2021_SYSU_1ST_Championship/"/>
    <url>/2021/08/14/2021_SYSU_1ST_Championship/</url>
    
    <content type="html"><![CDATA[<h1 id="2021年8月第一届中大鹏思杯"><a href="#2021年8月第一届中大鹏思杯" class="headerlink" title="2021年8月第一届中大鹏思杯"></a>2021年8月第一届中大鹏思杯</h1><h3 id="R1-电脑堺"><a href="#R1-电脑堺" class="headerlink" title="R1 电脑堺"></a>R1 电脑堺</h3><p>骰子赢 OO</p><p>G1开下准备对面丢了个灰被指，出神光对面跑。</p><p>G2对面卡手，豸豸点青龙EP拿了个瑞瑞过了，然后做完，对面跑了。</p><h3 id="R2-火灵天星"><a href="#R2-火灵天星" class="headerlink" title="R2 火灵天星"></a>R2 火灵天星</h3><p>骰子赢 OO</p><p>G1顺利做完，神光6子弹，对面过不了，赢了。</p><p>G2朱光炸小火，到我准备+下准备打完。</p><h3 id="R3-骚灵"><a href="#R3-骚灵" class="headerlink" title="R3 骚灵"></a>R3 骚灵</h3><p>骰子输 OO</p><p>G1对面不能成功展开盖2过，然后被我天霆扫完反压。</p><p>G2对面傀儡师找完盖3过，到我拉闸出花龙然后神光压制。</p><h3 id="R4-随风旅鸟"><a href="#R4-随风旅鸟" class="headerlink" title="R4 随风旅鸟"></a>R4 随风旅鸟</h3><p>骰子赢 OXO</p><p>G1先攻吃G，但用宣告者预言出神光解放神巫拉地外刷够子弹，对面突破不了就赢。</p><p>G2对面顺利展开，做了大企鹅和追加通召的陷阱还有场地，我这边全家开会尝试突破，但是吃了手牌的灰和DD乌鸦，凑齐怪兽对面开陷阱把怪全盖不给叠放，输。</p><p>G3自己做完然后就赢了。</p><h3 id="半决赛"><a href="#半决赛" class="headerlink" title="半决赛"></a>半决赛</h3><p>骰子赢 OO</p><p>G1顺利展开对面没鸟。</p><p>G2对面盖3后（2月书1追加通召）但是手里还是没鸟，然后我后攻拿先攻手牌，直接刷够子弹压制。</p><h3 id="决赛-电脑堺"><a href="#决赛-电脑堺" class="headerlink" title="决赛 电脑堺"></a>决赛 电脑堺</h3><p>骰子赢 OXX</p><p>G1胡了，吃了灰指了G。</p><p>G2topdeck神巫炸VFD吃墓指 走。</p><p>G3开仪式的下准备就吃了灰。手里只有Δ和弁天，就做了淑女+圣枪+2组珠光（墓地没留弁天留了淑女）。SP丢圣枪，对面通召娘娘然后瑞瑞，拆了，对面三战抽2发老老，拆了。然后topdeck γ但是Δ叫效果吃了G，抽了灰，思考一下卡组耗了子弹卡组没什么战力了，于是想顶G，途中因为紧张，解错了一次怪（不过有陨石，结局一样）然后拿了弁天之后他丢锁鸟，开辉巧群对面丢陨石，停牌。对面通召豸豸然后瑞瑞，灰了；对面说错了然后做了鹫鹫盖一后就过了，我回合第一发检索就吃了锁鸟接枪，我断定后面是朱雀，然后出LL，不变书呆压天霆扫场。最后用辉巧群把神光拉起来，手里一个朱光做子弹。到对面拍青龙，无了。</p><p>这里其实有想过直接留一组子弹（朱光+弁天）防青龙，这样对面3hand只要不是3张电脑堺就能拦下来，但是怕再过一回合，topdeck没抽到能让墓地龙辉巧跳的卡，选择了自己有续航的打法，但是吃了青龙，遗憾。</p><h3 id="个人碎碎念"><a href="#个人碎碎念" class="headerlink" title="个人碎碎念"></a>个人碎碎念</h3><p>这次真的非常感谢两位深圳的师弟组织中大线上赛，我作为群主一直没给大家组织过活动，虽然也跟自己个人的时运和学业情况有关系，但这次能跟校友们打比赛并且圆满成功，还是很开心的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>YUGIOH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-14 每日一题</title>
    <link href="/2021/08/14/2021.8.14%20daily%20problem/"/>
    <url>/2021/08/14/2021.8.14%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1583-统计不开心的朋友"><a href="#1583-统计不开心的朋友" class="headerlink" title="1583. 统计不开心的朋友"></a><a href="https://leetcode-cn.com/problems/count-unhappy-friends/">1583. 统计不开心的朋友</a></h4><p>难度中等19</p><p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code> 总是 <strong>偶数</strong> 。</p><p>对每位朋友 <code>i</code>，<code>preferences[i]</code> 包含一份 <strong>按亲近程度从高****到低排列</strong> 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code> 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 <code>0</code> 到 <code>n-1</code> 之间的整数表示。</p><p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [xi, yi]</code> 表示 <code>xi</code> 与 <code>yi</code> 配对，且 <code>yi</code> 与 <code>xi</code> 配对。</p><p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 <code>x</code> 与 <code>y</code> 配对且 <code>u</code> 与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，<code>x</code> 就会不开心：</p><ul><li><code>x</code> 与 <code>u</code> 的亲近程度胜过 <code>x</code> 与 <code>y</code>，且</li><li><code>u</code> 与 <code>x</code> 的亲近程度胜过 <code>u</code> 与 <code>v</code></li></ul><p>返回 <strong>不开心的朋友的数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]<br>输出：2<br>解释：<br>朋友<span class="hljs-number"> 1 </span>不开心，因为：<br>-<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>配对，但<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 3 </span>的亲近程度比<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>高，且<br>-<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 1 </span>的亲近程度比<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>高。<br>朋友<span class="hljs-number"> 3 </span>不开心，因为：<br>-<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>配对，但<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 1 </span>的亲近程度比<span class="hljs-number"> 3 </span>与<span class="hljs-number"> 2 </span>高，且<br>-<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 3 </span>的亲近程度比<span class="hljs-number"> 1 </span>与<span class="hljs-number"> 0 </span>高。<br>朋友<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>都是开心的。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, preferences = <span class="hljs-string">[[1], [0]]</span>, <span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1, 0]]</span><br>输出：<span class="hljs-number">0</span><br>解释：朋友 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 都开心。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">4</span>, preferences = <span class="hljs-string">[[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]</span>, <span class="hljs-built_in">pairs</span> = <span class="hljs-string">[[1, 3], [0, 2]]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 500</code></li><li><code>n</code> 是偶数</li><li><code>preferences.length == n</code></li><li><code>preferences[i].length == n - 1</code></li><li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li><li><code>preferences[i]</code> 不包含 <code>i</code></li><li><code>preferences[i]</code> 中的所有值都是独一无二的</li><li><code>pairs.length == n/2</code></li><li><code>pairs[i].length == 2</code></li><li><code>xi != yi</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li>每位朋友都 <strong>恰好</strong> 被包含在一对中</li></ul></li></ul><h2 id="方法一：直接模拟"><a href="#方法一：直接模拟" class="headerlink" title="方法一：直接模拟"></a>方法一：直接模拟</h2><p>直观的来说，我们需要x，y，u，v比较四个数的互相关系，那么我们就需要构建出能够让他们相互比较的变量+索引。</p><p>首先要比较亲近度，所以构建一个像是哈希表一样的索引，标注每个人跟他朋友之间的亲密优先级。</p><p>第二个，查找索引把每一对配对之间的[x，y]连起来，使得可以通过x找到y，通过y找到x。</p><p>第三步就是遍历x，只要满足题目给出的两个关系式，那他就是不开心的人。</p><p>注：今天是七夕，leetcode也知道单身码农多是吗哈哈哈，我也好想跟女生出去玩。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unhappyFriends</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; preferences, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">intimate</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<span class="hljs-comment">//构造亲近度表</span><br>        <span class="hljs-type">int</span> m = pairs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;preferences[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>                intimate[i][preferences[i][j]] = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">group</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            group[pairs[i][<span class="hljs-number">0</span>]]=pairs[i][<span class="hljs-number">1</span>];<span class="hljs-comment">//建立pairs的相互索引用于查找</span><br>            group[pairs[i][<span class="hljs-number">1</span>]]=pairs[i][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-comment">//构建xyuv4元组</span><br>            <span class="hljs-type">int</span> x = i;<br>            <span class="hljs-type">int</span> y = group[x];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;preferences[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-type">int</span> u = preferences[i][j];<br>                <span class="hljs-type">int</span> v = group[u];<br>                <span class="hljs-keyword">if</span>(intimate[x][u]&lt;intimate[x][y])&#123;<span class="hljs-comment">//这里用反过来的小于号是因为之前建立亲密度表的时候下标越小越亲密</span><br>                    <span class="hljs-keyword">if</span>(intimate[u][x]&lt;intimate[u][v])&#123;<span class="hljs-comment">//这里同样</span><br>                        ans++;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-13 每日一题</title>
    <link href="/2021/08/13/2021.8.13%20daily%20problem/"/>
    <url>/2021/08/13/2021.8.13%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><ul><li><h4 id="233-数字-1-的个数"><a href="#233-数字-1-的个数" class="headerlink" title="233. 数字 1 的个数"></a><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233. 数字 1 的个数</a></h4><p>难度困难249</p><p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code> 的非负整数中数字 <code>1</code> 出现的个数。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">13</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 2 * 109</code></li></ul></li></ul></li></ul><h2 id="方法一：枚举每一数位上-1-的个数"><a href="#方法一：枚举每一数位上-1-的个数" class="headerlink" title="方法一：枚举每一数位上 1 的个数"></a>方法一：枚举每一数位上 1 的个数</h2><p>其实是想到了数每个位上1出现的次数，但因为自己太傻从后开始往前数越数越乱。。一直不对。。。</p><p>贴一下官答的解释：</p><blockquote><p>当数位为 10^k10<br>k<br>  时，最后的 kk 个数位每 10^{k+1}10<br>k+1<br>  个数会循环一次，并且其中包含 10^k10<br>k<br>  个 11，由于 nn 包含 \lfloor \dfrac{n}{10^{k+1}} \rfloor⌊<br>10<br>k+1</p><p>n</p><p> ⌋ 个完整的循环，那么这一部分的 11 的个数为 \lfloor \dfrac{n}{10^{k+1}} \rfloor \times 10^k⌊<br>10<br>k+1</p><p>n</p><p> ⌋×10<br>k<br> 。不在循环中的部分还有 n \bmod 10^{k+1}nmod10<br>k+1<br>  个数，这一部分的 11 的个数为 n \bmod 10^{k+1} - 10^k + 1nmod10<br>k+1<br> −10<br>k<br> +1，如果这个值小于 00，那么调整为出现 00 次；如果这个值大于 10^k10<br>k<br> ，那么调整为出现 10^k10<br>k<br>  次。</p></blockquote><p>公式：<br>$$<br>⌊ \frac{n}{10^{k+1}} ⌋×10<br>k<br> +min(max(n\space mod10^{k+1}−10{k}+1,0),10<br>k<br> )<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// mulk 表示 10^k</span><br>        <span class="hljs-comment">// 在下面的代码中，可以发现 k 并没有被直接使用到（都是使用 10^k）</span><br>        <span class="hljs-comment">// 但为了让代码看起来更加直观，这里保留了 k</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mulk = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; n &gt;= mulk; ++k) &#123;<br>            ans += (n / (mulk * <span class="hljs-number">10</span>)) * mulk + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(n % (mulk * <span class="hljs-number">10</span>) - mulk + <span class="hljs-number">1</span>, <span class="hljs-number">0LL</span>), mulk);<br>            mulk *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-12 每日一题</title>
    <link href="/2021/08/12/2021.8.12%20daily%20problem/"/>
    <url>/2021/08/12/2021.8.12%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h4><p>难度中等</p><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbbab&quot;</span><br>输出：<span class="hljs-number">4</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bbbb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;cbbd&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：一个可能的最长回文子序列为 <span class="hljs-string">&quot;bb&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>做子序列的题目不要用以前那种，抽离单个序列来验证是否满足题目要求，把问题分割成子序列，逐步扩大子序列的范围。</p><p>对于一个子序列而言，如果它是回文子序列，并且长度大于 2，那么将它首尾的两个字符去除之后，它仍然是个回文子序列。因此可以用动态规划的方法计算给定字符串的最长回文子序列。</p><p>用 \textit{dp}[i][j]dp[i][j] 表示字符串 ss 的下标范围 [i, j][i,j] 内的最长回文子序列的长度。假设字符串 ss 的长度为 nn，则只有当 0 \le i \le j &lt; n0≤i≤j&lt;n 时，才会有 \textit{dp}[i][j] &gt; 0dp[i][j]&gt;0，否则 \textit{dp}[i][j] &#x3D; 0dp[i][j]&#x3D;0。</p><p>由于任何长度为 11 的子序列都是回文子序列，因此动态规划的边界情况是，对任意 0 \le i &lt; n0≤i&lt;n，都有 \textit{dp}[i][i] &#x3D; 1dp[i][i]&#x3D;1。</p><p>当 i &lt; ji&lt;j 时，计算 \textit{dp}[i][j]dp[i][j] 需要分别考虑 s[i]s[i] 和 s[j]s[j] 相等和不相等的情况：</p><p>如果 s[i] &#x3D; s[j]s[i]&#x3D;s[j]，则首先得到 ss 的下标范围 [i+1, j-1][i+1,j−1] 内的最长回文子序列，然后在该子序列的首尾分别添加 s[i]s[i] 和 s[j]s[j]，即可得到 ss 的下标范围 [i, j][i,j] 内的最长回文子序列，因此 \textit{dp}[i][j] &#x3D; \textit{dp}[i+1][j-1] + 2dp[i][j]&#x3D;dp[i+1][j−1]+2；</p><p>如果 s[i] \ne s[j]s[i]<br></p><p> &#x3D;s[j]，则 s[i]s[i] 和 s[j]s[j] 不可能同时作为同一个回文子序列的首尾，因此 \textit{dp}[i][j] &#x3D; \max(\textit{dp}[i+1][j], \textit{dp}[i][j-1])dp[i][j]&#x3D;max(dp[i+1][j],dp[i][j−1])。</p><p>由于状态转移方程都是从长度较短的子序列向长度较长的子序列转移，因此需要注意动态规划的循环顺序。</p><p>最终得到 \textit{dp}[0][n-1]dp[0][n−1] 即为字符串 ss 的最长回文子序列的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">char</span> c1 = s[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">char</span> c2 = s[j];<br>                <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-11 每日一题</title>
    <link href="/2021/08/11/2021.8.11%20daily%20problem/"/>
    <url>/2021/08/11/2021.8.11%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="446-等差数列划分-II-子序列"><a href="#446-等差数列划分-II-子序列" class="headerlink" title="446. 等差数列划分 II - 子序列"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/">446. 等差数列划分 II - 子序列</a></h4><p>难度困难</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中所有 <strong>等差子序列</strong> 的数目。</p><p>如果一个序列中 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p><ul><li>例如，<code>[1, 3, 5, 7, 9]</code>、<code>[7, 7, 7, 7]</code> 和 <code>[3, -1, -5, -9]</code> 都是等差序列。</li><li>再例如，<code>[1, 1, 2, 5, 7]</code> 不是等差序列。</li></ul><p>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p><ul><li>例如，<code>[2,5,10]</code> 是 <code>[1,2,1,***2***,4,1,***5\***,***10***]</code> 的一个子序列。</li></ul><p>题目数据保证答案是一个 <strong>32-bit</strong> 整数。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,4,6,8,10]</span><br>输出：7<br>解释：所有的等差子序列为：<br><span class="hljs-comment">[2,4,6]</span><br><span class="hljs-comment">[4,6,8]</span><br><span class="hljs-comment">[6,8,10]</span><br><span class="hljs-comment">[2,4,6,8]</span><br><span class="hljs-comment">[4,6,8,10]</span><br><span class="hljs-comment">[2,4,6,8,10]</span><br><span class="hljs-comment">[2,6,10]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7]</span><br>输出：<span class="hljs-number">16</span><br>解释：数组中的任意子序列都是等差子序列。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h2 id="方法一：动态规划-哈希表"><a href="#方法一：动态规划-哈希表" class="headerlink" title="方法一：动态规划 + 哈希表"></a>方法一：动态规划 + 哈希表</h2><p>完全没思路，今天摸了。</p><p>我们首先考虑至少有两个元素的等差子序列，下文将其称作弱等差子序列。</p><p>由于尾项和公差可以确定一个等差数列，因此我们定义状态 f[i][d]f[i][d] 表示尾项为 \textit{nums}[i]nums[i]，公差为 dd 的弱等差子序列的个数。</p><p>我们用一个二重循环去遍历 \textit{nums}nums 中的所有元素对 (\textit{nums}[i],\textit{nums}[j])(nums[i],nums[j])，其中 j&lt;ij&lt;i。将 \textit{nums}[i]nums[i] 和 \textit{nums}[j]nums[j] 分别当作等差数列的尾项和倒数第二项，则该等差数列的公差 d&#x3D;\textit{nums}[i]-\textit{nums}[j]d&#x3D;nums[i]−nums[j]。由于公差相同，我们可以将 \textit{nums}[i]nums[i] 加到以 \textit{nums}[j]nums[j] 为尾项，公差为 dd 的弱等差子序列的末尾，这对应着状态转移 f[i][d] +&#x3D; f[j][d]f[i][d]+&#x3D;f[j][d]。同时，(\textit{nums}[i],\textit{nums}[j])(nums[i],nums[j]) 这一对元素也可以当作一个弱等差子序列，故有状态转移</p><p>f[i][d] +&#x3D; f[j][d] + 1<br>f[i][d]+&#x3D;f[j][d]+1</p><p>由于题目要统计的等差子序列至少有三个元素，我们回顾上述二重循环，其中「将 \textit{nums}[i]nums[i] 加到以 \textit{nums}[j]nums[j] 为尾项，公差为 dd 的弱等差子序列的末尾」这一操作，实际上就构成了一个至少有三个元素的等差子序列，因此我们将循环中的 f[j][d]f[j][d] 累加，即为答案。</p><p>代码实现时，由于 \textit{nums}[i]nums[i] 的范围很大，所以计算出的公差的范围也很大，我们可以将状态转移数组 ff 的第二维用哈希表代替。</p><p><strong>注：dp[i][d](弱等差的数目) &#x3D; dp[j][d](真等差的数目) + 1(假等差的数目)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> d = <span class="hljs-number">1LL</span> * nums[i] - nums[j];<span class="hljs-comment">//这里的1LL就是转成longlong的意思，1乘以要转类型的数</span><br>                <span class="hljs-keyword">auto</span> it = f[j].<span class="hljs-built_in">find</span>(d);<br>                <span class="hljs-type">int</span> cnt = it== f[j].<span class="hljs-built_in">end</span>() ? <span class="hljs-number">0</span> : it-&gt;second;<br>                ans += cnt;<br>                f[i][d] += cnt + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-10 每日一题</title>
    <link href="/2021/08/10/2021.8.10%20daily%20problem/"/>
    <url>/2021/08/10/2021.8.10%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a></h4><p>难度中等</p><p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><ul><li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li></ul><p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p><p><strong>子数组</strong> 是数组中的一个连续序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4]</span><br>输出：3<br>解释：nums 中有三个子等差数组：<span class="hljs-comment">[1, 2, 3]</span>、<span class="hljs-comment">[2, 3, 4]</span> 和 <span class="hljs-comment">[1,2,3,4]</span> 自身。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>之前在动态规划课程里面已经做过这道了。</p><p>用最直观的方法解题，模拟遍历找子数组。</p><p>首先如果某个数组是等差数组，那么它的等差子数组的个数就是等差数组本身长度-1 。</p><p>所以，我们从第一个差开始，依次往下遍历，如果数字连续等差，就对计数器增1 。当遍历到不一样的差值时，将当前计数器的值加入到answer，然后置零且计算新一轮的差值，开始以下一轮遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> d = nums[<span class="hljs-number">1</span>]-nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]-nums[i<span class="hljs-number">-1</span>]==d)&#123;<span class="hljs-comment">//如果差相同，直接增，等差子数组的长度等于数组本身长度-1，这里从第二位开始计算temp，所以运算到最后temp就是数组数量。</span><br>                temp++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果差不相同，就要开始下一轮的模拟</span><br>                d = nums[i]-nums[i<span class="hljs-number">-1</span>];<br>                temp = <span class="hljs-number">0</span>;<br>            &#125;<br>            ans += temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-09 每日一题</title>
    <link href="/2021/08/09/2021.8.9%20daily%20problem/"/>
    <url>/2021/08/09/2021.8.9%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h4><p>难度中等</p><p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。</p><p>给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。</p><p>题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">12</span>, primes = [<span class="hljs-number">2,7,13,19</span>]<br>输出：<span class="hljs-number">32</span> <br>解释：给定长度为 <span class="hljs-number">4</span> 的质数数组 primes = [<span class="hljs-number">2,7,13,19</span>]，前 <span class="hljs-number">12</span> 个超级丑数序列为：[<span class="hljs-number">1,2,4,7</span>,<span class="hljs-number">8,13,14,16</span>,<span class="hljs-number">19,26,28,32</span>] 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 1, primes = <span class="hljs-comment">[2,3,5]</span><br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = <span class="hljs-comment">[2,3,5]</span> 中。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 106</code></li><li><code>1 &lt;= primes.length &lt;= 100</code></li><li><code>2 &lt;= primes[i] &lt;= 1000</code></li><li>题目数据 <strong>保证</strong> <code>primes[i]</code> 是一个质数</li><li><code>primes</code> 中的所有值都 <strong>互不相同</strong> ，且按 <strong>递增顺序</strong> 排列</li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>这道题目的关键在于，每一轮用数组里的最小数乘以数组里的所有数，然后把乘得的最小结果数放入数组中。但显然用过的最小数是不用再参与运算了，而直接把新的最小数压入primes数组的话，首先是每轮都要排序，其次是不好确定循环边界和每轮开始的循环下标。</p><p>故使用dp[]数组，以dp[i]代表第i个超级丑数。于是我们初始化dp[1] &#x3D; 1。</p><p>每一轮，使用一个指针pointers代表“倍数”。简单来说，就是一开始里面所有质因数的倍数都是1，每一轮加入最小的数之后，那么最小的那个质因数就不能乘以1了，要乘以给定数组里面的质数，所以每一轮处理完之后，要修改对应质因数的倍数（而处理这个倍数就是dp数组后移，一开始从最小的1开始，每一步后移都是未使用过的当前最小乘数）。</p><p>就用示例的做例子，一开始加入1，第一轮做完之后加入2，2不能再乘以1，所以质因数“2”的pointers要后移，那么第二轮就是2*2，得到4。同样这轮里面4也是2所有因数乘以对应pointers指向倍数所得到的最小数，“2”的pointers继续后移。</p><p>但是在第三轮，4*2&lt;1*7；这一轮的最小数是7，将7加入后将7的pointers后移，下一轮关于7的运算就是7*dp[2]了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = primes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pointers</span><span class="hljs-params">(m, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(m)</span></span>;<br>            <span class="hljs-type">int</span> minNum = INT_MAX;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                nums[j] = dp[pointers[j]] * primes[j];<br>                minNum = <span class="hljs-built_in">min</span>(minNum, nums[j]);<br>            &#125;<br>            dp[i] = minNum;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (minNum == nums[j]) &#123;<br>                    pointers[j]++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-08 每日一题</title>
    <link href="/2021/08/08/2021.8.8%20daily%20problem/"/>
    <url>/2021/08/08/2021.8.8%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数</a></h4><p>难度简单</p><p>泰波那契序列 Tn 定义如下： </p><p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 &#x3D; Tn + Tn+1 + Tn+2</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 Tn 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 4<br>输出：4<br>解释：<br>T_3 =<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>= 2<br>T_4 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>= 4<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">25</span><br>输出：<span class="hljs-number">1389537</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 37</code></li><li>答案保证是一个 32 位整数，即 <code>answer &lt;= 2^31 - 1</code>。</li></ul></li></ul><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p>秒杀</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tribonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> arr[<span class="hljs-number">38</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        arr[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        arr[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">37</span>;i++)&#123;<br>            arr[i] = arr[i<span class="hljs-number">-3</span>]+arr[i<span class="hljs-number">-2</span>]+arr[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-07 每日一题</title>
    <link href="/2021/08/07/2021.8.7%20daily%20problem/"/>
    <url>/2021/08/07/2021.8.7%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="457-环形数组是否存在循环"><a href="#457-环形数组是否存在循环" class="headerlink" title="457. 环形数组是否存在循环"></a><a href="https://leetcode-cn.com/problems/circular-array-loop/">457. 环形数组是否存在循环</a></h4><p>难度中等119</p><p>存在一个不含 <code>0</code> 的 <strong>环形</strong> 数组 <code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 <code>i</code> 的角色应该向前或向后移动的下标个数：</p><ul><li>如果 <code>nums[i]</code> 是正数，<strong>向前</strong> 移动 <code>nums[i]</code> 步</li><li>如果 <code>nums[i]</code> 是负数，<strong>向后</strong> 移动 <code>nums[i]</code> 步</li></ul><p>因为数组是 <strong>环形</strong> 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p><p>数组中的 <strong>循环</strong> 由长度为 <code>k</code> 的下标序列 <code>seq</code> ：</p><ul><li>遵循上述移动规则将导致重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code></li><li>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong></li><li><code>k &gt; 1</code></li></ul><p>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,-1,1,2,2]<br>输出：true<br>解释：存在循环，按下标<span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 3 </span>-&gt;<span class="hljs-number"> 0 </span>。循环长度为<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [-1,2]<br>输出：false<br>解释：按下标<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 1 </span>... 的运动无法构成循环，因为循环的长度为<span class="hljs-number"> 1 </span>。根据定义，循环的长度必须大于<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-2,1,-1,-2,-2]</span><br>输出：false<br>解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums<span class="hljs-comment">[1]</span> 是正数，而 nums<span class="hljs-comment">[2]</span> 是负数。<br>所有 nums<span class="hljs-comment">[seq<span class="hljs-comment">[j]</span>]</span> 应当不是全正就是全负。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums[i] != 0</code></li></ul><p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(n)</code> 且额外空间复杂度为 <code>O(1)</code> 的算法吗？</p></li></ul><h2 id="方法一：快慢指针"><a href="#方法一：快慢指针" class="headerlink" title="方法一：快慢指针"></a>方法一：快慢指针</h2><p>经典快慢指针题目，但是之前没有具体写过这种双指针法，用了一种很低级的方法要考虑很多边界条件没做出来，贴题解了。</p><p>我们可以将环形数组理解为图中的 nn 个点，\text{nums}[i]nums[i] 表示 ii 号点向 (i + \text{nums}[i]) \bmod n(i+nums[i])modn 号点连有一条单向边。</p><p>注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。而依据题目要求，我们要检查图中是否存在一个所有单向边方向一致的环。我们可以使用在无向图中找环的一个经典算法：快慢指针来解决本题，参考题解「141. 环形链表」。</p><p>具体地，我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。</p><p>在实际代码中，我们无需新建一个数组记录每个点的访问情况，而只需要将原数组的对应元素置零即可（题目保证原数组中元素不为零）。遍历过程中，如果快慢指针相遇，或者移动方向改变，那么我们就停止遍历，并将快慢指针经过的点均置零即可。</p><p>特别地，当 \text{nums}[i]nums[i] 为 nn 的整倍数时，ii 的后继节点即为 ii 本身，此时循环长度 k&#x3D;1k&#x3D;1，不符合题目要求，因此我们需要跳过这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">circularArrayLoop</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> next = [&amp;](<span class="hljs-type">int</span> cur) &#123;<br>            <span class="hljs-built_in">return</span> ((cur + nums[cur]) % n + n) % n; <span class="hljs-comment">// 保证返回值在 [0,n) 中</span><br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!nums[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> slow = i, fast = <span class="hljs-built_in">next</span>(i);<br>            <span class="hljs-comment">// 判断非零且方向相同</span><br>            <span class="hljs-keyword">while</span> (nums[slow] * nums[fast] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[slow] * nums[<span class="hljs-built_in">next</span>(fast)] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                    <span class="hljs-keyword">if</span> (slow != <span class="hljs-built_in">next</span>(slow)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                slow = <span class="hljs-built_in">next</span>(slow);<br>                fast = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">next</span>(fast));<br>            &#125;<br>            <span class="hljs-type">int</span> add = i;<br>            <span class="hljs-keyword">while</span> (nums[add] * nums[<span class="hljs-built_in">next</span>(add)] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">int</span> tmp = add;<br>                add = <span class="hljs-built_in">next</span>(add);<br>                nums[tmp] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-06 每日一题</title>
    <link href="/2021/08/06/2021.8.6%20daily%20problem/"/>
    <url>/2021/08/06/2021.8.6%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="847-访问所有节点的最短路径"><a href="#847-访问所有节点的最短路径" class="headerlink" title="847. 访问所有节点的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/">847. 访问所有节点的最短路径</a></h4><p>难度困难</p><p>存在一个由 <code>n</code> 个节点组成的无向连通图，图中的节点按从 <code>0</code> 到 <code>n - 1</code> 编号。</p><p>给你一个数组 <code>graph</code> 表示这个图。其中，<code>graph[i]</code> 是一个列表，由所有与节点 <code>i</code> 直接相连的节点组成。</p><p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[0]</span>,<span class="hljs-comment">[0]</span>,<span class="hljs-comment">[0]</span>]</span><br>输出：4<br>解释：一种可能的路径为 <span class="hljs-comment">[1,0,2,0,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[0,2,4]</span>,<span class="hljs-comment">[1,3,4]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>]</span><br>输出：4<br>解释：一种可能的路径为 <span class="hljs-comment">[0,1,4,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 12</code></li><li><code>0 &lt;= graph[i].length &lt; n</code></li><li><code>graph[i]</code> 不包含 <code>i</code></li><li>如果 <code>graph[a]</code> 包含 <code>b</code> ，那么 <code>graph[b]</code> 也包含 <code>a</code></li><li>输入的图总是连通图</li></ul></li></ul><h2 id="方法一：状态压缩-广度优先搜索"><a href="#方法一：状态压缩-广度优先搜索" class="headerlink" title="方法一：状态压缩 + 广度优先搜索"></a>方法一：状态压缩 + 广度优先搜索</h2><p>看到困难+图论题目就绷不住了，下面是官方题解：</p><p>由于题目需要我们求出「访问所有节点的最短路径的长度」，并且图中每一条边的长度均为 11，因此我们可以考虑使用广度优先搜索的方法求出最短路径。</p><p>在常规的广度优先搜索中，我们会在队列中存储节点的编号。对于本题而言，最短路径的前提是「访问了所有节点」，因此除了记录节点的编号以外，我们还需要记录每一个节点的经过情况。因此，我们使用三元组 (u, \textit{mask}, \textit{dist})(u,mask,dist) 表示队列中的每一个元素，其中：</p><p>uu 表示当前位于的节点编号；</p><p>\textit{mask}mask 是一个长度为 nn 的二进制数，表示每一个节点是否经过。如果 \textit{mask}mask 的第 ii 位是 11，则表示节点 ii 已经过，否则表示节点 ii 未经过；</p><p>\textit{dist}dist 表示到当前节点为止经过的路径长度。</p><p>这样一来，我们使用该三元组进行广度优先搜索，即可解决本题。初始时，我们将所有的 (i, 2^i, 0)(i,2<br>i<br> ,0) 放入队列，表示可以从任一节点开始。在搜索的过程中，如果当前三元组中的 \textit{mask}mask 包含 nn 个 11（即 \textit{mask} &#x3D; 2^n - 1mask&#x3D;2<br>n<br> −1），那么我们就可以返回 \textit{dist}dist 作为答案。</p><p>细节</p><p>为了保证广度优先搜索时间复杂度的正确性，即同一个节点 uu 以及节点的经过情况 \textit{mask}mask 只被搜索到一次，我们可以使用数组或者哈希表记录 (u, \textit{mask})(u,mask) 是否已经被搜索过，防止无效的重复搜索。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        queue&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">seen</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span> &lt;&lt; n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            q.<span class="hljs-built_in">emplace</span>(i, <span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-number">0</span>);<br>            seen[i][<span class="hljs-number">1</span> &lt;&lt; i] = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [u, mask, dist] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (mask == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) &#123;<br>                ans = dist;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 搜索相邻的节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: graph[u]) &#123;<br>                <span class="hljs-comment">// 将 mask 的第 v 位置为 1</span><br>                <span class="hljs-type">int</span> mask_v = mask | (<span class="hljs-number">1</span> &lt;&lt; v);<br>                <span class="hljs-keyword">if</span> (!seen[v][mask_v]) &#123;<br>                    q.<span class="hljs-built_in">emplace</span>(v, mask_v, dist + <span class="hljs-number">1</span>);<br>                    seen[v][mask_v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-04 每日一题</title>
    <link href="/2021/08/04/2021.8.4%20daily%20problem/"/>
    <url>/2021/08/04/2021.8.4%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="611-有效三角形的个数"><a href="#611-有效三角形的个数" class="headerlink" title="611. 有效三角形的个数"></a><a href="https://leetcode-cn.com/problems/valid-triangle-number/">611. 有效三角形的个数</a></h4><p>难度中等232</p><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,3,4]</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释:</span><br><span class="hljs-section">有效的组合是: </span><br>2,3,4 (使用第一个 2)<br>2,3,4 (使用第二个 2)<br>2,2,3<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组长度不超过1000。</li><li>数组里整数的范围为 [0, 1000]。</li></ol></li></ul><h2 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h2><p>先排序，然后验证a+b&gt;c，但是超时，不贴了。</p><h2 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h2><p>首先进行排序，然后每次固定最大值，然后取下标0作为left，固定的最大值的左边一个元素做right。</p><p>每次遍历检查nums[l] + nums[r] 是否大于 nums[i]，如果是，则返回的答案值累积r-1，然后R自减；否则L自增。</p><p>遍历完就是答案，时间复杂度O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">triangleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">if</span> (nums[l] + nums[r] &gt; nums[i]) &#123;<br>                    ans += r - l;<br>                    --r;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ++l;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-04 每日一题</title>
    <link href="/2021/08/04/2021.8.5%20daily%20problem/"/>
    <url>/2021/08/04/2021.8.5%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="802-找到最终的安全状态"><a href="#802-找到最终的安全状态" class="headerlink" title="802. 找到最终的安全状态"></a><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a></h4><p>难度中等</p><p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p><p>对于一个起始节点，如果从该节点出发，<strong>无论每一步选择沿哪条有向边行走</strong>，最后必然在有限步内到达终点，则将该起始节点称作是 <strong>安全</strong> 的。</p><p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 <strong>升序</strong> 排列。</p><p>该有向图有 <code>n</code> 个节点，按 <code>0</code> 到 <code>n - 1</code> 编号，其中 <code>n</code> 是 <code>graph</code> 的节点数。图以下述形式给出：<code>graph[i]</code> 是编号 <code>j</code> 节点的一个列表，满足 <code>(i, j)</code> 是图的一条有向边。</p><p><strong>示例 1：</strong></p><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="Illustration of graph"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[0]</span>,<span class="hljs-comment">[5]</span>,<span class="hljs-comment">[]</span>,<span class="hljs-comment">[]</span>]</span><br>输出：<span class="hljs-comment">[2,4,5,6]</span><br>解释：示意图如上。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：graph = <span class="hljs-comment">[<span class="hljs-comment">[1,2,3,4]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[0,4]</span>,<span class="hljs-comment">[]</span>]</span><br>输出：<span class="hljs-comment">[4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= graph[i].length &lt;= n</code></li><li><code>graph[i]</code> 按严格递增顺序排列。</li><li>图中可能包含自环。</li><li>图中边的数目在范围 <code>[1, 4 * 104]</code> 内。</li></ul></li></ul><h2 id="方法一：深度优先搜索-三色标记法"><a href="#方法一：深度优先搜索-三色标记法" class="headerlink" title="方法一：深度优先搜索 + 三色标记法"></a>方法一：深度优先搜索 + 三色标记法</h2><p>根据题意，若起始节点位于一个环内，或者能到达一个环，则该节点不是安全的。否则，该节点是安全的。</p><p>我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进行标记，标记的规则如下：</p><p>白色（用 00 表示）：该节点尚未被访问；<br>灰色（用 11 表示）：该节点位于递归栈中，或者在某个环上；<br>黑色（用 22 表示）：该节点搜索完毕，是一个安全节点。<br>当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。</p><p>如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将「找到了环」这一信息传递到栈中的所有节点上。</p><p>如果搜索过程中没有遇到灰色节点，则说明没有遇到环，那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">eventualSafeNodes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">color</span><span class="hljs-params">(n)</span></span>;<br><br>        function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>)&gt; safe = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-keyword">if</span> (color[x] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> color[x] == <span class="hljs-number">2</span>;<br>            &#125;<br>            color[x] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : graph[x]) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">safe</span>(y)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            color[x] = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">safe</span>(i)) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-03 每日一题</title>
    <link href="/2021/08/03/2021.8.3%20daily%20problem/"/>
    <url>/2021/08/03/2021.8.3%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组</a></h4><p>难度中等602</p><p>给你一个整数数组 <code>nums</code> ，你需要找出一个 <strong>连续子数组</strong> ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p><p>请你找出符合题意的 <strong>最短</strong> 子数组，并输出它的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[2,6,4,8,10,9,15]</span><br>输出：<span class="hljs-number">5</span><br>解释：你只需要对 <span class="hljs-string">[6, 4, 8, 10, 9]</span> 进行升序排序，那么整个表都会变为升序排序。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(n)</code> 的解决方案吗？</p></li></ul><h2 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h2><p>通过对数组进行排序，然后比较排序前和排序后的数组找出第一个和最后一个数字不相同的下标，两个下标作差即是答案，时间复杂度也O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; store;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        temp.<span class="hljs-built_in">assign</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(temp[i]!=nums[i])&#123;<br>                store.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(store.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> store[store.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-store[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：一次遍历"><a href="#方法二：一次遍历" class="headerlink" title="方法二：一次遍历"></a>方法二：一次遍历</h2><p>假设 \textit{nums}_Bnums<br>B</p><p>  在 \textit{nums}nums 中对应区间为 [\textit{left},\textit{right}][left,right]。</p><p>注意到 \textit{nums}_Bnums<br>B</p><p>  和 \textit{nums}_Cnums<br>C</p><p>  中任意一个数都大于等于 \textit{nums}_Anums<br>A</p><p>  中任意一个数。因此有 \textit{nums}_Anums<br>A</p><p>  中每一个数 \textit{nums}_inums<br>i</p><p>  都满足：</p><p>\textit{nums}<em>i \leq \min</em>{j&#x3D;i+1}^{n-1} \textit{nums}_j<br>nums<br>i</p><p> ≤<br>j&#x3D;i+1<br>min<br>n−1</p><p> nums<br>j</p><p>我们可以从大到小枚举 ii，用一个变量 \textit{minn}minn 记录 \min_{j&#x3D;i+1}^{n-1} \textit{nums}_jmin<br>j&#x3D;i+1<br>n−1</p><p> nums<br>j</p><p> 。每次移动 ii，都可以 O(1)O(1) 地更新 \textit{minn}minn。这样最后一个使得不等式不成立的 ii 即为 \textit{left}left。\textit{left}left 左侧即为 \textit{nums}_Anums<br>A</p><p>  能取得的最大范围。</p><p>同理，我们可以用类似的方法确定 \textit{right}right。在实际代码中，我们可以在一次循环中同时完成左右边界的计算。</p><p>特别地，我们需要特判 \textit{nums}nums 有序的情况，此时 \textit{nums}_Bnums<br>B</p><p>  的长度为 00。当我们计算完成左右边界，即可返回 \textit{nums}_Bnums<br>B</p><p>  的长度。</p><p>这个方法其实就是递归找最大最小，然后验证这些数是否在最终位置上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxn = INT_MIN, right = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> minn = INT_MAX, left = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (maxn &gt; nums[i]) &#123;<br>                right = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                maxn = nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minn &lt; nums[n - i - <span class="hljs-number">1</span>]) &#123;<br>                left = n - i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                minn = nums[n - i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : right - left + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-02 每日一题</title>
    <link href="/2021/08/02/2021.8.2%20daily%20problem/"/>
    <url>/2021/08/02/2021.8.2%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h4><p>难度中等292</p><p>有 <code>n</code> 个网络节点，标记为 <code>1</code> 到 <code>n</code>。</p><p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong> 边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中 <code>ui</code> 是源节点，<code>vi</code> 是目标节点， <code>wi</code> 是一个信号从源节点传递到目标节点的时间。</p><p>现在，从某个节点 <code>K</code> 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：times = <span class="hljs-string">[[2,1,1],[2,3,1],[3,4,1]]</span>, n = <span class="hljs-number">4</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：times = <span class="hljs-string">[[1,2,1]]</span>, n = <span class="hljs-number">2</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：times = <span class="hljs-string">[[1,2,1]]</span>, n = <span class="hljs-number">2</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= n &lt;= 100</code></li><li><code>1 &lt;= times.length &lt;= 6000</code></li><li><code>times[i].length == 3</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li><code>0 &lt;= wi &lt;= 100</code></li><li>所有 <code>(ui, vi)</code> 对都 <strong>互不相同</strong>（即，不含重复边）</li></ul></li></ul><h2 id="方法一：迪杰斯特拉算法"><a href="#方法一：迪杰斯特拉算法" class="headerlink" title="方法一：迪杰斯特拉算法"></a>方法一：迪杰斯特拉算法</h2><p>比较标准的图论连通图题目。</p><p>想到了用迪杰斯特拉算法，但没能用代码把他写出来；</p><p>用低级的标记法虽然能确定是否连通，但是难以表示遍历到具体点所对应的正确的时间。</p><p>学习一下官方解法的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = INT_MAX / <span class="hljs-number">2</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, inf));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : times) &#123;<br>            <span class="hljs-type">int</span> x = t[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, y = t[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            g[x][y] = t[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, inf)</span></span>;<br>        dist[k - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; n; ++y) &#123;<br>                <span class="hljs-keyword">if</span> (!used[y] &amp;&amp; (x == <span class="hljs-number">-1</span> || dist[y] &lt; dist[x])) &#123;<br>                    x = y;<br>                &#125;<br>            &#125;<br>            used[x] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; n; ++y) &#123;<br>                dist[y] = <span class="hljs-built_in">min</span>(dist[y], dist[x] + g[x][y]);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = *<span class="hljs-built_in">max_element</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans == inf ? <span class="hljs-number">-1</span> : ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-08-01 每日一题</title>
    <link href="/2021/08/01/2021.8.1%20daily%20problem/"/>
    <url>/2021/08/01/2021.8.1%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1337-矩阵中战斗力最弱的-K-行"><a href="#1337-矩阵中战斗力最弱的-K-行" class="headerlink" title="1337. 矩阵中战斗力最弱的 K 行"></a><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">1337. 矩阵中战斗力最弱的 K 行</a></h4><p>难度简单54</p><p>给你一个大小为 <code>m * n</code> 的矩阵 <code>mat</code>，矩阵由若干军人和平民组成，分别用 1 和 0 表示。</p><p>请你返回矩阵中战斗力最弱的 <code>k</code> 行的索引，按从最弱到最强排序。</p><p>如果第 <em><strong>i</strong></em> 行的军人数量少于第 <em><strong>j</strong></em> 行，或者两行军人数量相同但 <em><strong>i</strong></em> 小于 <em><strong>j</strong></em>，那么我们认为第 <em><strong>i</strong></em> 行的战斗力比第 <em><strong>j</strong></em> 行弱。</p><p>军人 <strong>总是</strong> 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mat = <br>[[1,1,0,0,0],<br> [1,1,1,1,0],<br> [1,0,0,0,0],<br> [1,1,0,0,0],<br> [1,1,1,1,1]], <br>k = 3<br>输出：[2,0,3]<br>解释：<br>每行中的军人数目：<br>行<span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 2 </span><br>行<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 4 </span><br>行<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span><br>行<span class="hljs-number"> 3 </span>-&gt;<span class="hljs-number"> 2 </span><br>行<span class="hljs-number"> 4 </span>-&gt;<span class="hljs-number"> 5 </span><br>从最弱到最强对这些行排序后得到 [2,0,3,1,4]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mat = <br>[[1,0,0,0],<br> [1,1,1,1],<br> [1,0,0,0],<br> [1,0,0,0]], <br>k = 2<br>输出：[0,2]<br>解释： <br>每行中的军人数目：<br>行<span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 1 </span><br>行<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 4 </span><br>行<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span><br>行<span class="hljs-number"> 3 </span>-&gt;<span class="hljs-number"> 1 </span><br>从最弱到最强对这些行排序后得到 [0,2,3,1]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>2 &lt;= n, m &lt;= 100</code></li><li><code>1 &lt;= k &lt;= m</code></li><li><code>matrix[i][j]</code> 不是 0 就是 1</li></ul></li></ul><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>简单题，用SET去做，就是将每行的行数以及战力两个参数放入元组里去比较。排序的时候按战力排，所以使用set（自带有序），first用战力，这样全部压入set之后就是答案的顺序，最后将前K个放到ans里面就可以了。</p><p>本来应该10分钟搞定的，但之前一直纠结在map和unordered_map；一直纠结排序的问题，因为同等战力是早出现的行战力低。。。看到了用pair加入map，但还是没法排序；最后直接用set就完事了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">kWeakestRows</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        set&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;mat.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-type">int</span> force = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;mat[i].<span class="hljs-built_in">size</span>();j++)&#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">1</span>)&#123;<br>                    force++;<br>                &#125;<br>            &#125;<br>            mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(force,i));<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>            <span class="hljs-keyword">if</span>(ans.<span class="hljs-built_in">size</span>()==k)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-31 每日一题</title>
    <link href="/2021/07/31/2021.7.31%20daily%20problem/"/>
    <url>/2021/07/31/2021.7.31%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="987-二叉树的垂序遍历"><a href="#987-二叉树的垂序遍历" class="headerlink" title="987. 二叉树的垂序遍历"></a><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h4><p>难度困难</p><p>给你二叉树的根结点 <code>root</code> ，请你设计算法计算二叉树的 <strong>垂序遍历</strong> 序列。</p><p>对位于 <code>(row, col)</code> 的每个结点而言，其左右子结点分别位于 <code>(row + 1, col - 1)</code> 和 <code>(row + 1, col + 1)</code> 。树的根结点位于 <code>(0, 0)</code> 。</p><p>二叉树的 <strong>垂序遍历</strong> 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p><p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [3,9,20,null,null,15,7]<br>输出：[[9],[3,15],[20],[7]]<br>解释：<br>列 -1 ：只有结点<span class="hljs-number"> 9 </span>在此列中。<br>列 <span class="hljs-number"> 0 </span>：只有结点<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 15 </span>在此列中，按从上到下顺序。<br>列 <span class="hljs-number"> 1 </span>：只有结点<span class="hljs-number"> 20 </span>在此列中。<br>列 <span class="hljs-number"> 2 </span>：只有结点<span class="hljs-number"> 7 </span>在此列中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3,4,5,6,7]<br>输出：[[4],[2],[1,5,6],[3],[7]]<br>解释：<br>列 -2 ：只有结点<span class="hljs-number"> 4 </span>在此列中。<br>列 -1 ：只有结点<span class="hljs-number"> 2 </span>在此列中。<br>列 <span class="hljs-number"> 0 </span>：结点<span class="hljs-number"> 1 </span>、5 和<span class="hljs-number"> 6 </span>都在此列中。<br>         <span class="hljs-number"> 1 </span>在上面，所以它出现在前面。<br>         <span class="hljs-number"> 5 </span>和<span class="hljs-number"> 6 </span>位置都是 (2, 0) ，所以按值从小到大排序，5 在<span class="hljs-number"> 6 </span>的前面。<br>列 <span class="hljs-number"> 1 </span>：只有结点<span class="hljs-number"> 3 </span>在此列中。<br>列 <span class="hljs-number"> 2 </span>：只有结点<span class="hljs-number"> 7 </span>在此列中。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2,3,4,6,5,7]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[4]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,5,6]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[7]</span>]</span><br>解释：<br>这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。<br>因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数目总数在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>用map去做。按照题意，从左至右的位置看成是横坐标，高度看成是纵坐标，横纵坐标相同的点放在一个vector组里，题目中要求横纵坐标相同的点要按大小排列。所以先用map标记横坐标键值，再使用一个map标记纵坐标键值，建立一个二维的哈希表。</p><p>然后遍历二叉树，按照横纵坐标放入哈希表里。map自带有序，所以放好之后横坐标是有序的。</p><p>完成之后再遍历二叉树，因为同一个横坐标对应多个纵坐标，所以要新建临时vector组存放多个纵坐标的值装入临时vector之后再压入返回的向量组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; mp;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> mark,<span class="hljs-type">int</span> height)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        mp[mark][height].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left,mark<span class="hljs-number">-1</span>,height++);<br>        <span class="hljs-built_in">traversal</span>(root-&gt;right,mark+<span class="hljs-number">1</span>,height++);<br>        <span class="hljs-comment">/*if(root-&gt;left!=nullptr)&#123;</span><br><span class="hljs-comment">            traversal(root-&gt;left,mark-1,height++);</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if(root-&gt;right!=nullptr)&#123;</span><br><span class="hljs-comment">            traversal(root-&gt;right,mark+1,height++);</span><br><span class="hljs-comment">        &#125;*/</span><br>    &#125;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">verticalTraversal</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-built_in">traversal</span>(root,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++)&#123;<span class="hljs-comment">//横坐标遍历</span><br>            <span class="hljs-comment">//sort(it-&gt;second.begin(),it-&gt;second.end());</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> jt = it-&gt;second.<span class="hljs-built_in">begin</span>();jt!=it-&gt;second.<span class="hljs-built_in">end</span>();jt++)&#123;<br>                <span class="hljs-comment">//遍历相同横坐标下的纵坐标</span><br>                <span class="hljs-keyword">if</span>(jt-&gt;second.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//装入前先排序</span><br>                    <span class="hljs-built_in">sort</span>(jt-&gt;second.<span class="hljs-built_in">begin</span>(),jt-&gt;second.<span class="hljs-built_in">end</span>());<br>                    <span class="hljs-comment">//ans.push_back(jt-&gt;second);</span><br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>;z&lt;jt-&gt;second.<span class="hljs-built_in">size</span>();z++)&#123;<span class="hljs-comment">//装入临时向量组只能一个一个装</span><br>                    temp.<span class="hljs-built_in">push_back</span>(jt-&gt;second[z]);<br>                &#125;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-30 每日一题</title>
    <link href="/2021/07/30/2021.7.30%20daily%20problem/"/>
    <url>/2021/07/30/2021.7.30%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171. Excel表列序号"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/">171. Excel表列序号</a></h4><p>难度简单253</p><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><p>例如，</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs clean">A -&gt; <span class="hljs-number">1</span><br>B -&gt; <span class="hljs-number">2</span><br>C -&gt; <span class="hljs-number">3</span><br>...<br>Z -&gt; <span class="hljs-number">26</span><br>AA -&gt; <span class="hljs-number">27</span><br>AB -&gt; <span class="hljs-number">28</span> <br>...<br></code></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;A&quot;</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: &quot;AB&quot;</span><br><span class="hljs-section">输出: 28</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入: <span class="hljs-string">&quot;ZY&quot;</span><br>输出: <span class="hljs-number">701</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：纯数学"><a href="#方法一：纯数学" class="headerlink" title="方法一：纯数学"></a>方法一：纯数学</h2><p>很好理解，就是做一个26进制运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">titleToNumber</span><span class="hljs-params">(string columnTitle)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = columnTitle.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            ans+=(columnTitle[i]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">1</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">26</span>,n-i<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-29 每日一题</title>
    <link href="/2021/07/29/2021.7.29%20daily%20problem/"/>
    <url>/2021/07/29/2021.7.29%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1104-二叉树寻路"><a href="#1104-二叉树寻路" class="headerlink" title="1104. 二叉树寻路"></a><a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104. 二叉树寻路</a></h4><p>难度中等101</p><p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 <strong>逐行</strong> 依次按 “之” 字形进行标记。</p><p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p><p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png" alt="img"></p><p>给你树上某一个节点的标号 <code>label</code>，请你返回从根节点到该标号为 <code>label</code> 节点的路径，该路径是由途经的节点标号所组成的。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">label</span> = <span class="hljs-number">14</span><br>输出：<span class="hljs-selector-attr">[1,3,4,14]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：<span class="hljs-selector-tag">label</span> = <span class="hljs-number">26</span><br>输出：<span class="hljs-selector-attr">[1,2,6,10,26]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= label &lt;= 10^6</code></li></ul></li></ul><h2 id="方法一：纯数学"><a href="#方法一：纯数学" class="headerlink" title="方法一：纯数学"></a>方法一：纯数学</h2><p>方法一：数学<br>我们先来研究一个简单的情形：二叉树的每一行都是按从左到右的顺序进行标记。此时二叉树满足以下性质：</p><p>根节点位于第 11 行；</p><p>第 ii 行有 2^{i-1}2<br>i−1<br>  个节点，最左边的节点标号为 2^{i-1}2<br>i−1<br> ，最右边的节点标号为 2^i-12<br>i<br> −1；</p><p>对于标号为 \textit{val}val 的节点，其左子节点的标号为 2 \times \textit{val}2×val，右子节点的标号为 2 \times \textit{val} + 12×val+1，当 \textit{val}&gt;1val&gt;1 时，其父节点的标号为 \lfloor \frac{\textit{val}}{2} \rfloor⌊<br>2<br>val</p><p> ⌋。</p><p>对于给定节点的标号 \textit{label}label，可以根据上述性质得到从该节点到根节点的路径，将路径反转后，即为从根节点到标号 \textit{label}label 的节点的路径。</p><p>回到这题，对于偶数行按从右到左的顺序进行标记的情况，可以转换成按从左到右的顺序进行标记的情况，然后按照上述思路得到路径，只要对偶数行的标号进行转换即可。为了表述简洁，下文将按从左到右的顺序进行标记时的节点的标号称为「从左到右标号」。</p><p>首先找到标号为 \textit{label}label 的节点所在的行和该节点的「从左到右标号」。为了找到节点所在行，需要找到 ii 满足 2^{i-1} \le \textit{label} &lt; 2^i2<br>i−1<br> ≤label&lt;2<br>i<br> ，则该节点在第 ii 行。该节点的「从左到右标号」需要根据 ii 的奇偶性计算：</p><p>当 ii 是奇数时，第 ii 行为按从左到右的顺序进行标记，因此该节点的「从左到右标号」即为 \textit{label}label；</p><p>当 ii 是偶数时，第 ii 行为按从右到左的顺序进行标记，将整行的标号左右翻转之后得到按从左到右的顺序进行标记的标号，对于同一个节点，其翻转前后的标号之和为 2^{i-1} + 2^i - 12<br>i−1<br> +2<br>i<br> −1，因此标号为 \textit{label}label 的节点的「从左到右标号」为 2^{i-1} + 2^i - 1 - \textit{label}2<br>i−1<br> +2<br>i<br> −1−label。</p><p>得到标号为 \textit{label}label 的节点的「从左到右标号」之后，即可得到从该节点到根节点的路径，以及路径上的每个节点的「从左到右标号」。对于路径上的每个节点，需要根据节点所在行的奇偶性，得到该节点的实际标号：</p><p>当 ii 是奇数时，第 ii 行的每个节点的「从左到右标号」即为该节点的实际标号；</p><p>当 ii 是偶数时，如果第 ii 行的一个节点的「从左到右标号」为 \textit{val}val，则该节点的实际标号为 2^{i-1} + 2^i - 1 - \textit{val}2<br>i−1<br> +2<br>i<br> −1−val。</p><p>最后，将路径反转，即可得到从根节点到标号 \textit{label}label 的节点的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReverse</span><span class="hljs-params">(<span class="hljs-type">int</span> label, <span class="hljs-type">int</span> row)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; row - <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; row) - <span class="hljs-number">1</span> - label;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pathInZigZagTree</span><span class="hljs-params">(<span class="hljs-type">int</span> label)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">1</span>, rowStart = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (rowStart * <span class="hljs-number">2</span> &lt;= label) &#123;<br>            row++;<br>            rowStart *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (row % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            label = <span class="hljs-built_in">getReverse</span>(label, row);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">while</span> (row &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (row % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                path.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getReverse</span>(label, row));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                path.<span class="hljs-built_in">push_back</span>(label);<br>            &#125;<br>            row--;<br>            label &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-28 每日一题</title>
    <link href="/2021/07/28/2021.7.28%20daily%20problem/"/>
    <url>/2021/07/28/2021.7.28%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="863-二叉树中所有距离为-K-的结点"><a href="#863-二叉树中所有距离为-K-的结点" class="headerlink" title="863. 二叉树中所有距离为 K 的结点"></a><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h4><p>难度中等</p><p>给定一个二叉树（具有根结点 <code>root</code>）， 一个目标结点 <code>target</code> ，和一个整数值 <code>K</code> 。</p><p>返回到目标结点 <code>target</code> 距离为 <code>K</code> 的所有结点的值的列表。 答案可以以任何顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：root = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>, K = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br>解释：<br>所求结点为与目标结点（值为 <span class="hljs-number">5</span>）距离为 <span class="hljs-number">2</span> 的结点，<br>值分别为 <span class="hljs-number">7</span>，<span class="hljs-number">4</span>，以及 <span class="hljs-number">1</span><br><br><br><br>注意，输入的 <span class="hljs-string">&quot;root&quot;</span> 和 <span class="hljs-string">&quot;target&quot;</span> 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定的树是非空的。</li><li>树上的每个结点都具有唯一的值 <code>0 &lt;= node.val &lt;= 500</code> 。</li><li>目标结点 <code>target</code> 是树上的结点。</li><li><code>0 &lt;= K &lt;= 1000</code>.</li></ol></li></ul><h2 id="方法一：深度优先搜索-哈希表"><a href="#方法一：深度优先搜索-哈希表" class="headerlink" title="方法一：深度优先搜索 + 哈希表"></a>方法一：深度优先搜索 + 哈希表</h2><p>若将 \textit{target}target 当作树的根结点，我们就能从 \textit{target}target 出发，使用深度优先搜索去寻找与 \textit{target}target 距离为 kk 的所有结点，即深度为 kk 的所有结点。</p><p>由于输入的二叉树没有记录父结点，为此，我们从根结点 \textit{root}root 出发，使用深度优先搜索遍历整棵树，同时用一个哈希表记录每个结点的父结点。</p><p>然后从 \textit{target}target 出发，使用深度优先搜索遍历整棵树，除了搜索左右儿子外，还可以顺着父结点向上搜索。</p><p>代码实现时，由于每个结点值都是唯一的，哈希表的键可以用结点值代替。此外，为避免在深度优先搜索时重复访问结点，递归时额外传入来源结点 \textit{from}from，在递归前比较目标结点是否与来源结点相同，不同的情况下才进行递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    unordered_map&lt;<span class="hljs-type">int</span>, TreeNode*&gt; parents;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findParents</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>        parents[node-&gt;left-&gt;val] = node;<br>        <span class="hljs-built_in">findParents</span>(node-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>        parents[node-&gt;right-&gt;val] = node;<br>        <span class="hljs-built_in">findParents</span>(node-&gt;right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findAns</span><span class="hljs-params">(TreeNode* node, TreeNode* from, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (depth == k) &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;left != from) &#123;<br>        <span class="hljs-built_in">findAns</span>(node-&gt;left, node, depth + <span class="hljs-number">1</span>, k);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node-&gt;right != from) &#123;<br>        <span class="hljs-built_in">findAns</span>(node-&gt;right, node, depth + <span class="hljs-number">1</span>, k);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (parents[node-&gt;val] != from) &#123;<br>        <span class="hljs-built_in">findAns</span>(parents[node-&gt;val], node, depth + <span class="hljs-number">1</span>, k);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 从 root 出发 DFS，记录每个结点的父结点</span><br>        <span class="hljs-built_in">findParents</span>(root);<br><br>    <span class="hljs-comment">// 从 target 出发 DFS，寻找所有深度为 k 的结点</span><br>    <span class="hljs-built_in">findAns</span>(target, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, k);<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>想是想到将第二大的节点作为父节点再去深搜了，但不会写Orz。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-27 每日一题</title>
    <link href="/2021/07/27/2021.7.27%20daily%20problem/"/>
    <url>/2021/07/27/2021.7.27%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a><a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h4><p>难度简单154</p><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 <code>2</code> 或 <code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p><p>更正式地说，<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p><p>给出这样的一个二叉树，你需要输出所有节点中的<strong>第二小的值。</strong>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">5</span><br>解释：最小的值是 <span class="hljs-number">2</span> ，第二小的值是 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg" alt="img"></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs coq">  输入：root = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>  输出：<span class="hljs-number">-1</span><br>  解释：最小的值是 <span class="hljs-number">2</span>, 但是不存在第二小的值。<br><br>  <br><br><br>  **提示：**<br><br>- 树中节点数目在范围 `[<span class="hljs-number">1</span>, <span class="hljs-number">25</span>]` 内<br>  - `<span class="hljs-number">1</span> &lt;= Node.val &lt;= <span class="hljs-number">231</span> - <span class="hljs-number">1</span>`<br>- 对于树中每个节点 `root.val == min(root.<span class="hljs-built_in">left</span>.val, root.<span class="hljs-built_in">right</span>.val)`<br><br><br><br><br><br>## 方法一：先序遍历<br><br>直接对二叉树所有元素进行遍历，然后用<span class="hljs-built_in">set</span>记录所有出现过的值（不会重复）最后输出第二小的值完事了。<br><br>```c++<br>/**<br> * <span class="hljs-keyword">Definition</span> <span class="hljs-keyword">for</span> a binary tree node.<br> * struct TreeNode &#123;<br> *     int val;<br> *     TreeNode *<span class="hljs-built_in">left</span>;<br> *     TreeNode *<span class="hljs-built_in">right</span>;<br> *     TreeNode() : val(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x) : val(x), <span class="hljs-built_in">left</span>(nullptr), <span class="hljs-built_in">right</span>(nullptr) &#123;&#125;<br> *     TreeNode(int x, TreeNode *<span class="hljs-built_in">left</span>, TreeNode *<span class="hljs-built_in">right</span>) : val(x), <span class="hljs-built_in">left</span>(<span class="hljs-built_in">left</span>), <span class="hljs-built_in">right</span>(<span class="hljs-built_in">right</span>) &#123;&#125;<br> * &#125;;<br> */<br>class Solution &#123;<br>public:<br>    <span class="hljs-built_in">set</span>&lt;int&gt; arr;<br>    void travsal(TreeNode* root)&#123;<br>        arr.insert(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">left</span>!=nullptr)&#123;<br>            travsal(root-&gt;<span class="hljs-built_in">left</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">right</span>!=nullptr)&#123;<br>            travsal(root-&gt;<span class="hljs-built_in">right</span>);<br>        &#125;<br>    &#125;<br>    int findSecondMinimumValue(TreeNode* root) &#123;<br>        travsal(root);<br>        vector&lt;int&gt; ans;<br>        int flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> it = arr.begin();it!=arr.<span class="hljs-keyword">end</span>();it++)&#123;<br>            ans.push_back<span class="hljs-comment">(*it);</span><br><span class="hljs-comment">            if(ans.size()==2)&#123;</span><br><span class="hljs-comment">                flag=1;</span><br><span class="hljs-comment">                break;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        if(flag==1)&#123;</span><br><span class="hljs-comment">            return ans[1];</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        else&#123;</span><br><span class="hljs-comment">            return -1;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-26 每日一题</title>
    <link href="/2021/07/26/2021.7.26%20daily%20problem/"/>
    <url>/2021/07/26/2021.7.26%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1713-得到子序列的最少操作次数"><a href="#1713-得到子序列的最少操作次数" class="headerlink" title="1713. 得到子序列的最少操作次数"></a><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/">1713. 得到子序列的最少操作次数</a></h4><p>难度困难70</p><p>给你一个数组 <code>target</code> ，包含若干 <strong>互不相同</strong> 的整数，以及另一个整数数组 <code>arr</code> ，<code>arr</code> <strong>可能</strong> 包含重复元素。</p><p>每一次操作中，你可以在 <code>arr</code> 的任意位置插入任一整数。比方说，如果 <code>arr = [1,4,1,2]</code> ，那么你可以在中间添加 <code>3</code> 得到 <code>[1,4,**3**,1,2]</code> 。你可以在数组最开始或最后面添加整数。</p><p>请你返回 <strong>最少</strong> 操作次数，使得 <code>target</code> 成为 <code>arr</code> 的一个子序列。</p><p>一个数组的 <strong>子序列</strong> 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，<code>[2,7,4]</code> 是 <code>[4,**2**,3,**7**,2,1,**4**]</code> 的子序列（加粗元素），但 <code>[2,4,2]</code> 不是子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：target = <span class="hljs-comment">[5,1,3]</span>, arr = <span class="hljs-comment">[9,4,2,3,4]</span><br>输出：2<br>解释：你可以添加 5 和 1 ，使得 arr 变为 <span class="hljs-comment">[5,9,4,1,2,3,4]</span> ，target 为 arr 的子序列。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：target = [<span class="hljs-number">6,4,8,1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], arr = [<span class="hljs-number">4,7,6,2</span>,<span class="hljs-number">3,8,6,1</span>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target.length, arr.length &lt;= 105</code></li><li><code>1 &lt;= target[i], arr[i] &lt;= 109</code></li><li><code>target</code> 不包含任何重复元素。</li></ul><p>通过次数5,083</p><p>提交次数10,434</p></li></ul><h2 id="方法一：贪心-二分查找"><a href="#方法一：贪心-二分查找" class="headerlink" title="方法一：贪心 + 二分查找"></a>方法一：贪心 + 二分查找</h2><p>记数组 \textit{target}target 的长度为 nn，数组\textit{arr}arr 的长度为 mm。</p><p>根据题意，\textit{target}target 和 \textit{arr}arr 这两个数组的公共子序列越长，需要添加的元素个数也就越少。因此最少添加的元素个数为 nn 减去两数组的最长公共子序列的长度。</p><p>求最长公共子序列是一个经典问题，读者可参考「1143. 最长公共子序列的官方题解」。但是，这一做法的时间复杂度是 O(nm)O(nm) 的，在本题的数据范围下无法承受，我们需要改变思路。</p><p>由于 \textit{target}target 的元素互不相同，我们可以用一个哈希表记录 \textit{target}target 的每个元素所处的下标，并将 \textit{arr}arr 中的元素映射到下标上，对于不存在于 \textit{target}target 中的元素，由于其必然不会在最长公共子序列中，可将其忽略。</p><p>我们使用示例 22 来说明，将 \textit{arr}arr 中的元素转换成该元素在 \textit{target}target 中的下标（去掉不在 \textit{target}target 中的元素 77），可以得到一个新数组</p><p>\textit{arr}’ &#x3D; [1,0,5,4,2,0,3]<br>arr<br>′<br> &#x3D;[1,0,5,4,2,0,3]</p><p>若将 \textit{target}target 也做上述转换，这相当于将每个元素变为其下标，得</p><p>\textit{target}’ &#x3D; [0,1,2,3,4,5]<br>target<br>′<br> &#x3D;[0,1,2,3,4,5]</p><p>则求原数组的最长公共子序列等价于求上述转换后的两数组的最长公共子序列。</p><p>注意到 \textit{target}’target<br>′<br>  是严格单调递增的，因此 \textit{arr}’arr<br>′<br>  在最长公共子序列中的部分也必须是严格单调递增的，因此问题可进一步地转换成求 \textit{arr}’arr<br>′<br>  的最长递增子序列的长度。这也是一个经典问题，读者可以参考「300. 最长递增子序列的官方题解」，使用贪心和二分查找的方法得到最长递增子序列的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;target, vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = target.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pos;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            pos[target[i]] = i;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; d;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : arr) &#123;<br>            <span class="hljs-keyword">if</span> (pos.<span class="hljs-built_in">count</span>(val)) &#123;<br>                <span class="hljs-type">int</span> idx = pos[val];<br>                <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), idx);<br>                <span class="hljs-keyword">if</span> (it != d.<span class="hljs-built_in">end</span>()) &#123;<br>                    *it = idx;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    d.<span class="hljs-built_in">push_back</span>(idx);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n - d.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>看到困难就承受不住，这次完全是看题解的，直接贴答案吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-25 每日一题</title>
    <link href="/2021/07/26/2021.7.25%20daily%20problem/"/>
    <url>/2021/07/26/2021.7.25%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1743-从相邻元素对还原数组"><a href="#1743-从相邻元素对还原数组" class="headerlink" title="1743. 从相邻元素对还原数组"></a><a href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/">1743. 从相邻元素对还原数组</a></h4><p>难度中等</p><p>存在一个由 <code>n</code> 个不同元素组成的整数数组 <code>nums</code> ，但你已经记不清具体内容。好在你还记得 <code>nums</code> 中的每一对相邻元素。</p><p>给你一个二维整数数组 <code>adjacentPairs</code> ，大小为 <code>n - 1</code> ，其中每个 <code>adjacentPairs[i] = [ui, vi]</code> 表示元素 <code>ui</code> 和 <code>vi</code> 在 <code>nums</code> 中相邻。</p><p>题目数据保证所有由元素 <code>nums[i]</code> 和 <code>nums[i+1]</code> 组成的相邻元素对都存在于 <code>adjacentPairs</code> 中，存在形式可能是 <code>[nums[i], nums[i+1]]</code> ，也可能是 <code>[nums[i+1], nums[i]]</code> 。这些相邻元素对可以 <strong>按任意顺序</strong> 出现。</p><p>返回 <strong>原始数组</strong> <code>nums</code> 。如果存在多种解答，返回 <strong>其中任意一个</strong> 即可。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：adjacentPairs = <span class="hljs-comment">[<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[3,2]</span>]</span><br>输出：<span class="hljs-comment">[1,2,3,4]</span><br>解释：数组的所有相邻元素对都在 adjacentPairs 中。<br>特别要注意的是，adjacentPairs<span class="hljs-comment">[i]</span> 只表示两个元素相邻，并不保证其 左-右 顺序。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：adjacentPairs = <span class="hljs-comment">[<span class="hljs-comment">[4,-2]</span>,<span class="hljs-comment">[1,4]</span>,<span class="hljs-comment">[-3,1]</span>]</span><br>输出：<span class="hljs-comment">[-2,4,1,-3]</span><br>解释：数组中可能存在负数。<br>另一种解答是 <span class="hljs-comment">[-3,1,4,-2]</span> ，也会被视作正确答案。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：adjacentPairs = <span class="hljs-string">[[100000,-100000]]</span><br>输出：[<span class="hljs-number">100000</span>,<span class="hljs-number">-100000</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums.length == n</code></li><li><code>adjacentPairs.length == n - 1</code></li><li><code>adjacentPairs[i].length == 2</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>-105 &lt;= nums[i], ui, vi &lt;= 105</code></li><li>题目数据保证存在一些以 <code>adjacentPairs</code> 作为元素对的数组 <code>nums</code></li></ul></li></ul><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p>首先，遍历给出来的二维整数数组，把每一pair的两个元素，互相把对方链入自己的哈希索引里面；全部遍历后建立哈希表。</p><p>哈希表的索引本身就是数组的元素，然后索引下的元素就是它的相邻元素。</p><p>紧接着遍历哈希表，找出第一个索引长度只有1的元素（头尾一共两个 任意一个）记为起点。</p><p>然后就是把元素逐个加入答案数组，检查的时候我们用一个set来存放已经出现过的数，有两个索引的元素只要找出任意一个没出现过的数就可以将其置为起点，直至答案数组的长度增长至n+1（n是相邻数字的组数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">restoreArray</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; adjacentPairs)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt; list;<br>        <span class="hljs-type">int</span> n = adjacentPairs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            list[adjacentPairs[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(adjacentPairs[i][<span class="hljs-number">0</span>]);<br>            list[adjacentPairs[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(adjacentPairs[i][<span class="hljs-number">1</span>]);<br>        &#125;<br>        set&lt;<span class="hljs-type">int</span>&gt; judge;<span class="hljs-comment">//检查某个数是否出现过</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=list.<span class="hljs-built_in">begin</span>();it!=list.<span class="hljs-built_in">end</span>();it++)&#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;second.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//找起点</span><br>                judge.<span class="hljs-built_in">insert</span>(it-&gt;first);<span class="hljs-comment">//这里要注意取的是first</span><br>                res.<span class="hljs-built_in">push_back</span>(it-&gt;first);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> start = res[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span>(res.<span class="hljs-built_in">size</span>()&lt;n+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;list[start].<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-comment">//if(!judge.find(list[start][i]))不能这样写,按下面写</span><br>                <span class="hljs-keyword">if</span>(judge.<span class="hljs-built_in">find</span>(list[start][i])==judge.<span class="hljs-built_in">end</span>())&#123;<br>                    start = list[start][i];<br>                    res.<span class="hljs-built_in">push_back</span>(start);<br>                    judge.<span class="hljs-built_in">insert</span>(start);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这次做题还是对unordered_map和set的函数不熟练。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-24 每日一题</title>
    <link href="/2021/07/24/2021.7.24%20daily%20problem/"/>
    <url>/2021/07/24/2021.7.24%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1736-替换隐藏数字得到的最晚时间"><a href="#1736-替换隐藏数字得到的最晚时间" class="headerlink" title="1736. 替换隐藏数字得到的最晚时间"></a><a href="https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/">1736. 替换隐藏数字得到的最晚时间</a></h4><p>难度简单14</p><p>给你一个字符串 <code>time</code> ，格式为 <code>hh:mm</code>（小时：分钟），其中某几位数字被隐藏（用 <code>?</code> 表示）。</p><p>有效的时间为 <code>00:00</code> 到 <code>23:59</code> 之间的所有时间，包括 <code>00:00</code> 和 <code>23:59</code> 。</p><p>替换 <code>time</code> 中隐藏的数字，返回你可以得到的最晚有效时间。</p><p><strong>示例 1：</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：<span class="hljs-built_in">time</span> = <span class="hljs-string">&quot;2?:?0&quot;</span><br>输出：<span class="hljs-string">&quot;23:50&quot;</span><br>解释：以数字 <span class="hljs-string">&#x27;2&#x27;</span> 开头的最晚一小时是 <span class="hljs-number">23</span> ，以 <span class="hljs-string">&#x27;0&#x27;</span> 结尾的最晚一分钟是 <span class="hljs-number">50</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：time <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0?:3?&quot;</span><br>输出：<span class="hljs-string">&quot;09:39&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：time <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1?:22&quot;</span><br>输出：<span class="hljs-string">&quot;19:22&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>time</code> 的格式为 <code>hh:mm</code></li><li>题目数据保证你可以由输入的字符串生成有效的时间</li></ul></li></ul><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p>直接模拟。</p><p>小学生代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">maximumTime</span><span class="hljs-params">(string time)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(time[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(time[<span class="hljs-number">1</span>]&gt;<span class="hljs-string">&#x27;3&#x27;</span>&amp;&amp;time[<span class="hljs-number">1</span>]!=<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                time[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                time[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;2&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(time[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(time[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;2&#x27;</span>)&#123;<br>                time[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;3&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                time[<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(time[<span class="hljs-number">3</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>            time[<span class="hljs-number">3</span>]=<span class="hljs-string">&#x27;5&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(time[<span class="hljs-number">4</span>]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>            time[<span class="hljs-number">4</span>]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-23 每日一题</title>
    <link href="/2021/07/23/2021.7.23%20daily%20problem/"/>
    <url>/2021/07/23/2021.7.23%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1893-检查是否区域内所有整数都被覆盖-https-leetcode-cn-com-problems-check-if-all-the-integers-in-a-range-are-covered"><a href="#1893-检查是否区域内所有整数都被覆盖-https-leetcode-cn-com-problems-check-if-all-the-integers-in-a-range-are-covered" class="headerlink" title="1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)"></a>1893. 检查是否区域内所有整数都被覆盖](<a href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/">https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/</a>)</h4><p>难度简单35</p><p>给你一个二维整数数组 <code>ranges</code> 和两个整数 <code>left</code> 和 <code>right</code> 。每个 <code>ranges[i] = [starti, endi]</code> 表示一个从 <code>starti</code> 到 <code>endi</code> 的 <strong>闭区间</strong> 。</p><p>如果闭区间 <code>[left, right]</code> 内每个整数都被 <code>ranges</code> 中 <strong>至少一个</strong> 区间覆盖，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>已知区间 <code>ranges[i] = [starti, endi]</code> ，如果整数 <code>x</code> 满足 <code>starti &lt;= x &lt;= endi</code> ，那么我们称整数<code>x</code> 被覆盖了。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：ranges = <span class="hljs-string">[[1,2],[3,4],[5,6]]</span>, left = <span class="hljs-number">2</span>, right = <span class="hljs-number">5</span><br>输出：<span class="hljs-literal">true</span><br>解释：<span class="hljs-number">2</span> 到 <span class="hljs-number">5</span> 的每个整数都被覆盖了：<br>- <span class="hljs-number">2</span> 被第一个区间覆盖。<br>- <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 被第二个区间覆盖。<br>- <span class="hljs-number">5</span> 被第三个区间覆盖。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：ranges = <span class="hljs-string">[[1,10],[10,20]]</span>, left = <span class="hljs-number">21</span>, right = <span class="hljs-number">21</span><br>输出：<span class="hljs-literal">false</span><br>解释：<span class="hljs-number">21</span> 没有被任何一个区间覆盖。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ranges.length &lt;= 50</code></li><li><code>1 &lt;= starti &lt;= endi &lt;= 50</code></li><li><code>1 &lt;= left &lt;= right &lt;= 50</code></li></ul></li></ul><h2 id="方法一：标记法"><a href="#方法一：标记法" class="headerlink" title="方法一：标记法"></a>方法一：标记法</h2><p>检查每个区间，把区间内全部标1。</p><p>然后检查left到right，如果某个位置不是1则返回false。</p><p>小学生代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCovered</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; ranges, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> area[<span class="hljs-number">2501</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ranges.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = ranges[i][<span class="hljs-number">0</span>];j&lt;=ranges[i][<span class="hljs-number">1</span>];j++)&#123;<br>                area[j]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = left;i&lt;=right;i++)&#123;<br>            <span class="hljs-keyword">if</span>(area[i]==<span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-22 每日一题</title>
    <link href="/2021/07/22/2021.7.22%20daily%20problem/"/>
    <url>/2021/07/22/2021.7.22%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h4><p>难度中等667</p><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[7,null]</span>,<span class="hljs-comment">[13,0]</span>,<span class="hljs-comment">[11,4]</span>,<span class="hljs-comment">[10,2]</span>,<span class="hljs-comment">[1,0]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[1,1],[2,1]]</span><br>输出：<span class="hljs-string">[[1,1],[2,1]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：head = <span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br>输出：<span class="hljs-string">[[3,null],[3,0],[3,null]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：给定的链表为空（空指针），因此返回 null。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-10000 &lt;= Node.val &lt;= 10000</code></li><li><code>Node.random</code> 为空（null）或指向链表中的节点。</li></ul></li></ul><h2 id="方法一：回溯-哈希表"><a href="#方法一：回溯-哈希表" class="headerlink" title="方法一：回溯 + 哈希表"></a>方法一：回溯 + 哈希表</h2><p>思路及算法</p><p>本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建，因此我们需要变换思路。一个可行方案是，我们利用回溯的方式，让每个节点的拷贝操作相互独立。对于当前节点，我们首先要进行拷贝，然后我们进行「当前节点的后继节点」和「当前节点的随机指针指向的节点」拷贝，拷贝完成后将创建的新节点的指针返回，即可完成当前节点的两指针的赋值。</p><p>具体地，我们用哈希表记录每一个节点对应新节点的创建情况。遍历该链表的过程中，我们检查「当前节点的后继节点」和「当前节点的随机指针指向的节点」的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</p><p>在实际代码中，我们需要特别判断给定节点为空节点的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cachedNode.<span class="hljs-built_in">count</span>(head)) &#123;<br>            Node* headNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = headNew;<br>            headNew-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            headNew-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cachedNode[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-21 每日一题</title>
    <link href="/2021/07/21/2021.7.21%20daily%20problem/"/>
    <url>/2021/07/21/2021.7.21%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度简单1269</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,0,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>0 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p></li></ul><h2 id="方法一：双指针同步"><a href="#方法一：双指针同步" class="headerlink" title="方法一：双指针同步"></a>方法一：双指针同步</h2><p>先找出长度差，长的链表先走相差的步数，构造出两条链都只需要走相同的步数到达尾节点。</p><p>然后同步前进，若节点相同则代表交点。</p><p>小学生式代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *p,*q;<br>        p = headA;<br>        q = headB;<br>        ListNode *ans=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">NULL</span>||headB==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-type">int</span> len1=<span class="hljs-number">0</span>,len2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>            len1++;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>            len2++;<br>            q = q-&gt;next;<br>        &#125;<br>        p = headA;<br>        q = headB;<br>        <span class="hljs-keyword">if</span>(len1&gt;len2)&#123;<br>            <span class="hljs-type">int</span> temp = len1-len2;<br>            <span class="hljs-keyword">while</span>(temp&gt;<span class="hljs-number">0</span>)&#123;<br>                p=p-&gt;next;<br>                temp--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> temp = len2-len1;<br>            <span class="hljs-keyword">while</span>(temp&gt;<span class="hljs-number">0</span>)&#123;<br>                q=q-&gt;next;<br>                temp--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p == q)&#123;<br>                ans = p;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                p = p-&gt;next;<br>                q = q-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：双指针交替法"><a href="#方法二：双指针交替法" class="headerlink" title="方法二：双指针交替法"></a>方法二：双指针交替法</h2><p>两个指针分别从A，B链表出发；当A链表遍历完的时候跳转到B链表；反之从B到A。</p><p>因为每次A,B的前进步数都是一步，而链表是交错的，如果相交，就一定通过有限次绕圈同时到达交错点。</p><p>如果不相交，也一定可以通过有限次绕圈同时到达NULL.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span>ptr || headB == <span class="hljs-literal">null</span>ptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>ptr;<br>        &#125;<br>        ListNode *p = headA, *q = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            p = p == <span class="hljs-literal">null</span>ptr ? headB : p-&gt;next;<br>            q = q == <span class="hljs-literal">null</span>ptr ? headA : q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Essay-01</title>
    <link href="/2021/07/20/essay-01/"/>
    <url>/2021/07/20/essay-01/</url>
    
    <content type="html"><![CDATA[<h3 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h3><p>毕业回来之后，真觉得老爸年纪变大了，明显和以前的感觉不太一样了。</p><p>想起以前看到的一句话，“要好好努力，不然赶不上父母老去的速度。”</p><p>有时想想自己真的是不算足够努力，20几岁了，还是很贪玩，时常有点自责。</p><p>总归是要做点事情啊，希望这些文字，能鞭笞一下自己。</p>]]></content>
    
    
    
    <tags>
      
      <tag>essay</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-20 每日一题</title>
    <link href="/2021/07/20/2021.7.20%20daily%20problem/"/>
    <url>/2021/07/20/2021.7.20%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1877-数组中最大数对和的最小值"><a href="#1877-数组中最大数对和的最小值" class="headerlink" title="1877. 数组中最大数对和的最小值"></a><a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h4><p>难度中等34</p><p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><ul><li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li></ul><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p><ul><li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,2,3]</span><br>输出：<span class="hljs-number">7</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) 和 (<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">3</span>, <span class="hljs-number">5</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>) = <span class="hljs-number">7</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,5,4,2,4,6]</span><br>输出：<span class="hljs-number">8</span><br>解释：数组中的元素可以分为数对 (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)，(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>) 和 (<span class="hljs-number">6</span>,<span class="hljs-number">2</span>) 。<br>最大数对和为 <span class="hljs-built_in">max</span>(<span class="hljs-number">3</span>+<span class="hljs-number">5</span>, <span class="hljs-number">4</span>+<span class="hljs-number">4</span>, <span class="hljs-number">6</span>+<span class="hljs-number">2</span>) = <span class="hljs-built_in">max</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>) = <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>n</code> 是 <strong>偶数</strong> 。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul></li></ul><h2 id="方法一：对折求和"><a href="#方法一：对折求和" class="headerlink" title="方法一：对折求和"></a>方法一：对折求和</h2><p>类似高斯求和的方式，前后两两相加，这种情况构造的pair和是最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPairSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//vector&lt;int&gt; res(n/2);</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-comment">//res[i] = nums[i] + nums[n-1-i];</span><br>            nums[i] = nums[i] + nums[n<span class="hljs-number">-1</span>-i];<br>        &#125;<br>        <span class="hljs-comment">//return *max_element(res.begin(),res.end());</span><br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-19 每日一题</title>
    <link href="/2021/07/19/2021.7.19%20daily%20problem/"/>
    <url>/2021/07/19/2021.7.19%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1838-最高频元素的频数"><a href="#1838-最高频元素的频数" class="headerlink" title="1838. 最高频元素的频数"></a><a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></h4><p>难度中等</p><p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,4], k = 5<br>输出：3<br>解释：对第一个元素执行<span class="hljs-number"> 3 </span>次递增操作，对第二个元素执<span class="hljs-number"> 2 </span>次递增操作，此时 nums = [4,4,4] 。<br>4 是数组中最高频元素，频数是<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,4,8,13], k = 5<br>输出：2<br>解释：存在多种最优解决方案：<br>- 对第一个元素执行<span class="hljs-number"> 3 </span>次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第二个元素执行<span class="hljs-number"> 4 </span>次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br>- 对第三个元素执行<span class="hljs-number"> 5 </span>次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,9,6], k = 2</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul></li></ul><h2 id="方法一：排序-滑动窗口"><a href="#方法一：排序-滑动窗口" class="headerlink" title="方法一：排序+滑动窗口"></a>方法一：排序+滑动窗口</h2><p>自己用最捞的枚举优化后还是超时，没搞出来，用官方答案解法。</p><p>将数组排序，遍历排序后数组每个元素<br>$$<br>x_r<br>$$<br>  作为目标值，并求出此时按贪心策略可以改变至目标值的元素左边界。</p><p>此时考虑到数据范围为<br>$$<br>10^5<br>$$<br> ，朴素的线性查找显然会超时，因此需要寻找可以优化的性质。</p><p>我们可以枚举<br>$$<br>x_r<br>$$<br>  作为目标值。假设<br>$$<br>x_r<br>$$<br>  对应的答案左边界为<br>$$<br>x_l<br>$$<br> ，定义<br>$$<br>\Delta(l, r)Δ(l,r) 为将 x_l,\dots,x_r全部变为x_r<br>$$</p><p>  所需要的操作次数：</p><p>$$<br>\Delta(l, r) &#x3D; \sum_{i &#x3D; l}^{r} (x_r - x_i) &#x3D; (r - l)x_r - \sum_{i &#x3D; l}^{r-1} x_i.<br>$$<br>考虑右边界 rr 右移至 r + 1r+1 的过程，此时：</p><p>$$<br>\Delta(l, r + 1) - \Delta(l, r) &#x3D; (x_{r + 1} - x_{r})\cdot(r - l + 1) \ge 0.<br>$$<br>操作数有可能超过限制 kk，因此在超过限制的情况下，我们需要移动左边界 ll。同样考虑左边界 ll 右移至 l + 1l+1 的过程，此时:</p><p>$$<br>\Delta(l + 1, r + 1) - \Delta(l, r + 1) &#x3D; -(x_{r + 1} - x_{l}) \le 0.<br>$$</p><p>这说明右移左边界会使得答案减小，因此我们需要移动左边界直至对应的<br>$$<br>\Delta(l’, r + 1)<br>$$<br> 不大于 k。</p><p>我们使用 l 与 r 作为执行操作的左右边界（闭区间），同时用total 来维护将 [l, r][l,r] 区间全部变为末尾元素的操作次数。在顺序枚举目标值（右边界）的同时，我们更新对应的左边界，并用res 来维护满足限制的最大区间元素数量即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxFrequency</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt; n; ++r) &#123;<br>            total += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(nums[r] - nums[r - <span class="hljs-number">1</span>]) * (r - l);<br>            <span class="hljs-keyword">while</span> (total &gt; k) &#123;<br>                total -= nums[r] - nums[l];<br>                ++l;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-18 每日一题</title>
    <link href="/2021/07/18/2021.7.18%20daily%20problem/"/>
    <url>/2021/07/18/2021.7.18%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a><a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></h4><p>难度中等</p><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p><strong>注意：</strong>本题相对原题稍作修改</p><p><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>],<br>输出:<br>[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h2 id="方法一：哈希映射"><a href="#方法一：哈希映射" class="headerlink" title="方法一：哈希映射"></a>方法一：哈希映射</h2><p>其实一开始看到这种分堆输出的，还以为要用并查集，但自己之前都没写过，想着可能没法做了。</p><p>然后也想过哈希链表键值对，但似乎又不能编成自己想要的链表形状。。</p><p>看了一下能用unordered_map，就两下子写出答案了。</p><p>思路就是，相同字母的词组里面的字母都是一致的，给这些字母找一个共同的键值，我在这里的处理是将他排序后作为键值，然后以这个键值插入目标字符串。</p><p>最后遍历unordered_map的储存位就能得到答案了。</p><p>（其实我不是很懂为什么指向second就把全部东西push进去了，回头看看unordered_map相关的文章）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string,vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : strs)&#123;<br>            <span class="hljs-keyword">auto</span> key = i;<br>            <span class="hljs-built_in">sort</span>(key.<span class="hljs-built_in">begin</span>(),key.<span class="hljs-built_in">end</span>());<br>            hash[key].<span class="hljs-built_in">emplace_back</span>(i);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=hash.<span class="hljs-built_in">begin</span>();it!=hash.<span class="hljs-built_in">end</span>();it++)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多说一句，auto真好用。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-17 每日一题</title>
    <link href="/2021/07/17/2021.7.17%20daily%20problem/"/>
    <url>/2021/07/17/2021.7.17%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="剑指-Offer-42-连续子数组的最大和"><a href="#剑指-Offer-42-连续子数组的最大和" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和"></a><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h4><p>难度简单</p><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><strong>示例1:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">  输入: nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出: 6<br>  解释: 连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li></ul></li><li><p><code>-100 &lt;= arr[i] &lt;= 100</code></p></li></ul><h2 id="方法一：-遍历查找"><a href="#方法一：-遍历查找" class="headerlink" title="方法一： 遍历查找"></a>方法一： 遍历查找</h2><p>非常基础的一道动态规划，每次储存包含到当前位置的最大子数列和就行，如果前面的加上本体还要更小证明前面的是负数，就只取本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums)</span></span>;<br>        res[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            res[i] = <span class="hljs-built_in">max</span>(nums[i],res[i<span class="hljs-number">-1</span>]+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-16 每日一题</title>
    <link href="/2021/07/16/2021.7.16%20daily%20problem/"/>
    <url>/2021/07/16/2021.7.16%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">剑指 Offer 53 - I. 在排序数组中查找数字 I</a></h4><p>难度简单</p><p>统计一个数字在排序数组中出现的次数。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="hljs-section">输出: 2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&lt;= 数组长度 &lt;= <span class="hljs-number">50000</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="方法一：-遍历查找"><a href="#方法一：-遍历查找" class="headerlink" title="方法一： 遍历查找"></a>方法一： 遍历查找</h2><p>直接找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:nums)&#123;<br>            <span class="hljs-keyword">if</span>(i==target)&#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：二分查找上下界"><a href="#方法二：二分查找上下界" class="headerlink" title="方法二：二分查找上下界"></a>方法二：二分查找上下界</h2><p>看到有评论说这道面试题问到了肯定是想看你用二分法。</p><p>于是用二分试一下，一开始的想法是用二分法找到目标，然后往前往后找相同的。</p><p>但是写的时候要给很多特殊测例写特殊判断，太复杂反而不是好方法。从这点来看的话我还是太low了。。。</p><p>看了一下其他人的方法，是通过找上下界然后上界标和下界标作差得到答案。</p><p>于是就按这个思路写了一个。（坑点记在代码注释里）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span> ,high = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//查找右边界</span><br>        <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>            <span class="hljs-type">int</span> mid = (high+low)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;=target)&#123;<span class="hljs-comment">//找右边界，所以是小于等于target就移动下界</span><br>                low = mid +<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                high = mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(high&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[high]!=target)&#123;<span class="hljs-comment">//提前返回，high&gt;=0要放前面，因为数组太短high可能会小于0，这样nums访问是非法的。if也是有一个不真后面就不看了，基础的“顺序编译”知识。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> right = low;<span class="hljs-comment">//最后low就是目标上界，high是要比low大于等于的，所以肯定是low</span><br>        <span class="hljs-comment">//查找左边界</span><br>        low = <span class="hljs-number">0</span>;high=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<br>            <span class="hljs-type">int</span> mid = (high+low)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=target)&#123;<span class="hljs-comment">//同理</span><br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> left = high;<br>        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;<span class="hljs-comment">//记得减一，因为只取r和l夹在中间的部分</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-15 每日一题</title>
    <link href="/2021/07/15/2021.7.15%20daily%20problem/"/>
    <url>/2021/07/15/2021.7.15%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1846-减小和重新排列数组后的最大元素"><a href="#1846-减小和重新排列数组后的最大元素" class="headerlink" title="1846. 减小和重新排列数组后的最大元素"></a><a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></h4><p>难度中等</p><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code> 。</li><li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[2,2,1,2,1]</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>我们可以重新排列 arr 得到 <span class="hljs-string">[1,2,2,2,1]</span> ，该数组满足所有条件。<br>arr 中最大元素为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">输入：arr = [100,1,1000]<br>输出：3<br>解释：<br>一个可行的方案如下：<br><span class="hljs-bullet">1.</span> 重新排列 arr 得到 [1,100,1000] 。<br><span class="hljs-bullet">2.</span> 将第二个元素减小为 2 。<br><span class="hljs-bullet">3.</span> 将第三个元素减小为 3 。<br>现在 arr = [1,2,3] ，满足所有条件。<br>arr 中最大元素为 3 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,2,3,4,5]</span><br>输出：<span class="hljs-number">5</span><br>解释：数组已经满足所有条件，最大元素为 <span class="hljs-number">5</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 105</code></li><li><code>1 &lt;= arr[i] &lt;= 109</code></li></ul></li></ul><h2 id="方法一：-排序贪心"><a href="#方法一：-排序贪心" class="headerlink" title="方法一： 排序贪心"></a>方法一： 排序贪心</h2><p>阅读题目后不难发现，使得目标最大的结果就是1~n的均差为1的等差数列，所以只需要对原数组进行一次排序，然后相邻元素之间如果不相等，就将后一个修改成前面的值大1的数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len = arr.<span class="hljs-built_in">size</span>();<br>        arr[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(arr[i+<span class="hljs-number">1</span>] - arr[i]) &gt; <span class="hljs-number">1</span>)&#123;<br>                arr[i+<span class="hljs-number">1</span>] = arr[i]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[len<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>今天题目好简单，哈哈。</p><h2 id="方法二：计数排序"><a href="#方法二：计数排序" class="headerlink" title="方法二：计数排序"></a>方法二：计数排序</h2><p>换一个角度思考，其实也可以找出1~n之间数列的空缺元素，然后用大的值去填补空缺元素。</p><p>所以可以用cnt[n]数组去记录每个值的出现次数，无出现过的元素cnt[i]&#x3D;0；比n大的元素全都加在cnt[n]上。</p><p>第二次遍历的时候用miss记录第i位之前空缺元素的个数，当cnt[i]不等于0的时候，就尽可能去把miss值变小。（但要记住cnt[i]至少要保留剩1）</p><p>最后n-miss的值就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximumElementAfterDecrementingAndRearranging</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : arr)&#123;<br>            cnt[<span class="hljs-built_in">min</span>(i,n)]++;<span class="hljs-comment">//记录出现次数</span><br>        &#125;<br>        <span class="hljs-type">int</span> miss=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意这里的下标要从1开始</span><br>            <span class="hljs-keyword">if</span>(cnt[i]==<span class="hljs-number">0</span>)&#123;<br>                miss++;<span class="hljs-comment">//记录i位前的空缺次数</span><br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                miss -= <span class="hljs-built_in">min</span>(cnt[i]<span class="hljs-number">-1</span>,miss);<span class="hljs-comment">//miss值不能是负数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n-miss;<span class="hljs-comment">//miss代表空缺元素的数量，包括前面空缺和后面空缺，所以直接n-miss</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-14 每日一题</title>
    <link href="/2021/07/14/2021.7.14%20daily%20problem/"/>
    <url>/2021/07/14/2021.7.14%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<ul><li><h4 id="1818-绝对差值和"><a href="#1818-绝对差值和" class="headerlink" title="1818. 绝对差值和"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">1818. 绝对差值和</a></h4><p>难度中等31</p><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p><p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><code>|x|</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：<br>- 将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者<br>- 将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |<span class="hljs-string">1-2</span>|<span class="hljs-string"> + (</span>|<span class="hljs-string">1-3</span>|<span class="hljs-string"> 或者 </span>|<span class="hljs-string">5-3</span>|<span class="hljs-string">) + </span>|<span class="hljs-string">5-5</span>|<span class="hljs-string"> = 3</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<span class="hljs-symbol">nums1</span> 和 <span class="hljs-symbol">nums2</span> 相等，所以不用替换元素。绝对差值和为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3****：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |<span class="hljs-string">10-9</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">10-3</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">4-5</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">4-1</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">2-7</span>|<span class="hljs-string"> + </span>|<span class="hljs-string">7-4</span>|<span class="hljs-string"> = 20</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 105</code></li></ul></li></ul><h2 id="方法一：-排序后二分查找"><a href="#方法一：-排序后二分查找" class="headerlink" title="方法一： 排序后二分查找"></a>方法一： 排序后二分查找</h2><p>因为题目要求最小化差值和，所以做题的思路应该是，对元素间的差值进行对比，替换前后减少的值最大化；而不是单纯找到最大差值然后找数去替换。</p><p>所以注定要取nums1里的数一个一个替换后和nums2里的数作差。但是全部遍历是超时的（我代码偷懒试过全遍历。。。）；为了降低时间复杂度，先进行排序再使用二分法查找最靠近nums2的nums1的元素。二分做到最后就是最适元素。然后比较替换后的差值贡献，贡献变得越小证明替换越好，然后记下差值贡献的变化值。最后用最初差值和减去贡献变化就是答案。</p><p>注：要注意取模运算的细节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAbsoluteSumDiff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pairs[<span class="hljs-number">100001</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//开辟空间记录排序前的每组差值</span><br>        <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<span class="hljs-comment">//参考了官方答案的初始化定义</span><br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            pairs[i]=<span class="hljs-built_in">abs</span>(nums1[i]-nums2[i]);<br>            total = (total+pairs[i])%mod;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>,high = n<span class="hljs-number">-1</span>,mid;<br>            <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<span class="hljs-comment">//二分查找</span><br>                mid = (low+high)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(nums1[mid]&gt;nums2[i])&#123;<br>                    high = mid<span class="hljs-number">-1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    low = mid+<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">//耻辱代码段，不删让自己记住这部分是有的问题。</span><br>                <span class="hljs-comment">/*else if(nums1[mid]&lt;nums2[i])&#123;</span><br><span class="hljs-comment">                    low = mid +1;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                else if(nums1[mid]==nums2[i])&#123;</span><br><span class="hljs-comment">                    break;</span><br><span class="hljs-comment">                &#125;*/</span><br>                <span class="hljs-keyword">if</span>(pairs[i]-<span class="hljs-built_in">abs</span>(nums1[mid]-nums2[i])&gt;max)&#123;<span class="hljs-comment">//比较改变之后的差值，观察它减少的贡献</span><br>                    res = <span class="hljs-built_in">abs</span>(nums1[mid]-nums2[i]);<br>                    max = pairs[i]-<span class="hljs-built_in">abs</span>(nums1[mid]-nums2[i]);<span class="hljs-comment">//记录最大改变的组合构造的差值</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> (total -max + mod)%mod;<span class="hljs-comment">//这里还要加一个mod是因为运算中我对total每步都有取模，所以是会导致total直接减去max</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>抱怨：这道题一开始以为直接找最大就行。。后来想了一会觉得还是要老老实实把目标数找出来，但又不想写好点的排序算法，结果写了发现超时，只好去写二分，但是二分写得又有问题，浪费了好多好多好多好多时间。。。不知道是不是骨子里就是很懒……</p><h2 id="方法二：lower-bound查找"><a href="#方法二：lower-bound查找" class="headerlink" title="方法二：lower_bound查找"></a>方法二：lower_bound查找</h2><p>参考答案的解法，虽然它也叫二分，但显然直接使用lower_bound查找nums2元素的最接近值还是很有意思的，mark一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1&#x27;000&#x27;000&#x27;007</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAbsoluteSumDiff</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rec</span><span class="hljs-params">(nums1)</span></span>;<br>        <span class="hljs-built_in">sort</span>(rec.<span class="hljs-built_in">begin</span>(), rec.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(nums1[i] - nums2[i]);<br>            sum = (sum + diff) % mod;<br>            <span class="hljs-comment">//lower_bound查找给定区间内第一个比目标要大元素。</span><br>            <span class="hljs-type">int</span> j = <span class="hljs-built_in">lower_bound</span>(rec.<span class="hljs-built_in">begin</span>(), rec.<span class="hljs-built_in">end</span>(), nums2[i]) - rec.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-comment">//把这个begin减去是为了把返回的容器互相做差使得j代表下标。</span><br>            <span class="hljs-keyword">if</span> (j &lt; n) &#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, diff - (rec[j] - nums2[i]));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, diff - (nums2[i] - rec[j - <span class="hljs-number">1</span>]));<br>            &#125;<br>            <span class="hljs-comment">//比较找到的值和前一个值跟nums2元素的差值，拿贡献改变最大的那个。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> (sum - maxn + mod) % mod;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-13 每日一题</title>
    <link href="/2021/07/13/2021.7.13%20daily%20problem/"/>
    <url>/2021/07/13/2021.7.13%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="218-天际线问题"><a href="#218-天际线问题" class="headerlink" title="218. 天际线问题"></a><a href="https://leetcode-cn.com/problems/the-skyline-problem/">218. 天际线问题</a></h4><p>难度困难</p><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 <strong>天际线</strong> 。</p><p>每个建筑物的几何信息由数组 <code>buildings</code> 表示，其中三元组 <code>buildings[i] = [lefti, righti, heighti]</code> 表示：</p><ul><li><code>lefti</code> 是第 <code>i</code> 座建筑物左边缘的 <code>x</code> 坐标。</li><li><code>righti</code> 是第 <code>i</code> 座建筑物右边缘的 <code>x</code> 坐标。</li><li><code>heighti</code> 是第 <code>i</code> 座建筑物的高度。</li></ul><p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式 <code>[[x1,y1],[x2,y2],...]</code> ，并按 <strong>x 坐标</strong> 进行 <strong>排序</strong> 。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，<code>y</code> 坐标始终为 <code>0</code> ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p><strong>注意：</strong>输出天际线中不得有连续的相同高度的水平线。例如 <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：<code>[...[2 3], [4 5], [12 7], ...]</code></p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/merged.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：buildings = <span class="hljs-comment">[<span class="hljs-comment">[2,9,10]</span>,<span class="hljs-comment">[3,7,15]</span>,<span class="hljs-comment">[5,12,12]</span>,<span class="hljs-comment">[15,20,10]</span>,<span class="hljs-comment">[19,24,8]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[2,10]</span>,<span class="hljs-comment">[3,15]</span>,<span class="hljs-comment">[7,12]</span>,<span class="hljs-comment">[12,0]</span>,<span class="hljs-comment">[15,10]</span>,<span class="hljs-comment">[20,8]</span>,<span class="hljs-comment">[24,0]</span>]</span><br>解释：<br>图 A 显示输入的所有建筑物的位置和高度，<br>图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：buildings = <span class="hljs-string">[[0,2,3],[2,5,3]]</span><br>输出：<span class="hljs-string">[[0,3],[5,0]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= buildings.length &lt;= 104</code></li><li><code>0 &lt;= lefti &lt; righti &lt;= 231 - 1</code></li><li><code>1 &lt;= heighti &lt;= 231 - 1</code></li><li><code>buildings</code> 按 <code>lefti</code> 非递减排序</li></ul><h2 id="方法一：-模拟法"><a href="#方法一：-模拟法" class="headerlink" title="方法一： 模拟法"></a>方法一： 模拟法</h2><p>先把图中的数据处理成题目中附图B的样子，然后遍历读点写入。但是测例里面最长大楼的长度是2的31次方，准备这么长的数组会栈溢出，所以这个方法不行，但写了就姑且记下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSkyline</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; buildings) &#123;<br>        <span class="hljs-type">int</span> graph[<span class="hljs-number">100000</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> max;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;b : buildings)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b[<span class="hljs-number">0</span>];i&lt;=b[<span class="hljs-number">1</span>];i++)&#123;<br>                <span class="hljs-keyword">if</span>(b[<span class="hljs-number">2</span>]&gt;graph[i])&#123;<br>                    graph[i] = b[<span class="hljs-number">2</span>];<br>                &#125;<br>            &#125;<br>            max = b[<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(graph[<span class="hljs-number">0</span>]!=<span class="hljs-number">0</span>)&#123;<br>            temp.<span class="hljs-built_in">clear</span>();<br>            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            temp.<span class="hljs-built_in">push_back</span>(graph[<span class="hljs-number">0</span>]);<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=max;i++)&#123;<br>            <span class="hljs-keyword">if</span>(graph[i]&gt;graph[i+<span class="hljs-number">1</span>])&#123;<br>                temp.<span class="hljs-built_in">clear</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(i);<br>                temp.<span class="hljs-built_in">push_back</span>(graph[i+<span class="hljs-number">1</span>]);<br>                res.<span class="hljs-built_in">push_back</span>(temp);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(graph[i]&lt;graph[i+<span class="hljs-number">1</span>])&#123;<br>                temp.<span class="hljs-built_in">clear</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">push_back</span>(graph[i+<span class="hljs-number">1</span>]);<br>                res.<span class="hljs-built_in">push_back</span>(temp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：扫描法"><a href="#方法二：扫描法" class="headerlink" title="方法二：扫描法"></a>方法二：扫描法</h2><p>虽然自己想到了从最左开始一直往右找大楼的端点，但自己没有想到要怎么记录重合的端点的最大高度。</p><p>参考了一个巧妙的方法：</p><p>使用multiset容器构造一个记录队列，它相比set的好处是能收纳相同元素，并且集合内有序，可以通过取最右端元素获取最大值。</p><p>同时，使用pair。因为pair排序的时候先按first排，first相同再比较second的大小。</p><p>题目中的数据大楼都是正数，但是遍历的时候区分左右端点可能要加复杂的判断，也很难去处理连续的相同高度的大楼，在题解里看到了一个非常精妙的手段去处理，就是把大楼的左高度变成负数入栈。于是碰到正数时就可以判断该大楼已经走到尽，将其从集合内删除来维护当前最高的高度。</p><p>并且可以发现答案要求都在大楼边缘的位置，那么比较当前最大高度和之前记录的最大高度就可以判断这个边缘是不是属于转折点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">getSkyline</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; buildings) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        multiset&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;b : buildings)&#123;<br>            <span class="hljs-comment">//就算m的类型是pair&lt;int,int&gt;;进行元素的插入前还是要进行makepair操作</span><br>            m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(b[<span class="hljs-number">0</span>],-b[<span class="hljs-number">2</span>]));<br>            m.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(b[<span class="hljs-number">1</span>],b[<span class="hljs-number">2</span>]));<br>        &#125;<br>        <span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">h</span><span class="hljs-params">(&#123;<span class="hljs-number">0</span>&#125;)</span></span>;<span class="hljs-comment">//记录当前最高的高度</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; last = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//上一个位置的最高高度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; i : m)&#123;<br>            <span class="hljs-keyword">if</span>(i.second&lt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//巧妙的做法,因为multiset有序,所以把大楼的左侧标记成负数就可以将其左右区分</span><br>                h.<span class="hljs-built_in">insert</span>(-i.second);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                h.<span class="hljs-built_in">erase</span>(h.<span class="hljs-built_in">find</span>(i.second));<span class="hljs-comment">//find()也是multiset里面的函数</span><br>            &#125;<br>            <span class="hljs-keyword">auto</span> max = *h.<span class="hljs-built_in">rbegin</span>();<span class="hljs-comment">//rbegin()返回的是迭代器，需要用*号取int值</span><br><br>            <span class="hljs-keyword">if</span>(last[<span class="hljs-number">1</span>]!=max)&#123;<span class="hljs-comment">//如果上一个记录高度不等于当前的最大高度,证明这里是一个转折点</span><br>            <span class="hljs-comment">//依据题目图片的定义,</span><br>            <span class="hljs-comment">//这里无论是左端还是右端,高度变化的时候就应该放入当前最高点对应的横坐标</span><br>                last[<span class="hljs-number">0</span>] = i.first;<br>                last[<span class="hljs-number">1</span>] = max;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;last[<span class="hljs-number">0</span>],last[<span class="hljs-number">1</span>]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题用到了一些少用的容器，记住first和second不是函数，find和erase这种需要带上类名；迭代器取值加星号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-12 每日一题</title>
    <link href="/2021/07/12/2021.7.12%20daily%20problem/"/>
    <url>/2021/07/12/2021.7.12%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="275-H-指数-II"><a href="#275-H-指数-II" class="headerlink" title="275. H 指数 II"></a><a href="https://leetcode-cn.com/problems/h-index-ii/">275. H 指数 II</a></h4><p>难度中等140</p><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 <strong>升序排列</strong> 。编写一个方法，计算出研究者的 <em>h</em> 指数。</p><p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<strong>总共</strong>有 h 篇论文分别被引用了<strong>至少</strong> h 次。（其余的 <em>N - h</em> 篇论文每篇被引用次数<strong>不多于</strong> <em>h</em> 次。）”</p><p><strong>示例:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: citations = [0,1,3,5,6]<br>输出:<span class="hljs-number"> 3 </span><br>解释: 给定数组表示研究者总共有<span class="hljs-number"> 5 </span>篇论文，每篇论文相应的被引用了 0, 1, 3, 5,<span class="hljs-number"> 6 </span>次。<br>     由于研究者有<span class="hljs-number"> 3 </span>篇论文每篇至少被引用了<span class="hljs-number"> 3 </span>次，其余两篇论文每篇被引用不多于<span class="hljs-number"> 3 </span>次，所以她的 h 指数是 3。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>如果 <em>h</em> 有多有种可能的值 ，<em>h</em> 指数是其中最大的那个。</p><p><strong>进阶：</strong></p><ul><li>这是 <a href="https://leetcode-cn.com/problems/h-index/description/">H 指数</a> 的延伸题目，本题中的 <code>citations</code> 数组是保证有序的。</li><li>你可以优化你的算法到对数时间复杂度吗？</li></ul><h2 id="方法一：顺序法遍历"><a href="#方法一：顺序法遍历" class="headerlink" title="方法一：顺序法遍历"></a>方法一：顺序法遍历</h2><p>方法跟昨天一样，把排序省了就行。</p><p>自己的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-comment">//sort(citations.begin(),citations.end());</span><br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;citations.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(citations[i]&gt;=(citations.<span class="hljs-built_in">size</span>()-i))&#123;<span class="hljs-comment">//找出符合条件的位置</span><br>                max = citations.<span class="hljs-built_in">size</span>()-i;<span class="hljs-comment">//计算H指数</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="方法二：二分查找"><a href="#方法二：二分查找" class="headerlink" title="方法二：二分查找"></a>方法二：二分查找</h2><p>一开始没审好题，题目说了要log级时间复杂度，按理说要用二分法做的。那刚好之前也很懒用二分，练练手发现自己还是有问题，先贴代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid=<span class="hljs-number">0</span>,low=<span class="hljs-number">0</span>,top=citations.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low&lt;=top)&#123;<br>            mid = (low+top)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(citations[mid]&lt;(citations.<span class="hljs-built_in">size</span>()-mid))&#123;<span class="hljs-comment">//不符合条件的，往后找。</span><br>                low = mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                top = mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//符合条件的，往前找一个更大的H。</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> citations.<span class="hljs-built_in">size</span>() - low;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意的地方是上下界转移的时候不能直接用mid，要加减一。另外找到之后其实挺好理解的长度-低位就是答案，做的时候没绕出来，过不了特定的测例。</p><p>最后，while循环里用小于等于是用来对付长度为1的citations的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-11 每日一题</title>
    <link href="/2021/07/11/2021.7.11%20daily%20problem/"/>
    <url>/2021/07/11/2021.7.11%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a><a href="https://leetcode-cn.com/problems/h-index/">274. H 指数</a></h4><p>难度中等169</p><p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 <em>h</em> 指数。</p><p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）<strong>总共</strong>有 h 篇论文分别被引用了<strong>至少</strong> h 次。且其余的 <em>N - h</em> 篇论文每篇被引用次数 <strong>不超过</strong> <em>h</em> 次。</p><p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：citations = [3,0,6,1,5]<br>输出：3 <br>解释：给定数组表示研究者总共有<span class="hljs-number"> 5 </span>篇论文，每篇论文相应的被引用了 3, 0, 6, 1,<span class="hljs-number"> 5 </span>次。<br>     由于研究者有<span class="hljs-number"> 3 </span>篇论文每篇 至少 被引用了<span class="hljs-number"> 3 </span>次，其余两篇论文每篇被引用 不多于<span class="hljs-number"> 3 </span>次，所以她的 h 指数是 3。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong>如果 <em>h</em> 有多种可能的值，<em>h</em> 指数是其中最大的那个。</p><h2 id="方法一：排序后遍历"><a href="#方法一：排序后遍历" class="headerlink" title="方法一：排序后遍历"></a>方法一：排序后遍历</h2><p>题目要求找H指数，所以我的想法是排序后，检查当前元素的值和他的位置；如果“当前位置到结尾的长度”（记为N）小于等于当前位置的引用次数，就证明有N篇文章被引用了至少N次。而因为是从较小的数开始遍历，所以第一次符合条件的就是答案。</p><p>自己的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(citations.<span class="hljs-built_in">begin</span>(),citations.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;citations.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(citations[i]&gt;=(citations.<span class="hljs-built_in">size</span>()-i))&#123;<span class="hljs-comment">//找出符合条件的位置</span><br>                max = citations.<span class="hljs-built_in">size</span>()-i;<span class="hljs-comment">//计算H指数</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>做完发现过于简单，还在怀疑有无可能方法是错误的只是恰好测例全过了。。。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-10 每日一题</title>
    <link href="/2021/07/10/2021.7.10%20daily%20problem/"/>
    <url>/2021/07/10/2021.7.10%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<h4 id="981-基于时间的键值存储"><a href="#981-基于时间的键值存储" class="headerlink" title="981. 基于时间的键值存储"></a><a href="https://leetcode-cn.com/problems/time-based-key-value-store/">981. 基于时间的键值存储</a></h4><p>难度中等96</p><p>创建一个基于时间的键值存储类 <code>TimeMap</code>，它支持下面两个操作：</p><p>\1. <code>set(string key, string value, int timestamp)</code></p><ul><li>存储键 <code>key</code>、值 <code>value</code>，以及给定的时间戳 <code>timestamp</code>。</li></ul><p>\2. <code>get(string key, int timestamp)</code></p><ul><li>返回先前调用 <code>set(key, value, timestamp_prev)</code> 所存储的值，其中 <code>timestamp_prev &lt;= timestamp</code>。</li><li>如果有多个这样的值，则返回对应最大的 <code>timestamp_prev</code> 的那个值。</li><li>如果没有值，则返回空字符串（<code>&quot;&quot;</code>）。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">5</span>]]<br>输出：[null,null,<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>,null,<span class="hljs-string">&quot;bar2&quot;</span>,<span class="hljs-string">&quot;bar2&quot;</span>]<br>解释：  <br>TimeMap kv;   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 存储键 <span class="hljs-string">&quot;foo&quot;</span> 和值 <span class="hljs-string">&quot;bar&quot;</span> 以及时间戳 timestamp = <span class="hljs-number">1</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">1</span>);  <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar&quot;</span> 因为在时间戳 <span class="hljs-number">3</span> 和时间戳 <span class="hljs-number">2</span> 处没有对应 <span class="hljs-string">&quot;foo&quot;</span> 的值，所以唯一的值位于时间戳 <span class="hljs-number">1</span> 处（即 <span class="hljs-string">&quot;bar&quot;</span>）   <br>kv.set(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar2&quot;</span>, <span class="hljs-number">4</span>);   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>   <br>kv.get(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 输出 <span class="hljs-string">&quot;bar2&quot;</span>   <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：inputs = [<span class="hljs-string">&quot;TimeMap&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>], inputs = [[],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">5</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">10</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">15</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">20</span>],[<span class="hljs-string">&quot;love&quot;</span>,<span class="hljs-number">25</span>]]<br>输出：[null,null,null,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;high&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>,<span class="hljs-string">&quot;low&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>所有的键&#x2F;值字符串都是小写的。</li><li>所有的键&#x2F;值字符串长度都在 <code>[1, 100]</code> 范围内。</li><li>所有 <code>TimeMap.set</code> 操作中的时间戳 <code>timestamps</code> 都是严格递增的。</li><li><code>1 &lt;= timestamp &lt;= 10^7</code></li><li><code>TimeMap.set</code> 和 <code>TimeMap.get</code> 函数在每个测试用例中将（组合）调用总计 <code>120000</code> 次。</li></ol><h2 id="方法一：哈希表-查找"><a href="#方法一：哈希表-查找" class="headerlink" title="方法一：哈希表+查找"></a>方法一：哈希表+查找</h2><p>由于set 操作中的时间戳都是严格递增的，因此二元组列表中保存的时间戳也是严格递增的，这样我们可以根据 get 操作中的key 在哈希表中找到对应的二元组列表pairs，然后根据timestamp 在 pairs 中二分查找。我们需要找到最大的不超过 timestamp 的时间戳，对此，我们可以二分找到第一个超过 timestamp 的二元组下标 i，若 i&gt;0 则说明目标二元组存在，即pairs[i−1]，否则二元组不存在，返回空字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    unordered_map&lt;string, vector&lt;pair&lt;<span class="hljs-type">int</span>, string&gt;&gt;&gt; m;<span class="hljs-comment">//unordered_map建立二元组映射对</span><br>    <span class="hljs-built_in">TimeMap</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(string key, string value, <span class="hljs-type">int</span> timestamp)</span> </span>&#123;<br>        m[key].<span class="hljs-built_in">emplace_back</span>(timestamp,value);<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">get</span><span class="hljs-params">(string key, <span class="hljs-type">int</span> timestamp)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> &amp;pairs = m[key];<br>        <span class="hljs-comment">// 使用一个大于所有 value 的字符串，以确保在 pairs 中含有 timestamp 的情况下也返回大于 timestamp 的位置</span><br>        pair&lt;<span class="hljs-type">int</span>, string&gt; p = &#123;timestamp, <span class="hljs-built_in">string</span>(&#123;<span class="hljs-number">127</span>&#125;)&#125;;<span class="hljs-comment">//ASCII码不超过127，以上界来初始化</span><br>        <span class="hljs-keyword">auto</span> i = <span class="hljs-built_in">upper_bound</span>(pairs.<span class="hljs-built_in">begin</span>(), pairs.<span class="hljs-built_in">end</span>(), p);<br>        <span class="hljs-keyword">if</span> (i != pairs.<span class="hljs-built_in">begin</span>()) &#123;<br>            <span class="hljs-keyword">return</span> (i - <span class="hljs-number">1</span>)-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your TimeMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * TimeMap* obj = new TimeMap();</span><br><span class="hljs-comment"> * obj-&gt;set(key,value,timestamp);</span><br><span class="hljs-comment"> * string param_2 = obj-&gt;get(key,timestamp);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>这道题，之前没怎么用过unordered_map；算是边看答案边理解做的，以后看到类似的题目要回来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-07-09 每日一题</title>
    <link href="/2021/07/09/2021.7.9%20daily%20problem/"/>
    <url>/2021/07/09/2021.7.9%20daily%20problem/</url>
    
    <content type="html"><![CDATA[<p>不能让拖延症主宰每日时间了，争取每天做完每日一题都上来记录。</p><h4 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h4><p>数组中占比超过一半的元素称之为主要元素。给你一个 <strong>整数</strong> 数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="方法一：排序后找出连续出现次数最多的元素"><a href="#方法一：排序后找出连续出现次数最多的元素" class="headerlink" title="方法一：排序后找出连续出现次数最多的元素"></a>方法一：排序后找出连续出现次数最多的元素</h2><p>因为题目要求时间复杂度是<code>O(N)</code> 、空间复杂度为 <code>O(1)</code> ；所以自己的想法是直接调用sort函数排序之后，相邻元素比较，如果相同则在当前计数下增1，然后用max跟计数器比较，比max大则修改max的值并记下当前元素；不同的话把计数器修改回1。</p><p>自己的AC代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>, ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>]==nums[i])&#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span>(cnt&gt;max)&#123;<span class="hljs-comment">//比较</span><br>                    max = cnt;<br>                    ans = nums[i];<span class="hljs-comment">//记下当前元素</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(max &gt; nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个方法比较捞，因为其实我用sort排序的时候可能就不符合O(n)要求了，虽然leetcode上AC了。</p><h2 id="方法二：Boyer-Moore-投票算法"><a href="#方法二：Boyer-Moore-投票算法" class="headerlink" title="方法二：Boyer-Moore 投票算法"></a>方法二：Boyer-Moore 投票算法</h2><blockquote><p>Boyer-Moore 投票算法的基本思想是：在每一轮投票过程中，从数组中删除两个不同的元素，直到投票过程无法继续，此时数组为空或者数组中剩下的元素都相等。</p><p>如果数组为空，则数组中不存在主要元素；</p><p>如果数组中剩下的元素都相等，则数组中剩下的元素可能为主要元素。</p></blockquote><p>做法就是元素间比较然后修改计数器，到最后肯定是剩下出现次数最多的主要元素。</p><p>具体一点就是，当计数器是0遍历到元素时，就把这个元素当作标志，并把计数器增1。然后把该元素与下一个元素比较。</p><p>当计数器非0时，比较当前元素与下一个元素，如果相同则计数器再增1，否则计数器减1。直至计数器减到0再选择新标志。</p><p>修改后的AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate = <span class="hljs-number">-1</span>,count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>                candidate = num;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(candidate == num)&#123;<br>                    count++;<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    count--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(num == candidate)&#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count*<span class="hljs-number">2</span>&gt;nums.<span class="hljs-built_in">size</span>()? candidate : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>参考得来的方法，比较纯粹，把问题简化成两两去除检查剩下的元素。要继续训练修改问题的思维。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深圳站战报</title>
    <link href="/2021/06/09/2021_ShenZhen_Report/"/>
    <url>/2021/06/09/2021_ShenZhen_Report/</url>
    
    <content type="html"><![CDATA[<h1 id="2021年巡回赛深圳站战报"><a href="#2021年巡回赛深圳站战报" class="headerlink" title="2021年巡回赛深圳站战报"></a>2021年巡回赛深圳站战报</h1><h3 id="R1-十二兽铁兽"><a href="#R1-十二兽铁兽" class="headerlink" title="R1 十二兽铁兽"></a>R1 十二兽铁兽</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/PHRAS006.jpg"></p><p>骰子赢 OO</p><p>G1对面没手坑做完崇光IP，对面挣扎了一下投降</p><p>G2对面比较卡手，开强贪壶我丢灰，对面剑指，抽了2开天玑拿人马，人马堆完通召牛叫效果展开连锁朱光丢地外，检索神巫，对面盖下3后过。对面在我的准阶开魔封，我这边手牌是神巫阿尔法伽马，通召神巫找弁天，出了黑蔷薇龙扫发现后场是剑指和第二张魔封，最后做出天霆崇光手里抓着圣枪，赢。</p><h3 id="R2-红坑码语"><a href="#R2-红坑码语" class="headerlink" title="R2 红坑码语"></a>R2 红坑码语</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/ETCO_20200110_0070.jpg"></p><p>骰子赢 OXO</p><p>G1开壶翻6吃灰，通召神巫吃泡影，停牌。对面回合通召微编码变栗仔球，手里的微编码link码语拿挖矿，然后生成员出转码堆点阵跳离，最后做出了转码+炽热，放血抽卡盖一卡过。我的回合抽卡阶段对面再放血。主阶出神巫吃宣，开极超吃G，然后继续做，中途吃了一次幽鬼兔，捡够朱光和一个天使防手坑做刺刀龙直接3k打完。</p><p>G2通召瓢虫拿微编码丢锁鸟，补牢牢妖做飞溅炽热，盖了3后。我开闪电风暴吃敕命，通召神巫吃泡影，跑。</p><p>G3先攻极超吃了灰，接着展开，μβ吃了泡影。我想着对面丢了泡影大概率不会有第二张了吧，然后转路线拿了个大虚无，通召，压死。</p><h3 id="第三轮-十二兽闪刀（好久没试过玩龙辉巧抽不到龙辉巧了）"><a href="#第三轮-十二兽闪刀（好久没试过玩龙辉巧抽不到龙辉巧了）" class="headerlink" title="第三轮 十二兽闪刀（好久没试过玩龙辉巧抽不到龙辉巧了）"></a>第三轮 十二兽闪刀（好久没试过玩龙辉巧抽不到龙辉巧了）</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/20180311_cd90c2.jpg"></p><p>骰子输 XX</p><p>G1对面天玑鼠骑发效果丢朱光地外找神巫，然后盖卡过。我这边手牌很bad（神巫神巫，崇光DRA和仪式的准备）通召神巫吃抓锚。对面下回合增援找闪刀转一波资源。我这边抽到地外，直接投降。</p><p>G2先攻（弁天三战灰流圣枪辉巧群）喊过。然后就只能看对面玩，过了三回合之后，剩下3900，对面场上4素材天霆和水刀，手里好几张牌，我场上一个墓指；对面EP水刀检索我思考了一下还是没有指名。到我回合抽到了delta，delta解放弁天，对面解读虫，我墓指他继续解读虫。三战抽2通召神巫对面天霆扫场，捡了一个弁天。结束回合，然后对面通召零衣，投降。</p><h3 id="第四轮-调皮宝贝"><a href="#第四轮-调皮宝贝" class="headerlink" title="第四轮 调皮宝贝"></a>第四轮 调皮宝贝</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/0804DBHS015.jpg"></p><p>骰子赢 OO</p><p>G1（神巫辉巧群辉巧群，阿尔法和蠢埋）通召神巫吃灰。想了好一阵子，蠢埋堆伽马，复活做μβ堆DRA，阿尔法吃掉μβ拿崇光，神巫+阿尔法出同盟车装地外，出崇光。对面看了看手牌投了。（不知道这里是不是有更好的选项，但是当时想到的自己认为的最优解就是这个）</p><p>G2对面出水滴娃变猫吃灰，发一对一拉风娃做鸡，C1风娃C2鸡，朱光丢地外把鸡炸了，拿神巫。无奈拉岩石娃喊过了。<br>我这边神巫泽塔场地爆展，赢。</p><h3 id="第五轮-十二兽铁兽"><a href="#第五轮-十二兽铁兽" class="headerlink" title="第五轮 十二兽铁兽"></a>第五轮 十二兽铁兽</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/PHRAS006.jpg"></p><p>骰子赢 OO</p><p>G1开杯面然后一路展开，最后是DRA+2明子弹崇光，手里抓着一个一开始拿着的朱光。对面开壶，开天玑，通召，开会局打完变身天霆，全部管住之后赢。后来得知对面是在赌我只有2子弹。</p><p>G2（赛后得知对面手里是DD乌鸦，泡影，虚无空间，灰流，克拉斯）盖两个后场过了。通召神巫吃灰，过。对面通召牛，打死神巫。然后我神抽阿尔法，阿尔法解放delta对面开虚无。我不想被克拉斯一直打拉开血差，盖下了灰流。）之后就是僵持数回合，对面抽到了天玑，天玑找老鼠，我朱光丢崇光<br>对面思考了一下用乌鸦叼走了δ，克拉斯硬开做出块击银弹，没有打我的盖怪，盖后过。到我阿尔法解弁天顺利出场，拿了圣枪，通召神巫吃激流葬，神巫堆地外找了一组朱光。之后对面也没有增加新的阻抗点，下一个回合抽到了泽塔开始展开，泡影抗战没拦住就投降了。</p><h3 id="第六轮-电脑堺"><a href="#第六轮-电脑堺" class="headerlink" title="第六轮 电脑堺"></a>第六轮 电脑堺</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/PHRAS001.jpg"></p><p>骰子赢 OXX</p><p>G1神巫朱光朱光阿尔法愚埋，神巫拿弁天，堆泽塔，泽塔解放弁天，对面灰，想了一下还是交了朱光，然后做到最后就是4子弹崇光，因为朱光不够数，不然可以5个子弹。对面掏九龙，康；青龙，康；又青龙，继续康；墓地青龙发效果拿了娘娘丢娘娘，通召瑞瑞叠断碎剑，康，展示手牌灰投降。</p><p>G2没有手坑对面朱雀法王，走。</p><p>G3开仪式的准备就吃了锁鸟，停牌。对面青龙瑞瑞一套combo直接斩杀。过程中我看到对面青龙和玄武分别丢了G和PSY，打完之后问对面起手是不是G,PSY,锁鸟,青龙,瑞瑞。我手牌（愚埋DRA准备神巫电子呼救），想了一想这把其实没有操作空间，感觉是运气到头了，这次还是出不了轮。</p><h3 id="第七轮-废铁自奏"><a href="#第七轮-废铁自奏" class="headerlink" title="第七轮 废铁自奏"></a>第七轮 废铁自奏</h3><p><img src="https://www.cardrush.jp/data/cardrush/product/ETCO_20200110_0028.jpg"></p><p>骰子赢 OO</p><p>G1对面没手坑直接爆展。</p><p>G2对面废铁盗龙找垃圾车，垃圾车堆自奏嬉游鬼，发效果丢了G，对面做了LINK2妹妹盖了反击，盖了2后喊过。到我准阶吃虚无，通召神巫吃一滴，一滴送了虚无。然后极超阿尔法变栗子，阿尔法解放泽塔吃自奏反击，然后对面连锁圣枪，我手里金谦用不出去，但还是转出了μβ最后做了一个DRA加一组朱光。然后下回合朱光DRA拦住赢。复盘之后跟对面交流，要是多抽一张出丁吉尔苏就赢了。不过这个时候大家都4-0-2肯定是没得出轮了，不在意输赢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>YUGIOH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My First Blog</title>
    <link href="/2021/01/12/My-First-Blog/"/>
    <url>/2021/01/12/My-First-Blog/</url>
    
    <content type="html"><![CDATA[<p>一直说要搞BLOG，终于在2021年1月开始动工啦！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
