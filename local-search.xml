<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Sysu2023WaitFor0401LimitationGame</title>
    <link href="/2023/03/13/Sysu2023WaitFor0401LimitationGame/"/>
    <url>/2023/03/13/Sysu2023WaitFor0401LimitationGame/</url>
    
    <content type="html"><![CDATA[<h1 id="2023中大四月表等表赛战报"><a href="#2023中大四月表等表赛战报" class="headerlink" title="2023中大四月表等表赛战报"></a>2023中大四月表等表赛战报</h1><p>笑死，打完比赛8点konami跳票等表赛没等到表。</p><p>使用60多种龙链接</p><p>R1：VS 海晶少女（绅士哥），🎲✔，OO</p><p>G1吃了锁鸟只能做天球+烙印兽过，对面海龟吞了天球拉了鳞虫，跳7星冰水用烙印兽互动，然后通召海晶下级最后做到大堡礁没打死，然后轮到我一个波动没拦住被斩杀。</p><p>G2对面7星冰水登场吃G，对面G没通过用鳞虫跟冰水啼互动，然后就正常展开。</p><p>R2：VS 闪刀姬（KAS哥），🎲❌，OX</p><p>G1对面让先我中G，停牌之后对面没打死，之后轮到我曳光吃抓锚没抢，神兽吃抓锚被抢走，然后用深渊兽互动，利用扇区场差复活补怪做满赢。</p><p>G2对面先攻增援成金强贪壶，通召01盖宇宙风过，轮到我开割草堆了33，场地，曳光弹三张全在墓地，没堆到辉光龙，卡组深渊兽剩下最后一张萨隆魔龙（此时手上起手就有一张萨隆魔龙），路由龙拿了装填龙。对面没有一开始丢G，我先跳黑白龙用混沌领域回1抽到灰，之后展开的时候丢G我丢灰，顾忌后场所以先做了阿泽莉亚点了，然后做到左龙对面C1零衣C2陨石被停牌，中途亡龙放了血剩下4500。对面回合，先做了泽克处理token然后直击，我因为顾忌连刀+抓锚combo打死所以没跳手里的萨隆，被对面打了2次1500（风刀直击过）之后跳萨隆挡住地刀。对面资源量爆棚做满处理了萨隆前面水刀+后面跳楼机+4后。轮到我，开胜负的时候进死三，对面留了抓锚，通召弹丸同调士吃抓锚被抢走，用最后的资源量做了天球，盖上手里的烙印之兽，手里留着一个鳞虫等待机会交换。然后对面通召零衣跳露世，直接变阿泽莉亚处理了后场烙印兽。我自己这边的视角是自己的弹丸同调士不能被打，对面阿泽莉亚变火刀拿了交闪再拿再燃炸了天球我弹自己弹丸同调士，对面变风刀游戏结束。（一时间短路忘记风刀能直击，手里的鳞虫没办法挡，所以这里的办法就是搏对面没有连刀直接弹上阿泽莉亚连锁萨隆刨零衣。还得是多跟糖师傅学习如何玩好天球……）</p><p>R3：VS 电脑界（十月），🎲✔，OXO</p><p>G1先攻做了神兽前托红阵，对面九龙青龙无效前托，通召娘娘，老老点娘娘，我神兽忘记电脑堺先堆再特招被对面堆了青龙，然后对面青龙拿瑞瑞点青龙堆青龙拿了豸豸，我要防天霆，所以让对面瑞瑞结算，然后对面出了瑚之龙打算跟我红阵交换，然后我补跳鳞虫，红阵chain瑚龙效果把对面青龙和瑚龙都送墓了，对面draw1没办法出豸豸，投牌。</p><p>G2对面九龙瑞瑞开，丢圣枪，被看一次手牌，星尘充能抽到技能抽取，做了两个9叠王战。我先跟王战交互然后输技能抽取。</p><p>G3先攻做了白枪渊前托，然后对面熔岩魔神吃了前托渊，白枪康九龙，赢。</p><p>R4：VS 纯爱妖精（萝卜），🎲✔，XO</p><p>G1先攻混沌领域中锁鸟交墓指，做黑白龙单卡展开做完前托考虑了一下还是做了混沌魔龙，这里没打仔细混沌魔龙守表出，没翻到能用的只拿了个鳞虫过，手里有灰和兔。对面上来先开裂缝，然后开金谦壶交灰，拍小黑交前托，拍朋友拿玩波摇出第二只小黑变玩波，先打了混沌魔龙拿吃饭然后狂打前托最后还杀了混沌魔龙，最后的检索拿了场地，终场是7素材大黑+抽1。轮到我，先做阿泽莉亚除去裂缝，然后凑够4个怪，对面似乎忌惮冥神没有弹，说是不知道曳光开完效果有暗自肃不能出冥神，然后没能骗到对面交第一次效果，出刺刀被弹了，前托管不住5素材大黑，输。</p><p>G2先攻不知道是吃G还是锁鸟，还是卡手来着？不记得了好像是停牌了，轮到对面好像我也管住了然后对面只做了肥猫抽2，那个时候死三了。轮到我爆展赢了，平局齐齐出轮。</p><p>TOP4：VS 闪灵铁兽（遗老），🎲✔，XOO</p><p>G1吃G拜拜。</p><p>G2先攻亡龙增殖G萨隆魔封红阵，无奈盖2过。对面通召河狸展开中G，他没斩杀只做了招财猫+双龙。轮到我展开的时候抽了墓指，但是那个时候对面丢G有魔封开不了，然后通召曳光炸魔封展开，尽量快做出前托神兽进BP打死，对面没抽到深渊兽。</p><p>G3对面起手应该是：红指，纳贝尔，萝卜，剑指，灰流，盖下2后+纳贝尔到我。然后对面开红指，我手牌是：双始龙，星蛇，萨隆，旋转，G，灰；飞了双始龙灰了旋转停牌。对面通召萝卜我丢G对面没剑指，然后link龙炮C1龙炮C2纳贝尔我灰被指，然后就是拉2河狸，做徒花拉姬特，那个时候我抽到了圣枪，C1圣枪C2玛格巨龙。对面没得打死，终端是淘气+闪灵红+萝卜。手卡资源量爆棚正常展开拿下对局。</p><p>决赛：VS 四加六世坏，🎲❌，OXX</p><p>G1对面空过，到我没做大吃了锁鸟做了天球，对面继续卡手，然后我抽到了赫界对面灰，激活手里星蛇对面投。</p><p>G2手里圣枪锁鸟，对面直接飞独角兽，独角兽拿自在天，我觉得这里开了锁鸟牌效也低而且还要被看额外，本着不想过独角兽+狼的组合尝试赌对面做不做香格里拉。然后自在天拿狼拿男人，飞男人，对面这里考虑防陨石直接叫男人效果，我连锁圣枪被对面狗狗连锁除外墓地的自在天拿回停泊地。三体直接出阿莱斯哈特被一卡通关。</p><p>G3对面SP丢G，我连锁开旋转。在考虑出天球还是做红绿阵的时候我因为忌惮俱舍，选择做红绿。用赫界拿玛格，上级召唤萨隆，跳起赫界做红绿阵。轮到对面开胜负我剩下红阵。然后通召四世坏男人拿新星做狗拿场地拿四世坏男人，手里直接跳维萨斯和四世坏男人，这下我手里玛格巨龙+红阵也拦不住了，刨了墓地男人跳出来，红阵想炸的时候吃了幽鬼兔。对面还自然上手了一张新星，做了承影+鲜花，我找遍卡组都没找到能用的最后拿了混源龙。topdeck抽魔封，GG。</p>]]></content>
    
    
    
    <tags>
      
      <tag>YuGiOh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230311</title>
    <link href="/2023/03/11/dailyProblem230311/"/>
    <url>/2023/03/11/dailyProblem230311/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-17-05-字母与数字"><a href="#面试题-17-05-字母与数字" class="headerlink" title="面试题 17.05.  字母与数字"></a><a href="https://leetcode.cn/problems/find-longest-subarray-lcci/">面试题 17.05.  字母与数字</a></h4><p>难度中等</p><p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p><p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p><p><strong>示例 1:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;H&quot;</span>,<span class="hljs-string">&quot;I&quot;</span>,<span class="hljs-string">&quot;J&quot;</span>,<span class="hljs-string">&quot;K&quot;</span>,<span class="hljs-string">&quot;L&quot;</span>,<span class="hljs-string">&quot;M&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;G&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less">输入: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>]</span><br><br>输出: <span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>array.length &lt;= 100000</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>能想到是前缀和+哈希转换，但是只想到了0，1计数，没想到-1，1计数。</p><p>这样计算前缀和的话只需要找到对应有相同count的对应下标作差找最大长度即可。抄一下答案</p><p>一个子数组包含的字母和数字的个数相同，等价于该子数组包含的字母和数字的个数之差为 0。因此可以将原数组做转换，每个字母对应 1，每个数字对应 −1，则转换后的数组中，每个子数组的元素和为该子数组对应的原始子数组的字母和数字的个数之差，如果转换后数组中的一个子数组的元素和为 0，则该子数组对应的原始子数组包含的字母和数字的个数相同。问题等价于在转换后的数组中寻找元素和为 0 的最长子数组。</p><p>为了在转换后的数组中寻找元素和为 0的子数组，可以计算转换后的数组的前缀和，如果两个下标对应的前缀和相等，则这两个下标之间的子数组的元素和为 0。</p><p>如果同一个前缀和出现多次，则该前缀和对应的最长子数组的长度为该前缀和的第一次出现的下标与最后一次出现的下标之间的子数组，因此为了在转换后的数组中寻找元素和为 0 的最长子数组，需要记录每个前缀和第一次出现的下标。</p><p>使用哈希表记录每个前缀和第一次出现的下标。由于空前缀的前缀和是 0 且对应下标 −1，因此首先将前缀和 0 与下标 −1 存入哈希表。</p><p>从左到右遍历数组，遍历过程中维护元素和为 0 的最长子数组的长度 maxLength 与开始下标  startIndex，初始时 maxLength&#x3D;0，startIndex&#x3D;−1。当遍历到下标 i 时，如果前缀和是 sum，则执行如下操作。</p><p>如果哈希表中已经存在前缀和 sum，则从哈希表中得到前缀和 sum 第一次出现的下标 firstIndex，以下标 i 结尾的元素和为 0 的最长子数组的长度是 i−firstIndex，该最长子数组的下标范围是 [firstIndex+1,i]。如果 i−firstIndex&gt;maxLength，则将 maxLength 更新为 i−firstIndex，将 startIndex 更新为 firstIndex+1；如果 i−firstIndex≤maxLength，则不更新 maxLength 与 startIndex。</p><p>如果哈希表中不存在前缀和 sum，则下标 i 为前缀和 sum 第一次出现的下标，将前缀和 sum 与下标 i 存入哈希表。</p><p>遍历结束之后，根据 maxLength 与 startIndex 的值返回结果。</p><p>如果 maxLength&gt;0，则原数组中存在字母和数字的个数相同的子数组，根据 maxLength 与 startIndex 得到原数组中包含的字母和数字的个数相同的最长子数组，返回该最长子数组。</p><p>如果 maxLength&#x3D;0，则原数组中不存在字母和数字的个数相同的子数组，返回空数组。</p><p>从左到右遍历数组的过程中，只有当遇到的子数组长度大于已有的最大长度时才会更新最大子数组的长度与开始下标，因此每次更新最大子数组的长度与开始下标之后，不存在长度等于已有的最大长度且开始下标更小的子数组。如果有多个最长子数组，则 startIndex 为这些最长子数组中的最小的左端点下标值。</p><p>实现方面，不需要创建并计算转换后的数组，只需要将原数组中的字母和数字分别对应 1 和 −1，在遍历过程中计算前缀和即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Leetcode, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230302</title>
    <link href="/2023/03/02/dailyProblem230302/"/>
    <url>/2023/03/02/dailyProblem230302/</url>
    
    <content type="html"><![CDATA[<h4 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode.cn/problems/bianry-number-to-string-lcci/">面试题 05.02. 二进制数转字符串</a></h4><p>难度中等</p><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p><p><strong>示例1:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.625</span><br>输出：<span class="hljs-string">&quot;0.101&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：<span class="hljs-number">0.1</span><br>输出：<span class="hljs-string">&quot;ERROR&quot;</span><br>提示：<span class="hljs-number">0.1</span>无法被二进制准确表示<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>32位包括输出中的 <code>&quot;0.&quot;</code> 这两位。</li><li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不难，按照题目的意思直接去按位操作就好。</p><p>一开始没想到的地方是如何判断不能被二进制准确表示，后来再看一次题目想到：只要32位之内都没把它转换成功就可以输出ERROR了。</p><p>要做的操作就是：</p><p>1，每次把num乘以2，然后取整数，再用num减去这个整数部分 &#x2F;&#x2F;是十进制小数转二进制的操作</p><p>2，如果num减至0或者字符串长度超32，就停止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">printBin</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>        string ans=<span class="hljs-string">&quot;0.&quot;</span>;<br>        <span class="hljs-keyword">while</span>(ans.<span class="hljs-built_in">length</span>()&lt;=<span class="hljs-number">32</span>&amp;&amp;num!=<span class="hljs-number">0</span>)&#123;<br>            num *=<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> bit = num;<span class="hljs-comment">//只取整数部分，按照整数部分的0/1情况添0/1</span><br>            num -= bit;<br>            ans+=(<span class="hljs-string">&#x27;0&#x27;</span>+bit);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(num!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ERROR&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230227</title>
    <link href="/2023/02/27/dailyProblem230227/"/>
    <url>/2023/02/27/dailyProblem230227/</url>
    
    <content type="html"><![CDATA[<h4 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a><a href="https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag/">1144. 递减元素使数组呈锯齿状</a></h4><p>难度中等</p><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3]<br>输出：2<br>解释：我们可以把<span class="hljs-number"> 2 </span>递减到 0，或把<span class="hljs-number"> 3 </span>递减到 1。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[9,6,1,6,2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可能还是对动态规划不熟？一开始在想要怎么安排规划，后来没想到状态方程只好作罢。</p><p>再次读题目，要求是奇数位都比偶数位大或者偶数位都比奇数位大，而可以进行的操作只能是减操作。</p><p>令操作数最少肯定是只改奇数位或者只改偶数位，既然如此，那就分奇偶两次分别遍历计数，然后选出最小的那个数。</p><p>途中修改了代码逻辑很多次，还是不够专注或者不够熟练，尝试每天都花一个小时的专注时间优先解决问题再做其他事情。</p><p>（从数据上来说似乎不是好解法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movesToMakeZigzag</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans1=<span class="hljs-number">0</span>,ans2=<span class="hljs-number">0</span>,n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//修改奇数位</span><br>            <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//防越界</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>                        ans1+=(nums[i]-nums[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>]||nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>                    ans1+=(nums[i]-<span class="hljs-built_in">min</span>(nums[i<span class="hljs-number">-1</span>],nums[i+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;=nums[<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//第一位的特殊判断</span><br>            ans2+=(nums[<span class="hljs-number">0</span>]-nums[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<span class="hljs-comment">//修改偶数位</span><br>            <span class="hljs-keyword">if</span>(i==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//防越界</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>                        ans2+=(nums[i]-nums[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;=nums[i<span class="hljs-number">-1</span>]||nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>                    ans2+=(nums[i]-<span class="hljs-built_in">min</span>(nums[i<span class="hljs-number">-1</span>],nums[i+<span class="hljs-number">1</span>])+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;ans2;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ans1,ans2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230226</title>
    <link href="/2023/02/26/dailyProblem230226/"/>
    <url>/2023/02/26/dailyProblem230226/</url>
    
    <content type="html"><![CDATA[<h4 id="1255-得分最高的单词集合"><a href="#1255-得分最高的单词集合" class="headerlink" title="1255. 得分最高的单词集合"></a><a href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/">1255. 得分最高的单词集合</a></h4><p>难度困难</p><p>你将会得到一份单词表 <code>words</code>，一个字母表 <code>letters</code> （可能会有重复字母），以及每个字母对应的得分情况表 <code>score</code>。</p><p>请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 <code>letters</code> 里的字母拼写出的 <strong>任意</strong> 属于 <code>words</code> 单词子集中，分数最高的单词集合的得分。</p><p>单词拼写游戏的规则概述如下：</p><ul><li>玩家需要用字母表 <code>letters</code> 里的字母来拼写单词表 <code>words</code> 中的单词。</li><li>可以只使用字母表 <code>letters</code> 中的部分字母，但是每个字母最多被使用一次。</li><li>单词表 <code>words</code> 中每个单词只能计分（使用）一次。</li><li>根据字母得分情况表<code>score</code>，字母 <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, <code>&#39;c&#39;</code>, … , <code>&#39;z&#39;</code> 对应的得分分别为 <code>score[0]</code>, <code>score[1]</code>, …, <code>score[25]</code>。</li><li>本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;dog&quot;</span>,<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;dad&quot;</span>,<span class="hljs-string">&quot;good&quot;</span>], letters = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]<br>输出：23<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">c</span>=9, <span class="hljs-attribute">d</span>=5, <span class="hljs-attribute">g</span>=3, <span class="hljs-attribute">o</span>=2<br>使用给定的字母表 letters，我们可以拼写单词 <span class="hljs-string">&quot;dad&quot;</span> (5+1+5)和 <span class="hljs-string">&quot;good&quot;</span> (3+2+2+5)，得分为 23 。<br>而单词 <span class="hljs-string">&quot;dad&quot;</span> 和 <span class="hljs-string">&quot;dog&quot;</span> 只能得到 21 分。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：words = [<span class="hljs-string">&quot;xxxz&quot;</span>,<span class="hljs-string">&quot;ax&quot;</span>,<span class="hljs-string">&quot;bx&quot;</span>,<span class="hljs-string">&quot;cx&quot;</span>], letters = [<span class="hljs-string">&quot;z&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]<br>输出：27<br>解释：<br>字母得分为  <span class="hljs-attribute">a</span>=4, <span class="hljs-attribute">b</span>=4, <span class="hljs-attribute">c</span>=4, <span class="hljs-attribute">x</span>=5, <span class="hljs-attribute">z</span>=10<br>使用给定的字母表 letters，我们可以组成单词 <span class="hljs-string">&quot;ax&quot;</span> (4+5)， <span class="hljs-string">&quot;bx&quot;</span> (4+5) 和 <span class="hljs-string">&quot;cx&quot;</span> (4+5) ，总得分为 27 。<br>单词 <span class="hljs-string">&quot;xxxz&quot;</span> 的得分仅为 25 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;leetcode&quot;</span>], letters = [<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-string">&quot;t&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>], score = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br>解释：<br>字母 <span class="hljs-string">&quot;e&quot;</span> 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 14</code></li><li><code>1 &lt;= words[i].length &lt;= 15</code></li><li><code>1 &lt;= letters.length &lt;= 100</code></li><li><code>letters[i].length == 1</code></li><li><code>score.length == 26</code></li><li><code>0 &lt;= score[i] &lt;= 10</code></li><li><code>words[i]</code> 和 <code>letters[i]</code> 只包含小写的英文字母。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>自己的想法是给每个单词赋分，然后遍历所有可能找出最高得分，但我觉得这个太笨，而且遍历的时候还要对letters数组数数，不是合理的解法，去看答案了。</p><p>解题思路：<br>1，提供的字母集合，每个字母只能用一次<br>2，提供的单词集合，每个单词也只能用一次<br>3，单词集合的大小，1 &lt;&#x3D; words[i].length &lt;&#x3D; 15<br>4，枚举 words 子集总共 2^15 种情况<br>5，对每一种情况统计使用了哪些字母<br>        如果字母超出范围了，就不符合要求，否则按照字母表计算得分<br>        记录最大得分<br>位压缩：<br>1，对于单词集合中每一个词，都可以选择，用&#x2F;不用</p><p>​所以就可以用位 0&#x2F;1 来表示</p><p>2，单词集合中每个单词都表示出来，总和就是 2的N次方种</p><p>​可以用 1 &lt;&lt; N 来表示</p><p>3，当遍历到其中一个组合时，其数字的二进制位表示的就是各个单词的使用状态</p><p>​比如 5，二进制 101，代表第 0 个和第 2 个单词使用，第 1 个单词不使用</p><p>4，检查时，对于第 i 个单词，使用 1 &lt;&lt; i，得到二进制除了第 i 位（顺序是从右至左）其余全 0 的数字</p><p>​比如第 2 个单词，1 &lt;&lt; 2 之后得到 4（二进制 100）</p><p>5，再与状态位进行&amp;操作，得到是否使用<br>    4（二进制100）与刚才的 5（二进制101）&amp;操作，得到 true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 将第（bit）种组合情况，所使用的单词中的字母数量统计出来</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">group</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, <span class="hljs-type">int</span> bit)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; words.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(bit &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : words[i])<br>        &#123;<br>            g[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> g;<br>&#125;<br><br><span class="hljs-comment">// 根据规则计算得分</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calcScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; group, vector&lt;<span class="hljs-type">int</span>&gt;&amp; lettercnt, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (lettercnt[j] &lt; group[j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        s += group[j] * score[j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScoreWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; words, vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, vector&lt;<span class="hljs-type">int</span>&gt;&amp; score)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 统计给出的字母的数量</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lettercnt</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : letters)<br>    &#123;<br>        lettercnt[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; words.<span class="hljs-built_in">size</span>()); i++)<br>    &#123;<br>        <span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">group</span>(words, i);<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">calcScore</span>(g, lettercnt, score));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FlowersForAlgernon</title>
    <link href="/2023/02/24/FlowersForAlgernon/"/>
    <url>/2023/02/24/FlowersForAlgernon/</url>
    
    <content type="html"><![CDATA[<p>献给阿尔吉侬的花束》</p><p>本周由于心情的和兴趣缺乏的缘故，无意中了解到了这本书，决定阅读。随手写写</p><p>跟一般书的标题不一样，虽然用阿尔吉侬命名，但阿尔吉侬在书中是一只白老鼠。</p><p>本作的主角是查理·高登，以为天生低智的男人。</p><p>他有着善良且努力学习的特质，因为他的与众不同才会被选上当人智提升计划的实验对象。</p><p>他接受实验之后逐渐变得比普通的聪明人更加聪明，但快速的智力成长和与之不匹配的心智让他对原来的世界产生了不同的看法。他之前渴望被社会接纳渴望变聪明，但社会反馈给他的更多是欺辱和霸凌，而自己的母亲也无法接受自己的儿子是弱智的。</p><p>查理看到了这一切之后，觉得这一切都是不可接受的，反而对弱势群体产生了更强的怜悯。</p><p>而关于书中描写查理的情感和爱情，我个人认为这部分是勾勒出，他作为一个正常人，完整的生活必不可缺的元素，他渴望被爱，同时也想学会去爱。</p><p>书中也表达了一个观点——无论你的智慧多么高超深邃，但如果缺少爱，那将毫无意义。</p><p>这个观点可以从查理变聪明之后会变自大，目中无人看出，也可以是实验团队将查理看成是实验物品这个行为去提炼。</p><p>查理在觉醒了智慧之后，明确了他是一个人，是一个个体，在拥有智慧的时候是，在进行手术前也是，所以他对整个实验会产生控诉，认为研究人员没有把他当作人，只是用来攫取名利的科学证据。但是在逐渐对世界产生认识的过程中他也开始理解自己存在的意义，在知道自己在不久的将来会退化之后马上着手写分析，希望能造福智障群体。</p><p>在查理实验的全过程中，阿尔吉侬的存在是很重要的，他在显现智力的一开始非常抗拒与阿尔吉侬比赛，直至后来战胜这只小白鼠，我个人认为是自尊的一种觉醒。他也在体验世界的过程中发现这是他真正的好友，因为这只小白鼠跟他一样，都是实验对象，都经历了智力的觉醒和衰退。他在还清醒的时候一直会给阿尔吉侬的坟墓上放花，也在小说的最后，希望读到他写的报告的人也可以给阿尔吉侬献花。我个人认为这体现了对需要帮助群体的爱，以及查理在阿尔吉侬身上看到了自己，他不希望自己被大家遗忘，所以题目写《献给阿尔吉侬的花束》其实是双关的，同样也是，献给查理高登的花。</p><blockquote><p>任何有常识的人都会记得迷乱的眼睛可以区分为两类，而且是由两种原因造成的；不是自光明进入黑暗，就是自黑暗进入光明，这些心灵之眼与肉体之眼完全真实；记得这些事情的人，在见到眼神困惑而又微弱的人时，并不会因此而取笑这个人。首先，他会问这个人的灵魂是否自更光明的生活进入黑暗的生活，因为还不习惯黑暗而无法看见，或是刚自黑暗的生活进入光明的生活，由于太亮而目眩。因此，他会以所处的条件与生存环境判断别人是否快乐，然后，以此同情别人。或是，如果他对于一个从黑暗进入光明的灵魂产生取笑之心，那他就有更多的理由去取笑自光明返回黑暗洞穴的人。</p></blockquote><p>书中开头引用的这段柏拉图的话，其实是查理的人生缩影。</p><p>他从无到有再到无，在无知的时候他没有执念，但是在从有到无的过程中他非常痛苦，他不想失去智慧和阅读写作的能力。换做我们自己也是一样的，在失去重视之物的时候也会想拼命挽留。实验的持续时间就像是命运，生命中有太多的东西不能由我们自己决定去留。凡人终究是会有执念，查理在几个月的实验经理，像是度过了相对完整的一生，希望我能在他的生活沉淀出更利好我成长的养分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230224</title>
    <link href="/2023/02/24/dailyProblem230224/"/>
    <url>/2023/02/24/dailyProblem230224/</url>
    
    <content type="html"><![CDATA[<h4 id="2357-使数组中所有元素都等于零"><a href="#2357-使数组中所有元素都等于零" class="headerlink" title="2357. 使数组中所有元素都等于零"></a><a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">2357. 使数组中所有元素都等于零</a></h4><p>难度简单</p><p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p><ul><li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 <strong>最小</strong> 的 <strong>非零</strong> 元素。</li><li><code>nums</code> 中的每个正整数都减去 <code>x</code>。</li></ul><p>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,5,0,3,5]</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>第一步操作：选出 x = <span class="hljs-number">1</span> ，之后 nums = <span class="hljs-string">[0,4,0,2,4]</span> 。<br>第二步操作：选出 x = <span class="hljs-number">2</span> ，之后 nums = <span class="hljs-string">[0,2,0,0,2]</span> 。<br>第三步操作：选出 x = <span class="hljs-number">2</span> ，之后 nums = <span class="hljs-string">[0,0,0,0,0]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-number">0</span><br>解释：nums 中的每个元素都已经是 <span class="hljs-number">0</span> ，所以不需要执行任何操作。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单题，一种方法是直接按照题意进行一次遍历，因为减操作是累积的，所以用一个minus变量记录当前已经减去多少，就不需要逐个位置去修改了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minus = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            nums[i] += minus;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                minus -= nums[i];<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种方法，从数学的角度出发，这个答案其实是求原数组有多少个不同的正整数。</p><p>证明：</p><p>假如不是的话，说明在某一次操作能将开始就不同的两个数同时抹零，但我们又知道每次减操作是所有数一同进行的，故两个开始就不同的数他们之间的差值在整个过程中都是固定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                hash.<span class="hljs-built_in">insert</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hash.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230223</title>
    <link href="/2023/02/23/dailyProblem230223/"/>
    <url>/2023/02/23/dailyProblem230223/</url>
    
    <content type="html"><![CDATA[<h4 id="1238-循环码排列"><a href="#1238-循环码排列" class="headerlink" title="1238. 循环码排列"></a><a href="https://leetcode.cn/problems/circular-permutation-in-binary-representation/">1238. 循环码排列</a></h4><p>难度中等</p><p>给你两个整数 <code>n</code> 和 <code>start</code>。你的任务是返回任意 <code>(0,1,2,,...,2^n-1)</code> 的排列 <code>p</code>，并且满足：</p><ul><li><code>p[0] = start</code></li><li><code>p[i]</code> 和 <code>p[i+1]</code> 的二进制表示形式只有一位不同</li><li><code>p[0]</code> 和 <code>p[2^n -1]</code> 的二进制表示形式也只有一位不同</li></ul><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：n = <span class="hljs-number">2</span>, start = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">3,2,0,1</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">11,10,00,01</span>)<br>     所有的相邻元素都有一位是不同的，另一个有效的排列是 [<span class="hljs-number">3,1,0,2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输出：n = <span class="hljs-number">3</span>, start = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">2,6,7,5</span>,<span class="hljs-number">4,0,1,3</span>]<br>解释：这个排列的二进制表示是 (<span class="hljs-number">010,110,111</span>,<span class="hljs-number">101,100,000</span>,<span class="hljs-number">001,011</span>)<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li><li><code>0 &lt;= start &lt; 2^n</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本质就是格雷编码。二进制编码转换格雷编码的公式为：i 异或 （i&gt;&gt;1) 。i为当前数组下标。</p><p>不过本题跟格雷编码的区别在于，格雷的初始要求是0，而题目是给定的start。</p><p>所以，要在之前求出格雷编码的情况下，与start进行一次异或。（每一个格雷码跟start异或都不会改变只有一位相差的性质，而一开始的格雷码是0，右移一位也是0，那么与start异或就是start本身了。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">circularPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            ret[i] = (i &gt;&gt; <span class="hljs-number">1</span>) ^ i ^ start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTCG-YUGIOH-REPORT</title>
    <link href="/2023/02/20/CTCG-YUGIOH-REPORT/"/>
    <url>/2023/02/20/CTCG-YUGIOH-REPORT/</url>
    
    <content type="html"><![CDATA[<h1 id="CTCG东莞站-深渊龙link-4-0-3-战报"><a href="#CTCG东莞站-深渊龙link-4-0-3-战报" class="headerlink" title="CTCG东莞站 深渊龙link 4-0-3 战报"></a>CTCG东莞站 深渊龙link 4-0-3 战报</h1><p>R1 VS珠泪哀歌族，🎲✔，OXX</p><p>G1能动，顺利做满对面投降。</p><p>G2起手只有鳞虫和萨隆魔龙两张手坑，对面一上来就是天魔世界跳芬里尔狼+塞壬丢古尖兵，古尖兵堆古卫兵。萨隆魔龙点梅洛对面飞红人鱼躲开继续展开，鳞虫点小美人鱼成功干扰但是被狼除外，终场对面有时潜+狼+哀唱。到我展开吃G对面墓地还有影依，投了。</p><p>G3先攻因为有龙谷先用黑白龙做了天球，扇区拉曳光中G，想着手里还有玛格，前场有天球就直接过了。然后对面拍天魔世界，天球弹完拉鸟龙兽。对面直接手拍芬里尔狼检索红人鱼，魔神王拿融合，通召宿神像跟手里魔神王和古尖兵融合，排连锁资源量直接打穿，无奈输。</p><p>R2 VS闪灵深渊兽，🎲✔，OO</p><p>G1先攻顺利做完，对面看完第六抽投降。</p><p>G2对面卡手盖烙印之兽过了，然后我一手展开牌，对面两个深渊兽交互质量不高，顺利拿下。</p><p>R3 VS神碑，🎲❌，OO</p><p>G1对面开穗先找泉，摇人出穆宁，微睡点穆宁，泉抽3被我用灰打断，盖2过。在我的准备阶段开了群雄割据+千查万别。我手牌有辉光龙混沌领域和赫界龙，决定直接找混源龙炸贴纸，之后成功展开做完白枪前托管住然后胜利。</p><p>G2对面做完穆宁+泉没盖卡，我手牌比较好，交互完之后都做了前托白枪，但是对面下回合有天岩户，还是顺利转起，还有set卡，然后我只能单前托beat，其中有一个回合对面用速攻喊完人因为紧张没用神碑之泉效果抽3，然后两回合没抽到神碑魔法被前托打死。</p><p>R4 VS俱舍怒威，🎲❌，XOX</p><p>G1起手2速攻旋转2赫界龙1装填龙，对面做满，有天魔世界+香格里拉+阿莱斯哈特+芬里尔狼，无得过直接投</p><p>G2对面丢G我丢灰，然后始枪龙吃了灰，手里拿着萨隆魔龙，盖魔毒+烙印之兽停牌，然后先开金谦out6吃灰，接着通召莱斯哈特先进BP打死始枪龙，然后先叫效果再开停泊地，我跳萨隆魔龙出场然后开魔毒炸了停泊地和手里的结界波。T3topdeck抽辉白龙，出场对面投降。</p><p>G3虽然起手2张叠光延迟，但是对面满中满：有天魔世界+香格里拉+阿莱斯哈特+芬里尔狼+电脑兽+停泊地+明牌六根清净，out了我前托还盖了2未知后场。抽阶要处理香格里拉只能双交叠光延迟弹阿莱斯哈特和香格里拉。赫界龙吃墓指，也都还行，用黑白龙和旋转运转用扇区拉场差突破，但没想到扇区竟然吃了宇宙旋风。。直接无晒资源投牌。。。</p><p>R5 VS珠泪哀歌，🎲❌，XOX</p><p>G1对面堆墓质量很高，我只丢了锁鸟，但墓地神官神像齐，还出了小米，深渊兽被露莎卡管住，突破失败投牌。</p><p>G2混沌轴+赫界龙展开，对面在我出了神兽之后再叫小美人鱼，被管住，然后跳红人鱼质量不高，我做完对面投牌。</p><p>G3无手坑对面做完：龙神王+露莎卡+深渊潜伏+哀唱+一手，混沌领域被龙神王管住，手里有深渊兽和复烙印，墓地有尖兵堆下去的鳞虫，因为被封墓效所以不能用路由龙找弹丸边，尝试用6+4出混沌双翼解场。于是玛格巨龙想出场被露莎卡管住，复烙印想着多拉鳞虫处理掉龙神王，结果就是因为忘记了封墓效导致没用好复烙印的复活（应该复活玛格巨龙逼哀唱，要么多一个续航要么可以成功解决哀唱），只有混沌双翼一个除去，点哀唱被哀唱无效，BP打死深渊潜伏M2出阿泽莉亚拆龙神王，然后过，结果对面神抽梅洛人鱼，配合哀唱融出卡雷多哈特直接摁死我，两个topdeck质量都低，无法返场，GAMELOST。</p><p>R6 轮空 O</p><p>R7 VS珠泪哀歌，🎲❌，OXO</p><p>对面估计没心机玩了。</p><p>G1用深渊兽交互一下对面只做露莎卡，后来被我做出前托就投了</p><p>G2对面塞壬丢古尖开堆，我丢了G他只做了露莎卡，但他手里有红人鱼和反击，我读错牌以为是哀唱没交宇宙旋风，被对面管死。</p><p>G3我做到一半对面就投降了。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>骰子运真的不行，而且后手基本抽不到有效交互牌，感觉就是差一点神助之力。</p><p>但是以往去打赛都没犯错，跟珠泪打细节还是太多，结果就是漏掉了关键的一着没复活玛格巨龙，否则说不定还不会止步第一天。不过就，我自认也认真去打这场比赛了，下次再努力吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>yugioh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230220</title>
    <link href="/2023/02/20/dailyProblem230220/"/>
    <url>/2023/02/20/dailyProblem230220/</url>
    
    <content type="html"><![CDATA[<h4 id="2347-最好的扑克手牌"><a href="#2347-最好的扑克手牌" class="headerlink" title="2347. 最好的扑克手牌"></a><a href="https://leetcode.cn/problems/best-poker-hand/">2347. 最好的扑克手牌</a></h4><p>难度简单</p><p>给你一个整数数组 <code>ranks</code> 和一个字符数组 <code>suit</code> 。你有 <code>5</code> 张扑克牌，第 <code>i</code> 张牌大小为 <code>ranks[i]</code> ，花色为 <code>suits[i]</code> 。</p><p>下述是从好到坏你可能持有的 <strong>手牌类型</strong> ：</p><ol><li><code>&quot;Flush&quot;</code>：同花，五张相同花色的扑克牌。</li><li><code>&quot;Three of a Kind&quot;</code>：三条，有 3 张大小相同的扑克牌。</li><li><code>&quot;Pair&quot;</code>：对子，两张大小一样的扑克牌。</li><li><code>&quot;High Card&quot;</code>：高牌，五张大小互不相同的扑克牌。</li></ol><p>请你返回一个字符串，表示给定的 5 张牌中，你能组成的 <strong>最好手牌类型</strong> 。</p><p><strong>注意：</strong>返回的字符串 <strong>大小写</strong> 需与题目描述相同。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">13</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], suits = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>]<br>输出：<span class="hljs-string">&quot;Flush&quot;</span><br>解释：<span class="hljs-number">5</span> 张扑克牌的花色相同，所以返回 <span class="hljs-string">&quot;Flush&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>], suits = [<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>输出：<span class="hljs-string">&quot;Three of a Kind&quot;</span><br>解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 。<br>注意我们也可以得到 <span class="hljs-string">&quot;Pair&quot;</span> ，但是 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 是更好的手牌类型。<br>有其他的 <span class="hljs-number">3</span> 张牌也可以组成 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 手牌类型。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：ranks = [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<span class="hljs-number">9</span>], suits = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br>输出：<span class="hljs-string">&quot;Pair&quot;</span><br>解释：第一和第二张牌大小相同，所以得到 <span class="hljs-string">&quot;Pair&quot;</span> 。<br>我们无法得到 <span class="hljs-string">&quot;Flush&quot;</span> 或者 <span class="hljs-string">&quot;Three of a Kind&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>ranks.length == suits.length == 5</code></li><li><code>1 &lt;= ranks[i] &lt;= 13</code></li><li><code>&#39;a&#39; &lt;= suits[i] &lt;= &#39;d&#39;</code></li><li>任意两张扑克牌不会同时有相同的大小和花色。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>按照优先级顺序判断就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">bestHand</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ranks, vector&lt;<span class="hljs-type">char</span>&gt;&amp; suits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> kinds[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> nums[<span class="hljs-number">14</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            nums[ranks[i]]++;<br>            kinds[suits[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(kinds[i]==<span class="hljs-number">5</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Flush&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">14</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=<span class="hljs-number">3</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Three of a Kind&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">14</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pair&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;High Card&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++, LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230217</title>
    <link href="/2023/02/17/dailyProblem230217/"/>
    <url>/2023/02/17/dailyProblem230217/</url>
    
    <content type="html"><![CDATA[<h4 id="1139-最大的以-1-为边界的正方形"><a href="#1139-最大的以-1-为边界的正方形" class="headerlink" title="1139. 最大的以 1 为边界的正方形"></a><a href="https://leetcode.cn/problems/largest-1-bordered-square/">1139. 最大的以 1 为边界的正方形</a></h4><p>难度中等</p><p>给你一个由若干 <code>0</code> 和 <code>1</code> 组成的二维网格 <code>grid</code>，请你找出边界全部由 <code>1</code> 组成的最大 <strong>正方形</strong> 子网格，并返回该子网格中的元素数量。如果不存在，则返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,1],[1,0,1],[1,1,1]]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,1,0,0]]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 100</code></li><li><code>1 &lt;= grid[0].length &lt;= 100</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>用动态规划解决，</p><p>在位置i,j，我们可以标记up[i][j]和left[i][j]。代表在ij位置左起最大连续1和上方最大连续1的数量。</p><p>而构成正方形的边长肯定是这两个连续1的数量的较小值，以这个值作为边长l，去寻找另外两个对角的长度，枚举出可以构成正方形的情况，然后更新最大边界的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largest1BorderedSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(),n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">left</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>)), <span class="hljs-built_in">up</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> maxborder = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<span class="hljs-comment">//因为下标不是从0开始</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)&#123;<br>                    left[i][j] = left[i][j<span class="hljs-number">-1</span>] +<span class="hljs-number">1</span>;<br>                    up[i][j] = up[i<span class="hljs-number">-1</span>][j] +<span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> border = <span class="hljs-built_in">min</span>(left[i][j],up[i][j]);<br>                    <span class="hljs-keyword">while</span>(left[i-border+<span class="hljs-number">1</span>][j]&lt;border||up[i][j-border+<span class="hljs-number">1</span>]&lt;border)&#123;<br>                        border--;<br>                    &#125;<br>                    maxborder = <span class="hljs-built_in">max</span>(maxborder,border);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxborder*maxborder;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++ Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230210</title>
    <link href="/2023/02/11/dailyProblem230210/"/>
    <url>/2023/02/11/dailyProblem230210/</url>
    
    <content type="html"><![CDATA[<h4 id="1223-掷骰子模拟"><a href="#1223-掷骰子模拟" class="headerlink" title="1223. 掷骰子模拟"></a><a href="https://leetcode.cn/problems/dice-roll-simulation/">1223. 掷骰子模拟</a></h4><p>难度困难</p><p>有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。</p><p>不过我们在使用它时有个约束，就是使得投掷骰子时，<strong>连续</strong> 掷出数字 <code>i</code> 的次数不能超过 <code>rollMax[i]</code>（<code>i</code> 从 1 开始编号）。</p><p>现在，给你一个整数数组 <code>rollMax</code> 和一个整数 <code>n</code>，请你来计算掷 <code>n</code> 次骰子可得到的不同点数序列的数量。</p><p>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 <strong>模 <code>10^9 + 7</code></strong> 之后的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷<span class="hljs-number"> 2 </span>次骰子，如果没有约束的话，共有<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 36 </span>种可能的组合。但是根据 rollMax 数组，数字<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 2 </span>最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">2</span>, rollMax = <span class="hljs-string">[1,1,1,1,1,1]</span><br>输出：<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：n = <span class="hljs-number">3</span>, rollMax = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">181</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>rollMax.length == 6</code></li><li><code>1 &lt;= rollMax[i] &lt;= 15</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>动态规划问题。</p><p>使用dp[i][j]来记录i位置时是j的序列数量，即长度为i的序列总数为dp[i][1~6]。</p><p>要怎么用上约束条件呢？</p><p>假设目前i位置上为X，分两种情况。</p><p>1，假如添加X后还没超过限制，就不做任何处理。</p><p>2，添加X后超过了限制，可知这必定是第一次超过限制，</p><p>如果都把可能性直接相加，那么可知是要减掉一些的。</p><p>假设数字5在第10位已经连续出现了4次，而5限制只能连续出现3次。那么就代表第6位是1，2，3，4，6。把这些数量减去就好了</p><p>于是状态方程为：<br>$$<br>\sum_{k&#x3D;1}^6dp[i-1][k] - \sum_{k&#x3D;1,k!&#x3D;j}^6dp[i-rollMax[j-1]-1][k]<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dieSimulator</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; rollMax)</span> </span>&#123;<br>        vector&lt;vector&lt;LL&gt; &gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;LL&gt;(<span class="hljs-number">7</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>            dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">6</span>; j++) &#123;<br>                <span class="hljs-comment">// 加入第 i-1 次得所有可能序列总数</span><br>                LL ans = <span class="hljs-built_in">accumulate</span>(dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">begin</span>(), dp[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<br>                <span class="hljs-type">int</span> idx = i - <span class="hljs-number">1</span> - rollMax[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span> (idx &gt;= <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 减去 i - 1 - rollMax[j-1]次掷出1，2，3，4，5 的所有序列总数</span><br>                    ans = <span class="hljs-built_in">accumulate</span>(dp[idx].<span class="hljs-built_in">begin</span>(), dp[idx].<span class="hljs-built_in">end</span>(), ans, [&amp;](LL init, LL e) &#123;<br>                        <span class="hljs-keyword">return</span> init + MOD - e;<br>                    &#125;);<br>                    ans += dp[idx][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 特殊情况处理</span><br>                    ans -= <span class="hljs-number">1</span>;<br>                &#125;<br>                dp[i][j] = ans % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp[n].<span class="hljs-built_in">begin</span>(), dp[n].<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>) % MOD;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230211</title>
    <link href="/2023/02/11/dailyProblem230211/"/>
    <url>/2023/02/11/dailyProblem230211/</url>
    
    <content type="html"><![CDATA[<h4 id="2335-装满杯子需要的最短总时长"><a href="#2335-装满杯子需要的最短总时长" class="headerlink" title="2335. 装满杯子需要的最短总时长"></a><a href="https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups/">2335. 装满杯子需要的最短总时长</a></h4><p>难度简单47</p><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 <strong>不同</strong> 类型的水或者 <code>1</code> 杯任意类型的水。</p><p>给你一个下标从 <strong>0</strong> 开始、长度为 <code>3</code> 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 <strong>最少</strong> 秒数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [1,4,2]<br>输出：4<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水。<br>可以证明最少需要<span class="hljs-number"> 4 </span>秒才能装满所有杯子。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：amount = [5,4,4]<br>输出：7<br>解释：下面给出一种方案：<br>第<span class="hljs-number"> 1 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 2 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 3 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 4 </span>秒：装满一杯温水和一杯热水。<br>第<span class="hljs-number"> 5 </span>秒：装满一杯冷水和一杯热水。<br>第<span class="hljs-number"> 6 </span>秒：装满一杯冷水和一杯温水。<br>第<span class="hljs-number"> 7 </span>秒：装满一杯热水。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：amount </span>=<span class="hljs-string"> [5,0,0]</span><br><span class="hljs-string">输出：5</span><br><span class="hljs-string">解释：每秒装满一杯冷水。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>amount.length == 3</code></li><li><code>0 &lt;= amount[i] &lt;= 100</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单的数学题，题中明确了只有三个杯子而一次可以倒两个杯子。</p><p>最少的次数肯定就是需求数量比较少的两个杯子之和与最多的那个杯子做差有关系。</p><p>因为一次能倒满两个杯子，就要争取每一次都有两个杯子可以倒。</p><p>用需求数量最多的杯子去调整剩下两个杯子的数量（使得用完最多的杯子的时候那两个杯子数量尽可能相等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fillCups</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; amount)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(amount.<span class="hljs-built_in">begin</span>(),amount.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span>((amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>])&lt;=amount[<span class="hljs-number">2</span>])&#123;<br>            <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> temp = amount[<span class="hljs-number">0</span>]+amount[<span class="hljs-number">1</span>]-amount[<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> amount[<span class="hljs-number">2</span>] + temp/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230208</title>
    <link href="/2023/02/08/dailyProblem230208/"/>
    <url>/2023/02/08/dailyProblem230208/</url>
    
    <content type="html"><![CDATA[<h4 id="1233-删除子文件夹"><a href="#1233-删除子文件夹" class="headerlink" title="1233. 删除子文件夹"></a><a href="https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/">1233. 删除子文件夹</a></h4><p>难度中等</p><p>你是一位系统管理员，手里有一份文件夹列表 <code>folder</code>，你的任务是要删除该列表中的所有 <strong>子文件夹</strong>，并以 <strong>任意顺序</strong> 返回剩下的文件夹。</p><p>如果文件夹 <code>folder[i]</code> 位于另一个文件夹 <code>folder[j]</code> 下，那么 <code>folder[i]</code> 就是 <code>folder[j]</code> 的 <strong>子文件夹</strong> 。</p><p>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：’&#x2F;‘ 后跟一个或者多个小写英文字母。</p><ul><li>例如，<code>&quot;/leetcode&quot;</code> 和 <code>&quot;/leetcode/problems&quot;</code> 都是有效的路径，而空字符串和 <code>&quot;/&quot;</code> 不是。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/d/e&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/c/d&quot;</span>,<span class="hljs-string">&quot;/c/f&quot;</span>]<br>解释：<span class="hljs-string">&quot;/a/b&quot;</span> 是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹，而 <span class="hljs-string">&quot;/c/d/e&quot;</span> 是 <span class="hljs-string">&quot;/c/d&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：folder = [<span class="hljs-string">&quot;/a&quot;</span>,<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出：[<span class="hljs-string">&quot;/a&quot;</span>]<br>解释：文件夹 <span class="hljs-string">&quot;/a/b/c&quot;</span> 和 <span class="hljs-string">&quot;/a/b/d&quot;</span> 都会被删除，因为它们都是 <span class="hljs-string">&quot;/a&quot;</span> 的子文件夹。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: folder = [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br>输出: [<span class="hljs-string">&quot;/a/b/c&quot;</span>,<span class="hljs-string">&quot;/a/b/ca&quot;</span>,<span class="hljs-string">&quot;/a/b/d&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= folder.length &lt;= 4 * 104</code></li><li><code>2 &lt;= folder[i].length &lt;= 100</code></li><li><code>folder[i]</code> 只包含小写字母和 <code>&#39;/&#39;</code></li><li><code>folder[i]</code> 总是以字符 <code>&#39;/&#39;</code> 起始</li><li>每个文件夹名都是 <strong>唯一</strong> 的</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>读完题目后，判断是否是子文件夹其实就是找子串。</p><p>因为目录的逻辑，解答的要求应该是，文件夹与子文件夹的路径只有开头部分重复。</p><p>并且按照文件夹的定义，字母间需要用 ‘&#x2F;’ 隔开。</p><p>所以解题的步骤就是，先将这些字符串排序（短的在前），然后给它添加一个 ‘&#x2F;’ 。</p><p>逐个验证是否是子串，如果是就标记为1，减少遍历次数以及标记答案。</p><p>因为即使是子串也有可能不是因为开头相同而匹配，所以还要额外验证一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = folder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">hash</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;string&gt; ans;<br>        <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(),folder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i] == <span class="hljs-number">0</span>)&#123;<br>                string temp = folder[i]+<span class="hljs-string">&#x27;/&#x27;</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>(folder[j].<span class="hljs-built_in">find</span>(temp)!=folder[j].npos&amp;&amp;temp[<span class="hljs-number">1</span>]==folder[j][<span class="hljs-number">1</span>])&#123;<br>                        hash[j] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(hash[i]==<span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(folder[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem230209</title>
    <link href="/2023/02/08/dailyProblem230209/"/>
    <url>/2023/02/08/dailyProblem230209/</url>
    
    <content type="html"><![CDATA[<h4 id="1797-设计一个验证系统"><a href="#1797-设计一个验证系统" class="headerlink" title="1797. 设计一个验证系统"></a><a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></h4><p>难度中等</p><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 <code>currentTime</code> 时刻之后 <code>timeToLive</code> 秒过期。如果验证码被更新了，那么它会在 <code>currentTime</code> （可能与之前的 <code>currentTime</code> 不同）时刻延长 <code>timeToLive</code> 秒。</p><p>请你实现 <code>AuthenticationManager</code> 类：</p><ul><li><code>AuthenticationManager(int timeToLive)</code> 构造 <code>AuthenticationManager</code> 并设置 <code>timeToLive</code> 参数。</li><li><code>generate(string tokenId, int currentTime)</code> 给定 <code>tokenId</code> ，在当前时间 <code>currentTime</code> 生成一个新的验证码。</li><li><code>renew(string tokenId, int currentTime)</code> 将给定 <code>tokenId</code> 且 <strong>未过期</strong> 的验证码在 <code>currentTime</code> 时刻更新。如果给定 <code>tokenId</code> 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。</li><li><code>countUnexpiredTokens(int currentTime)</code> 请返回在给定 <code>currentTime</code> 时刻，<strong>未过期</strong> 的验证码数目。</li></ul><p>如果一个验证码在时刻 <code>t</code> 过期，且另一个操作恰好在时刻 <code>t</code> 发生（<code>renew</code> 或者 <code>countUnexpiredTokens</code> 操作），过期事件 <strong>优先于</strong> 其他操作。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png" alt="img"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入：<br>[<span class="hljs-string">&quot;AuthenticationManager&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>, <span class="hljs-string">&quot;generate&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;renew&quot;</span>, <span class="hljs-string">&quot;countUnexpiredTokens&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>], [<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>], [<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">15</span>]]<br>输出：<br>[null, null, null, <span class="hljs-number">1</span>, null, null, null, <span class="hljs-number">0</span>]<br><br>解释：<br>AuthenticationManager authenticationManager = new AuthenticationManager(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> 构造 AuthenticationManager ，设置 timeToLive = <span class="hljs-number">5</span> 秒。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">1</span> 时，没有验证码的 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> ，没有验证码被更新。<br>authenticationManager.generate(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">2</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的新验证码。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">6</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">6</span> 时，只有 tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码未过期，所以返回 <span class="hljs-number">1</span> 。<br>authenticationManager.generate(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">7</span>); <span class="hljs-regexp">//</span> 时刻 <span class="hljs-number">7</span> 时，生成一个 tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的新验证码。<br>authenticationManager.renew(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-number">8</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，且 <span class="hljs-number">8</span> &gt;= <span class="hljs-number">7</span> ，所以时刻 <span class="hljs-number">8</span> 的renew 操作被忽略，没有验证码被更新。<br>authenticationManager.renew(<span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-number">10</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">10</span> 没有过期，所以 renew 操作会执行，该 token 将在时刻 <span class="hljs-number">15</span> 过期。<br>authenticationManager.countUnexpiredTokens(<span class="hljs-number">15</span>); <span class="hljs-regexp">//</span> tokenId 为 <span class="hljs-string">&quot;bbb&quot;</span> 的验证码在时刻 <span class="hljs-number">15</span> 过期，tokenId 为 <span class="hljs-string">&quot;aaa&quot;</span> 的验证码在时刻 <span class="hljs-number">7</span> 过期，所有验证码均已过期，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= timeToLive &lt;= 108</code></li><li><code>1 &lt;= currentTime &lt;= 108</code></li><li><code>1 &lt;= tokenId.length &lt;= 5</code></li><li><code>tokenId</code> 只包含小写英文字母。</li><li>所有 <code>generate</code> 函数的调用都会包含独一无二的 <code>tokenId</code> 值。</li><li>所有函数调用中，<code>currentTime</code> 的值 <strong>严格递增</strong> 。</li><li>所有函数的调用次数总共不超过 <code>2000</code> 次。</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>其实只是哈希表的分函数调用。所以均可访问的变量要在private定义。</p><p>用map给所有字符串和有效时间做映射，generate就初始化时间节点，renew就延长。</p><p>最后count的时候把所有字符串对应的时间和currentTime比较大小就可以返回答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> timeToLive;<br>    unordered_map&lt;string,<span class="hljs-type">int</span>&gt; valid;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AuthenticationManager</span>(<span class="hljs-type">int</span> timeToLive) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;timeToLive = timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generate</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        valid[tokenId] = currentTime + timeToLive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">renew</span><span class="hljs-params">(string tokenId, <span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (valid.<span class="hljs-built_in">count</span>(tokenId) &amp;&amp; valid[tokenId] &gt; currentTime) &#123;<span class="hljs-comment">//unorderedmap不能用find</span><br>            valid[tokenId] = currentTime + timeToLive;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countUnexpiredTokens</span><span class="hljs-params">(<span class="hljs-type">int</span> currentTime)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//for (auto &amp;[_, time] : mp) &#123;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = valid.<span class="hljs-built_in">begin</span>();it!=valid.<span class="hljs-built_in">end</span>();it++)&#123;<br>            <span class="hljs-keyword">if</span> (it -&gt; second &gt; currentTime) &#123;<br>                res++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your AuthenticationManager object will be instantiated and called as such:</span><br><span class="hljs-comment"> * AuthenticationManager* obj = new AuthenticationManager(timeToLive);</span><br><span class="hljs-comment"> * obj-&gt;generate(tokenId,currentTime);</span><br><span class="hljs-comment"> * obj-&gt;renew(tokenId,currentTime);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;countUnexpiredTokens(currentTime);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading-02</title>
    <link href="/2022/12/03/PaperReading-02/"/>
    <url>/2022/12/03/PaperReading-02/</url>
    
    <content type="html"><![CDATA[<h1 id="Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences"><a href="#Microsecond-scale-Preemption-for-Concurrent-GPU-accelerated-DNN-Inferences" class="headerlink" title="Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences"></a>Microsecond-scale Preemption for Concurrent GPU-accelerated DNN Inferences</h1><h4 id="A-Paper-summary"><a href="#A-Paper-summary" class="headerlink" title="A. Paper summary"></a>A. Paper summary</h4><h4 id="Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions"><a href="#Please-provide-a-short-summary-of-the-paper-that-captures-the-key-contributions" class="headerlink" title="Please provide a short summary of the paper that captures the key contributions."></a>Please provide a short summary of the paper that captures the key contributions.</h4><p>DNN inference tasks can be divided into two types according to whether it has real-time demand. However, current GPU scheduling systems don’t maintain throughput well while satisfying real-time preemption. To remedy this problem, this paper presented REEF, the first DNN inference serving system for commodity GPUs. It allows BE task to be executed with RT task without affecting it concurrently.</p><p>The two core technologies respectively are:</p><p>1, Reset-base Preemption: It is proved that the GPU based on DNN inference tasks is idempotent, so it can be quickly preempted by “kill”, and task can be recovery at breakpoints.</p><p>2, Dynamic Kernel Padding: Based on the observation of the predictability of delay of the GPU kernel of DNN inference tasks, the author proposes a controllable concurrent execution method, in the real-time kernel execution, according to its execution delay, dynamically fill the appropriate best-effort kernel with its concurrent execution.</p><h4 id="B-Key-strengths-and-weaknesses"><a href="#B-Key-strengths-and-weaknesses" class="headerlink" title="B. Key strengths and weaknesses"></a>B. Key strengths and weaknesses</h4><h4 id="Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively"><a href="#Please-provide-up-to-three-strengths-and-three-weaknesses-in-the-form-of-short-and-bullets-respectively" class="headerlink" title="Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively."></a>Please provide up to three strengths and three weaknesses, in the form of short (+) and (-) bullets, respectively.</h4><p>(+) REEF can preempt concurrent DNN tasks in Microsecond-scale.</p><p>(+) Compared with RT-Only in the DISB test, REEF can increase the throughput by 1.14~7.7 times under the premise of only increasing the latency of RT tasks by 2%.</p><p>(+) REEF are feasible for the closed-source GPUs, and evaluating result shows it reduces the preemption latency.</p><p>(-) When the execution time of best-effort kernels is often longer than that of real-time kernels, the throughput improvement of dynamic kernel padding may be trivial. But it also bring scheduling delay.</p><p>(-) Many commodity GPUs are closed-source, so REEF is unable to manipulate host queues and device queues directly.</p><p>(-) Latency predictability need to develop an offline kernel profiler to measure the computational requirements and the execution time. That is like a pretraining, which needs more time or computing power.</p><h4 id="C-Comments-to-authors"><a href="#C-Comments-to-authors" class="headerlink" title="C. Comments to authors"></a>C. Comments to authors</h4><h4 id="Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review"><a href="#Please-provide-detailed-comments-that-support-your-above-judgement-as-well-as-constructive-feedback-to-make-the-paper-stronger-This-should-constitute-the-meat-of-your-review" class="headerlink" title="Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review."></a>Please provide detailed comments that support your above judgement, as well as constructive feedback to make the paper stronger. This should constitute the meat of your review.</h4><p>For preemption, this paper shows REEF preemption delay is reduced by 15~18 times compared with existing methods. Not only promising RT tasks demand, but also maintain the throughput, which is instructive in some IoT scheme. Moreover, REEF-N runs on the closed-source GPUs such as NVIDIA and AMD GPUs. It’s available for Users and researchers. But the flaw is it cannot perform well as open source GPUs. In the end, I think if latency predicting judge RT tasks when they put into queue without offline measure in advance is better.</p><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1202</title>
    <link href="/2022/12/02/dailyProblem1202/"/>
    <url>/2022/12/02/dailyProblem1202/</url>
    
    <content type="html"><![CDATA[<h4 id="1769-移动所有球到每个盒子所需的最小操作数"><a href="#1769-移动所有球到每个盒子所需的最小操作数" class="headerlink" title="1769. 移动所有球到每个盒子所需的最小操作数"></a><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/">1769. 移动所有球到每个盒子所需的最小操作数</a></h4><p>难度中等</p><p>有 <code>n</code> 个盒子。给你一个长度为 <code>n</code> 的二进制字符串 <code>boxes</code> ，其中 <code>boxes[i]</code> 的值为 <code>&#39;0&#39;</code> 表示第 <code>i</code> 个盒子是 <strong>空</strong> 的，而 <code>boxes[i]</code> 的值为 <code>&#39;1&#39;</code> 表示盒子里有 <strong>一个</strong> 小球。</p><p>在一步操作中，你可以将 <strong>一个</strong> 小球从某个盒子移动到一个与之相邻的盒子中。第 <code>i</code> 个盒子和第 <code>j</code> 个盒子相邻需满足 <code>abs(i - j) == 1</code> 。注意，操作执行后，某些盒子中可能会存在不止一个小球。</p><p>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是将所有小球移动到第 <code>i</code> 个盒子所需的 <strong>最小</strong> 操作数。</p><p>每个 <code>answer[i]</code> 都需要根据盒子的 <strong>初始状态</strong> 进行计算。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：boxes = &quot;110&quot;<br>输出：[1,1,3]<br>解释：每个盒子对应的最小操作数如下：<br>1) 第<span class="hljs-number"> 1 </span>个盒子：将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 1 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>2) 第<span class="hljs-number"> 2 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 2 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。<br>3) 第<span class="hljs-number"> 3 </span>个盒子：将一个小球从第<span class="hljs-number"> 1 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 2 </span>步操作。将一个小球从第<span class="hljs-number"> 2 </span>个盒子移动到第<span class="hljs-number"> 3 </span>个盒子，需要<span class="hljs-number"> 1 </span>步操作。共计<span class="hljs-number"> 3 </span>步操作。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">boxes </span>= <span class="hljs-string">&quot;001011&quot;</span><br>输出：[<span class="hljs-number">11</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == boxes.length</code></li><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>boxes[i]</code> 为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>直观地理解，其实就是每一个小球都只能一步移动。</p><p>让所有球都集中到某个盒子，所需的次数其实就是小球与这个盒子的距离。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minOperations</span><span class="hljs-params">(string boxes)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = boxes.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(boxes[j]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                    ans[i] += <span class="hljs-built_in">abs</span>(i-j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PaperReading_01</title>
    <link href="/2022/11/29/PaperReading-01/"/>
    <url>/2022/11/29/PaperReading-01/</url>
    
    <content type="html"><![CDATA[<h1 id="L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites"><a href="#L2D2-Low-Latency-Distributed-Downlink-for-Low-Earth-Orbit-Satellites" class="headerlink" title="L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites"></a>L2D2: Low Latency Distributed Downlink for Low Earth Orbit Satellites</h1><h3 id="要解决什么问题？"><a href="#要解决什么问题？" class="headerlink" title="要解决什么问题？"></a>要解决什么问题？</h3><p>实时高分辨率的地球图片回传非常具有挑战性；因为轨道很低并且在高速移动。集中式架构的地面接收站会招致小时级别的数据下载延迟，并且因为造价原因难以扩展。作者希望降低数据回传时延。</p><h3 id="提出了什么架构-x2F-方法？"><a href="#提出了什么架构-x2F-方法？" class="headerlink" title="提出了什么架构&#x2F;方法？"></a>提出了什么架构&#x2F;方法？</h3><p>L2D2——地面分布式站点设计。</p><p>是使用低成本的商品硬件提供低时延和鲁棒下载链接的混合地面站模型，只有一部分地面站有上行链路功能。还设计了用于调度和速率自适应的新算法，尽管仅接收地面站存在局限性，但仍可实现低延迟和高鲁棒性。</p><h3 id="解决方案的关键是？"><a href="#解决方案的关键是？" class="headerlink" title="解决方案的关键是？"></a>解决方案的关键是？</h3><p>1，L2D2模型拥有全球分布式的地面站点</p><p>——使得卫星可以follow动态下行链路的调度，并降低了数据下行的时延。</p><p>2，混合式站点部署</p><p>——大部分站点只有接收功能，不传输任何数据，使得模型整体易于扩展。</p><p>3，低复杂度降低维护成本</p><p>——单个地面站没有专用设备，而是易于部署的商品硬件，通过多个地面站互补链路容量。</p><p>4，利用机器学习的方法来建模解决速率适应问题</p><p>——梯度提升回归树，基于深度学习的回归。</p><p><img src="C:\Users\Aki\OneDrive\桌面\model.png" alt="model"></p><h3 id="实验如何设计？"><a href="#实验如何设计？" class="headerlink" title="实验如何设计？"></a>实验如何设计？</h3><p>使用真实世界链路质量测量和模拟的组合</p><p>作者从 X 波段运行的 16 对地面站-卫星和在 Ka 波段运行的 1 对地面站-卫星对中收集真实世界的数据，</p><p>使用从开源的SatNOGS地面站部署收集的数据用于仿真来评估L2D2，这些地站会监听政府和学术机构卫星的广播信号，数据放在一个公开数据集。选择了可运行的地面站并且进行了至少 1000 次观察。</p><h3 id="有什么贡献？"><a href="#有什么贡献？" class="headerlink" title="有什么贡献？"></a>有什么贡献？</h3><p>提出了新的模型：仅能下载的和上下行皆可的。其地理分布式以及新的调度方案、速率适应方案使得L2D2可以从大规模的LEO中经过数分钟成功下载数据，而传统的则需要几个小时。由于设计比较简单、低成本，所以易于推广。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PaperReading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dailyProblem1129</title>
    <link href="/2022/11/29/dailyProblem1129/"/>
    <url>/2022/11/29/dailyProblem1129/</url>
    
    <content type="html"><![CDATA[<h4 id="1758-生成交替二进制字符串的最少操作数"><a href="#1758-生成交替二进制字符串的最少操作数" class="headerlink" title="1758. 生成交替二进制字符串的最少操作数"></a><a href="https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string/">1758. 生成交替二进制字符串的最少操作数</a></h4><p>给你一个仅由字符 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串 <code>s</code> 。一步操作中，你可以将任一 <code>&#39;0&#39;</code> 变成 <code>&#39;1&#39;</code> ，或者将 <code>&#39;1&#39;</code> 变成 <code>&#39;0&#39;</code> 。</p><p><strong>交替字符串</strong> 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 <code>&quot;010&quot;</code> 是交替字符串，而字符串 <code>&quot;0100&quot;</code> 不是。</p><p>返回使 <code>s</code> 变成 <strong>交替字符串</strong> 所需的 <strong>最少</strong> 操作数。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;0100&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：如果将最后一个字符变为 &#x27;1&#x27; ，s 就变成 <span class="hljs-string">&quot;0101&quot;</span> ，即符合交替字符串定义。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;10&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：s 已经是交替字符串。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1111&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：需要 <span class="hljs-number">2</span> 步操作得到 <span class="hljs-string">&quot;0101&quot;</span> 或 <span class="hljs-string">&quot;1010&quot;</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s[i]</code> 是 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>显然，答案字符串只有两种可能性，一种是0开头，另一种是1开头，然后让字符串s分别变成这两种字符串，取最小变化次数的一个就行。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt1=<span class="hljs-number">0</span>,cnt2=<span class="hljs-number">0</span>;<br>        string s2 = s;<br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            cnt1++;<br>            s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==s[i+<span class="hljs-number">1</span>])&#123;<br>                s[i+<span class="hljs-number">1</span>] = (s[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt1++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s2[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            cnt2++;<br>            s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;s2.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s2[i]==s2[i+<span class="hljs-number">1</span>])&#123;<br>                s2[i+<span class="hljs-number">1</span>] = (s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-number">1</span>)%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(cnt1,cnt2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LABOBASE TEST</title>
    <link href="/2022/11/18/LABOBASE-TEST/"/>
    <url>/2022/11/18/LABOBASE-TEST/</url>
    
    <content type="html"><![CDATA[<h1 id="再部署"><a href="#再部署" class="headerlink" title="再部署"></a>再部署</h1><p>在实验室也重新搭建了博客，以后用来update一些论文阅读，周报，以及题解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>LOG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/18/hello-world/"/>
    <url>/2022/11/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
